{"version":3,"file":"browser.global.js","sources":["../src/array/at.ts","../src/array/difference.ts","../src/array/differenceBy.ts","../src/array/differenceWith.ts","../src/array/flatten.ts","../src/array/head.ts","../src/array/intersection.ts","../src/array/intersectionBy.ts","../src/array/intersectionWith.ts","../src/math/random.ts","../src/math/randomInt.ts","../src/array/uniq.ts","../src/array/union.ts","../src/array/unionBy.ts","../src/array/uniqWith.ts","../src/array/unionWith.ts","../src/array/zip.ts","../src/error/AbortError.ts","../src/error/TimeoutError.ts","../src/function/debounce.ts","../src/function/noop.ts","../src/function/ary.ts","../src/function/partial.ts","../src/function/partialRight.ts","../src/math/sum.ts","../src/math/mean.ts","../src/predicate/isTypedArray.ts","../src/predicate/isPrimitive.ts","../src/object/clone.ts","../src/predicate/isPlainObject.ts","../src/object/flattenObject.ts","../src/object/mapKeys.ts","../src/object/mapValues.ts","../src/object/cloneDeep.ts","../src/compat/predicate/isObjectLike.ts","../src/object/merge.ts","../src/compat/_internal/tags.ts","../src/compat/_internal/getSymbols.ts","../src/compat/_internal/getTag.ts","../src/predicate/isEqual.ts","../src/predicate/isLength.ts","../src/promise/delay.ts","../src/promise/timeout.ts","../src/string/capitalize.ts","../src/string/_internal/getWords.ts","../src/string/trimStart.ts","../src/string/trimEnd.ts","../src/string/trim.ts","../src/string/deburr.ts","../src/string/escape.ts","../src/string/unescape.ts","../src/compat/_internal/isDeepKey.ts","../src/compat/_internal/toKey.ts","../src/compat/util/toPath.ts","../src/compat/object/get.ts","../src/compat/object/property.ts","../src/compat/predicate/isMatch.ts","../src/compat/predicate/matches.ts","../src/compat/object/cloneDeep.ts","../src/compat/_internal/isIndex.ts","../src/compat/predicate/isArguments.ts","../src/compat/object/has.ts","../src/compat/predicate/matchesProperty.ts","../src/compat/array/flatten.ts","../src/compat/_internal/compareValues.ts","../src/compat/predicate/isSymbol.ts","../src/compat/_internal/isKey.ts","../src/compat/array/orderBy.ts","../src/compat/_internal/identity.ts","../src/compat/object/set.ts","../src/compat/function/bind.ts","../src/compat/function/bindKey.ts","../src/compat/function/curry.ts","../src/compat/function/debounce.ts","../src/compat/predicate/isNil.ts","../src/compat/object/unset.ts","../src/compat/predicate/isPlainObject.ts","../src/compat/predicate/isTypedArray.ts","../src/compat/object/mergeWith.ts","../src/compat/predicate/isArrayLike.ts","../src/compat/predicate/conformsTo.ts","../src/compat/util/toString.ts","../src/compat/_internal/normalizeForCase.ts","../src/compat/math/clamp.ts","../src/math/clamp.ts","../src/compat/_internal/decimalAdjust.ts","../src/function/after.ts","../src/compat/function/ary.ts","../src/compat/function/attempt.ts","../src/function/before.ts","../src/compat/string/camelCase.ts","../src/string/camelCase.ts","../src/compat/array/castArray.ts","../src/compat/math/ceil.ts","../src/compat/array/chunk.ts","../src/array/chunk.ts","../src/array/compact.ts","../src/compat/array/concat.ts","../src/compat/predicate/conforms.ts","../src/array/countBy.ts","../src/compat/array/difference.ts","../src/compat/array/drop.ts","../src/array/dropRight.ts","../src/array/dropRightWhile.ts","../src/array/dropWhile.ts","../src/compat/string/endsWith.ts","../src/string/escapeRegExp.ts","../src/compat/array/fill.ts","../src/array/fill.ts","../src/compat/array/find.ts","../src/compat/array/findIndex.ts","../src/compat/array/findLastIndex.ts","../src/array/flatMap.ts","../src/array/flatMapDeep.ts","../src/array/flattenDeep.ts","../src/compat/array/flattenDeep.ts","../src/compat/array/flattenDepth.ts","../src/compat/math/floor.ts","../src/array/forEachRight.ts","../src/compat/object/fromPairs.ts","../src/array/groupBy.ts","../src/compat/math/inRange.ts","../src/math/inRange.ts","../src/compat/array/indexOf.ts","../src/array/initial.ts","../src/object/invert.ts","../src/compat/predicate/isArray.ts","../src/compat/predicate/isArrayLikeObject.ts","../src/compat/predicate/isBoolean.ts","../src/predicate/isDate.ts","../src/predicate/isFunction.ts","../src/compat/predicate/isInteger.ts","../src/compat/predicate/isNaN.ts","../src/predicate/isNotNil.ts","../src/predicate/isNull.ts","../src/compat/predicate/isNumber.ts","../src/compat/predicate/isObject.ts","../src/compat/predicate/isRegExp.ts","../src/compat/predicate/isSafeInteger.ts","../src/compat/predicate/isString.ts","../src/array/isSubset.ts","../src/predicate/isUndefined.ts","../src/compat/predicate/isWeakMap.ts","../src/predicate/isWeakMap.ts","../src/compat/predicate/isWeakSet.ts","../src/predicate/isWeakSet.ts","../src/compat/array/join.ts","../src/compat/string/kebabCase.ts","../src/string/kebabCase.ts","../src/array/keyBy.ts","../src/array/last.ts","../src/compat/string/lowerCase.ts","../src/string/lowerCase.ts","../src/string/lowerFirst.ts","../src/compat/object/mapKeys.ts","../src/compat/object/mapValues.ts","../src/compat/math/max.ts","../src/array/maxBy.ts","../src/math/meanBy.ts","../src/function/memoize.ts","../src/compat/object/merge.ts","../src/compat/math/min.ts","../src/array/minBy.ts","../src/function/negate.ts","../src/compat/object/omit.ts","../src/object/omitBy.ts","../src/function/once.ts","../src/string/pad.ts","../src/compat/string/padEnd.ts","../src/compat/string/padStart.ts","../src/compat/math/parseInt.ts","../src/array/partition.ts","../src/string/pascalCase.ts","../src/compat/object/pick.ts","../src/object/pickBy.ts","../src/array/pullAt.ts","../src/compat/math/random.ts","../src/math/range.ts","../src/compat/function/rearg.ts","../src/compat/string/repeat.ts","../src/compat/function/rest.ts","../src/function/rest.ts","../src/compat/math/round.ts","../src/array/sample.ts","../src/array/sampleSize.ts","../src/array/shuffle.ts","../src/compat/array/size.ts","../src/predicate/isNil.ts","../src/compat/string/snakeCase.ts","../src/string/snakeCase.ts","../src/compat/array/some.ts","../src/compat/array/sortBy.ts","../src/compat/function/spread.ts","../src/compat/string/startCase.ts","../src/string/startCase.ts","../src/compat/string/startsWith.ts","../src/math/sumBy.ts","../src/array/tail.ts","../src/array/take.ts","../src/array/takeRight.ts","../src/array/takeRightWhile.ts","../src/array/takeWhile.ts","../src/compat/function/throttle.ts","../src/array/toFilled.ts","../src/object/toMerged.ts","../src/compat/string/trim.ts","../src/compat/string/trimEnd.ts","../src/compat/string/trimStart.ts","../src/function/unary.ts","../src/array/uniqBy.ts","../src/array/unzip.ts","../src/array/unzipWith.ts","../src/compat/string/upperCase.ts","../src/string/upperCase.ts","../src/string/upperFirst.ts","../src/promise/withTimeout.ts","../src/array/without.ts","../src/array/xor.ts","../src/array/xorBy.ts","../src/array/xorWith.ts","../src/array/zipObject.ts","../src/compat/array/zipObjectDeep.ts","../src/array/zipWith.ts"],"sourcesContent":["/**\r\n * Retrieves elements from an array at the specified indices.\r\n *\r\n * This function supports negative indices, which count from the end of the array.\r\n *\r\n * @template T\r\n * @param {readonly T[]} arr - The array to retrieve elements from.\r\n * @param {number[]} indices - An array of indices specifying the positions of elements to retrieve.\r\n * @returns {Array<T | undefined>} A new array containing the elements at the specified indices.\r\n *\r\n * @example\r\n * const numbers = [10, 20, 30, 40, 50];\r\n * const result = at(numbers, [1, 3, 4]);\r\n * console.log(result); // [20, 40, 50]\r\n */\r\nexport function at<T>(arr: readonly T[], indices: number[]): Array<T | undefined> {\r\n  const result: Array<T | undefined> = [];\r\n\r\n  for (let i = 0; i < indices.length; i++) {\r\n    const index = indices[i];\r\n\r\n    result[i] = arr.at(index);\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Computes the difference between two arrays.\r\n *\r\n * This function takes two arrays and returns a new array containing the elements\r\n * that are present in the first array but not in the second array. It effectively\r\n * filters out any elements from the first array that also appear in the second array.\r\n *\r\n * @template T\r\n * @param {T[]} firstArr - The array from which to derive the difference. This is the primary array\r\n * from which elements will be compared and filtered.\r\n * @param {T[]} secondArr - The array containing elements to be excluded from the first array.\r\n * Each element in this array will be checked against the first array, and if a match is found,\r\n * that element will be excluded from the result.\r\n * @returns {T[]} A new array containing the elements that are present in the first array but not\r\n * in the second array.\r\n *\r\n * @example\r\n * const array1 = [1, 2, 3, 4, 5];\r\n * const array2 = [2, 4];\r\n * const result = difference(array1, array2);\r\n * // result will be [1, 3, 5] since 2 and 4 are in both arrays and are excluded from the result.\r\n */\r\nexport function difference<T>(firstArr: readonly T[], secondArr: readonly T[]): T[] {\r\n  const secondSet = new Set(secondArr);\r\n\r\n  return firstArr.filter(item => !secondSet.has(item));\r\n}\r\n","/**\r\n * Computes the difference between two arrays after mapping their elements through a provided function.\r\n *\r\n * This function takes two arrays and a mapper function. It returns a new array containing the elements\r\n * that are present in the first array but not in the second array, based on the identity calculated\r\n * by the mapper function.\r\n *\r\n * Essentially, it filters out any elements from the first array that, when\r\n * mapped, match an element in the mapped version of the second array.\r\n *\r\n * @template T, U\r\n * @param {T[]} firstArr - The primary array from which to derive the difference.\r\n * @param {T[]} secondArr - The array containing elements to be excluded from the first array.\r\n * @param {(value: T) => U} mapper - The function to map the elements of both arrays. This function\r\n * is applied to each element in both arrays, and the comparison is made based on the mapped values.\r\n * @returns {T[]} A new array containing the elements from the first array that do not have a corresponding\r\n * mapped identity in the second array.\r\n *\r\n * @example\r\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\r\n * const array2 = [{ id: 2 }, { id: 4 }];\r\n * const mapper = item => item.id;\r\n * const result = differenceBy(array1, array2, mapper);\r\n * // result will be [{ id: 1 }, { id: 3 }] since the elements with id 2 are in both arrays and are excluded from the result.\r\n */\r\nexport function differenceBy<T, U>(firstArr: readonly T[], secondArr: readonly T[], mapper: (value: T) => U): T[] {\r\n  const mappedSecondSet = new Set(secondArr.map(item => mapper(item)));\r\n\r\n  return firstArr.filter(item => {\r\n    return !mappedSecondSet.has(mapper(item));\r\n  });\r\n}\r\n","/**\r\n * Computes the difference between two arrays based on a custom equality function.\r\n *\r\n * This function takes two arrays and a custom comparison function. It returns a new array containing\r\n * the elements that are present in the first array but not in the second array. The comparison to determine\r\n * if elements are equal is made using the provided custom function.\r\n *\r\n * @template T\r\n * @param {T[]} firstArr - The array from which to get the difference.\r\n * @param {T[]} secondArr - The array containing elements to exclude from the first array.\r\n * @param {(x: T, y: T) => boolean} areItemsEqual - A function to determine if two items are equal.\r\n * @returns {T[]} A new array containing the elements from the first array that do not match any elements in the second array\r\n * according to the custom equality function.\r\n *\r\n * @example\r\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\r\n * const array2 = [{ id: 2 }, { id: 4 }];\r\n * const areItemsEqual = (a, b) => a.id === b.id;\r\n * const result = differenceWith(array1, array2, areItemsEqual);\r\n * // result will be [{ id: 1 }, { id: 3 }] since the elements with id 2 are considered equal and are excluded from the result.\r\n */\r\nexport function differenceWith<T>(\r\n  firstArr: readonly T[],\r\n  secondArr: readonly T[],\r\n  areItemsEqual: (x: T, y: T) => boolean\r\n): T[] {\r\n  return firstArr.filter(firstItem => {\r\n    return secondArr.every(secondItem => {\r\n      return !areItemsEqual(firstItem, secondItem);\r\n    });\r\n  });\r\n}\r\n","/**\r\n * Flattens an array up to the specified depth.\r\n *\r\n * @template T - The type of elements within the array.\r\n * @template D - The depth to which the array should be flattened.\r\n * @param {T[]} arr - The array to flatten.\r\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\r\n * @returns {Array<FlatArray<T[], D>>} A new array that has been flattened.\r\n *\r\n * @example\r\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 1);\r\n * // Returns: [1, 2, 3, 4, [5, 6]]\r\n *\r\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 2);\r\n * // Returns: [1, 2, 3, 4, 5, 6]\r\n */\r\nexport function flatten<T, D extends number = 1>(arr: readonly T[], depth = 1 as D): Array<FlatArray<T[], D>> {\r\n  const result: Array<FlatArray<T[], D>> = [];\r\n  const flooredDepth = Math.floor(depth);\r\n\r\n  const recursive = (arr: readonly T[], currentDepth: number) => {\r\n    for (const item of arr) {\r\n      if (Array.isArray(item) && currentDepth < flooredDepth) {\r\n        recursive(item, currentDepth + 1);\r\n      } else {\r\n        result.push(item as FlatArray<T[], D>);\r\n      }\r\n    }\r\n  };\r\n\r\n  recursive(arr, 0);\r\n  return result;\r\n}\r\n","/**\r\n * Returns the first element of an array.\r\n *\r\n * This function takes an array and returns the first element of the array.\r\n * If the array is empty, the function returns `undefined`.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {[T, ...T[]]} arr - A non-empty array from which to get the first element.\r\n * @returns {T} The first element of the array.\r\n *\r\n * @example\r\n * const arr = [1, 2, 3];\r\n * const firstElement = head(arr);\r\n * // firstElement will be 1\r\n */\r\nexport function head<T>(arr: readonly [T, ...T[]]): T;\r\n\r\n/**\r\n * Returns the first element of an array or `undefined` if the array is empty.\r\n *\r\n * This function takes an array and returns the first element of the array.\r\n * If the array is empty, the function returns `undefined`.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array from which to get the first element.\r\n * @returns {T | undefined} The first element of the array, or `undefined` if the array is empty.\r\n *\r\n * @example\r\n * const emptyArr: number[] = [];\r\n * const noElement = head(emptyArr);\r\n * // noElement will be undefined\r\n */\r\nexport function head<T>(arr: readonly T[]): T | undefined;\r\n\r\n/**\r\n * Returns the first element of an array or `undefined` if the array is empty.\r\n *\r\n * This function takes an array and returns the first element of the array.\r\n * If the array is empty, the function returns `undefined`.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array from which to get the first element.\r\n * @returns {T | undefined} The first element of the array, or `undefined` if the array is empty.\r\n *\r\n * @example\r\n * const emptyArr: number[] = [];\r\n * const noElement = head(emptyArr);\r\n * // noElement will be undefined\r\n */\r\nexport function head<T>(arr: readonly T[]): T | undefined {\r\n  return arr[0];\r\n}\r\n","/**\r\n * Returns the intersection of two arrays.\r\n *\r\n * This function takes two arrays and returns a new array containing the elements that are\r\n * present in both arrays. It effectively filters out any elements from the first array that\r\n * are not found in the second array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} firstArr - The first array to compare.\r\n * @param {T[]} secondArr - The second array to compare.\r\n * @returns {T[]} A new array containing the elements that are present in both arrays.\r\n *\r\n * @example\r\n * const array1 = [1, 2, 3, 4, 5];\r\n * const array2 = [3, 4, 5, 6, 7];\r\n * const result = intersection(array1, array2);\r\n * // result will be [3, 4, 5] since these elements are in both arrays.\r\n */\r\nexport function intersection<T>(firstArr: readonly T[], secondArr: readonly T[]): T[] {\r\n  const secondSet = new Set(secondArr);\r\n\r\n  return firstArr.filter(item => {\r\n    return secondSet.has(item);\r\n  });\r\n}\r\n","/**\r\n * Returns the intersection of two arrays based on a mapping function.\r\n *\r\n * This function takes two arrays and a mapping function. It returns a new array containing\r\n * the elements from the first array that, when mapped using the provided function, have matching\r\n * mapped elements in the second array. It effectively filters out any elements from the first array\r\n * that do not have corresponding mapped values in the second array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @template U - The type of mapped elements.\r\n * @param {T[]} firstArr - The first array to compare.\r\n * @param {T[]} secondArr - The second array to compare.\r\n * @param {(item: T) => U} mapper - A function to map the elements of both arrays for comparison.\r\n * @returns {T[]} A new array containing the elements from the first array that have corresponding mapped values in the second array.\r\n *\r\n * @example\r\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\r\n * const array2 = [{ id: 2 }, { id: 4 }];\r\n * const mapper = item => item.id;\r\n * const result = intersectionBy(array1, array2, mapper);\r\n * // result will be [{ id: 2 }] since only this element has a matching id in both arrays.\r\n */\r\nexport function intersectionBy<T, U>(firstArr: readonly T[], secondArr: readonly T[], mapper: (item: T) => U): T[] {\r\n  const mappedSecondSet = new Set(secondArr.map(mapper));\r\n  return firstArr.filter(item => mappedSecondSet.has(mapper(item)));\r\n}\r\n","/**\r\n * Returns the intersection of two arrays based on a custom equality function.\r\n *\r\n * This function takes two arrays and a custom equality function. It returns a new array containing\r\n * the elements from the first array that have matching elements in the second array, as determined\r\n * by the custom equality function. It effectively filters out any elements from the first array that\r\n * do not have corresponding matches in the second array according to the equality function.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} firstArr - The first array to compare.\r\n * @param {T[]} secondArr - The second array to compare.\r\n * @param {(x: T, y: T) => boolean} areItemsEqual - A custom function to determine if two elements are equal.\r\n * This function takes two arguments, one from each array, and returns `true` if the elements are considered equal, and `false` otherwise.\r\n * @returns {T[]} A new array containing the elements from the first array that have corresponding matches in the second array according to the custom equality function.\r\n *\r\n * @example\r\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\r\n * const array2 = [{ id: 2 }, { id: 4 }];\r\n * const areItemsEqual = (a, b) => a.id === b.id;\r\n * const result = intersectionWith(array1, array2, areItemsEqual);\r\n * // result will be [{ id: 2 }] since this element has a matching id in both arrays.\r\n */\r\nexport function intersectionWith<T>(\r\n  firstArr: readonly T[],\r\n  secondArr: readonly T[],\r\n  areItemsEqual: (x: T, y: T) => boolean\r\n): T[] {\r\n  return firstArr.filter(firstItem => {\r\n    return secondArr.some(secondItem => {\r\n      return areItemsEqual(firstItem, secondItem);\r\n    });\r\n  });\r\n}\r\n","/**\r\n * Generate a random number within the given range.\r\n *\r\n * If only one argument is provided, a number between `0` and the given number is returned.\r\n *\r\n * @param {number} maximum - The upper bound (exclusive).\r\n * @returns {number} A random number between 0 (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\r\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\r\n *\r\n * @example\r\n * const result1 = random(5); // Returns a random number between 0 and 5.\r\n * const result2 = random(0); // Returns a random number between 0 and 0 (which is 0).\r\n */\r\nexport function random(maximum: number): number;\r\n\r\n/**\r\n * Generate a random number within the given range.\r\n *\r\n * @param {number} minimum - The lower bound (inclusive).\r\n * @param {number} maximum - The upper bound (exclusive).\r\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\r\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\r\n *\r\n * @example\r\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\r\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown.\r\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\r\n */\r\nexport function random(minimum: number, maximum: number): number;\r\n\r\n/**\r\n * Generate a random number within the given range.\r\n *\r\n * @param {number} minimum - The lower bound (inclusive).\r\n * @param {number} maximum - The upper bound (exclusive).\r\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\r\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\r\n *\r\n * @example\r\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\r\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown.\r\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\r\n */\r\nexport function random(minimum: number, maximum?: number): number {\r\n  if (maximum == null) {\r\n    maximum = minimum;\r\n    minimum = 0;\r\n  }\r\n\r\n  if (minimum >= maximum) {\r\n    throw new Error('Invalid input: The maximum value must be greater than the minimum value.');\r\n  }\r\n\r\n  return Math.random() * (maximum - minimum) + minimum;\r\n}\r\n","import { random } from './random.ts';\r\n\r\n/**\r\n * Generates a random integer between 0 (inclusive) and the given maximum (exclusive).\r\n *\r\n * @param {number} maximum - The upper bound (exclusive).\r\n * @returns {number} A random integer between 0 (inclusive) and maximum (exclusive).\r\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\r\n *\r\n * @example\r\n * const result = randomInt(5); // result will be a random integer between 0 (inclusive) and 5 (exclusive)\r\n */\r\nexport function randomInt(maximum: number): number;\r\n\r\n/**\r\n * Generates a random integer between minimum (inclusive) and maximum (exclusive).\r\n *\r\n * @param {number} minimum - The lower bound (inclusive).\r\n * @param {number} maximum - The upper bound (exclusive).\r\n * @returns {number} A random integer between minimum (inclusive) and maximum (exclusive).\r\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\r\n *\r\n * @example\r\n * const result = randomInt(0, 5); // result will be a random integer between 0 (inclusive) and 5 (exclusive)\r\n * const result2 = randomInt(5, 0); // This will throw an error\r\n */\r\nexport function randomInt(minimum: number, maximum: number): number;\r\n\r\n/**\r\n * Generates a random integer between minimum (inclusive) and maximum (exclusive).\r\n *\r\n * If only one argument is provided, a number between `0` and the given number is returned.\r\n *\r\n * @param {number} minimum - The lower bound (inclusive).\r\n * @param {number} maximum - The upper bound (exclusive).\r\n * @returns {number} A random integer between minimum (inclusive) and maximum (exclusive).\r\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\r\n *\r\n * @example\r\n * const result = randomInt(0, 5); // result will be a random integer between 0 (inclusive) and 5 (exclusive)\r\n * const result2 = randomInt(5, 0); // This will throw an error\r\n */\r\nexport function randomInt(minimum: number, maximum?: number): number {\r\n  return Math.floor(random(minimum, maximum!));\r\n}\r\n","/**\r\n * Creates a duplicate-free version of an array.\r\n *\r\n * This function takes an array and returns a new array containing only the unique values\r\n * from the original array, preserving the order of first occurrence.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to process.\r\n * @returns {T[]} A new array with only unique values from the original array.\r\n *\r\n * @example\r\n * const array = [1, 2, 2, 3, 4, 4, 5];\r\n * const result = uniq(array);\r\n * // result will be [1, 2, 3, 4, 5]\r\n */\r\nexport function uniq<T>(arr: readonly T[]): T[] {\r\n  return Array.from(new Set(arr));\r\n}\r\n","import { uniq } from './uniq.ts';\r\n\r\n/**\r\n * Creates an array of unique values from all given arrays.\r\n *\r\n * This function takes two arrays, merges them into a single array, and returns a new array\r\n * containing only the unique values from the merged array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr1 - The first array to merge and filter for unique values.\r\n * @param {T[]} arr2 - The second array to merge and filter for unique values.\r\n * @returns {T[]} A new array of unique values.\r\n *\r\n * @example\r\n * const array1 = [1, 2, 3];\r\n * const array2 = [3, 4, 5];\r\n * const result = union(array1, array2);\r\n * // result will be [1, 2, 3, 4, 5]\r\n */\r\nexport function union<T>(arr1: readonly T[], arr2: readonly T[]): T[] {\r\n  return uniq(arr1.concat(arr2));\r\n}\r\n","/**\r\n * Creates an array of unique values, in order, from all given arrays using a provided mapping function to determine equality.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @template U - The type of mapped elements.\r\n * @param {T[]} arr1 - The first array.\r\n * @param {T[]} arr2 - The second array.\r\n * @param {(item: T) => U} mapper - The function to map array elements to comparison values.\r\n * @returns {T[]} A new array containing the union of unique elements from `arr1` and `arr2`, based on the values returned by the mapping function.\r\n *\r\n * @example\r\n * // Custom mapping function for numbers (modulo comparison)\r\n * const moduloMapper = (x) => x % 3;\r\n * unionBy([1, 2, 3], [4, 5, 6], moduloMapper);\r\n * // Returns [1, 2, 3]\r\n *\r\n * @example\r\n * // Custom mapping function for objects with an 'id' property\r\n * const idMapper = (obj) => obj.id;\r\n * unionBy([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], idMapper);\r\n * // Returns [{ id: 1 }, { id: 2 }, { id: 3 }]\r\n */\r\nexport function unionBy<T, U>(arr1: readonly T[], arr2: readonly T[], mapper: (item: T) => U): T[] {\r\n  const map = new Map<U, T>();\r\n\r\n  for (const item of [...arr1, ...arr2]) {\r\n    const key = mapper(item);\r\n\r\n    if (!map.has(key)) {\r\n      map.set(key, item);\r\n    }\r\n  }\r\n\r\n  return Array.from(map.values());\r\n}\r\n","/**\r\n * Returns a new array containing only the unique elements from the original array,\r\n * based on the values returned by the comparator function.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to process.\r\n * @param {(item1: T, item2: T) => boolean} areItemsEqual - The function used to compare the array elements.\r\n * @returns {T[]} A new array containing only the unique elements from the original array, based on the values returned by the comparator function.\r\n *\r\n * @example\r\n * ```ts\r\n * uniqWith([1.2, 1.5, 2.1, 3.2, 5.7, 5.3, 7.19], (a, b) => Math.abs(a - b) < 1);\r\n * // [1.2, 3.2, 5.7, 7.19]\r\n * ```\r\n */\r\nexport function uniqWith<T>(arr: readonly T[], areItemsEqual: (item1: T, item2: T) => boolean): T[] {\r\n  const result: T[] = [];\r\n\r\n  for (const item of arr) {\r\n    const isUniq = result.every(v => !areItemsEqual(v, item));\r\n\r\n    if (isUniq) {\r\n      result.push(item);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { uniqWith } from './uniqWith.ts';\r\n\r\n/**\r\n * Creates an array of unique values from two given arrays based on a custom equality function.\r\n *\r\n * This function takes two arrays and a custom equality function, merges the arrays, and returns\r\n * a new array containing only the unique values as determined by the custom equality function.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr1 - The first array to merge and filter for unique values.\r\n * @param {T[]} arr2 - The second array to merge and filter for unique values.\r\n * @param {(item1: T, item2: T) => boolean} areItemsEqual - A custom function to determine if two elements are equal.\r\n * It takes two arguments and returns `true` if the elements are considered equal, and `false` otherwise.\r\n * @returns {T[]} A new array of unique values based on the custom equality function.\r\n *\r\n * @example\r\n * const array1 = [{ id: 1 }, { id: 2 }];\r\n * const array2 = [{ id: 2 }, { id: 3 }];\r\n * const areItemsEqual = (a, b) => a.id === b.id;\r\n * const result = unionWith(array1, array2, areItemsEqual);\r\n * // result will be [{ id: 1 }, { id: 2 }, { id: 3 }] since { id: 2 } is considered equal in both arrays\r\n */\r\nexport function unionWith<T>(\r\n  arr1: readonly T[],\r\n  arr2: readonly T[],\r\n  areItemsEqual: (item1: T, item2: T) => boolean\r\n): T[] {\r\n  return uniqWith(arr1.concat(arr2), areItemsEqual);\r\n}\r\n","/**\r\n * Combines multiple arrays into a single array of tuples.\r\n *\r\n * This function takes multiple arrays and returns a new array where each element is a tuple\r\n * containing the corresponding elements from the input arrays. If the input arrays are of\r\n * different lengths, the resulting array will have the length of the longest input array,\r\n * with undefined values for missing elements.\r\n *\r\n * @template T\r\n * @param {T[]} arr1 - The first array to zip.\r\n * @returns {Array<[T]>} A new array of tuples containing the corresponding elements from the input arrays.\r\n *\r\n * @example\r\n * const arr1 = [1, 2, 3];\r\n * const result = zip(arr1);\r\n * // result will be [[1], [2], [3]]\r\n */\r\nexport function zip<T>(arr1: readonly T[]): Array<[T]>;\r\n\r\n/**\r\n * Combines multiple arrays into a single array of tuples.\r\n *\r\n * This function takes multiple arrays and returns a new array where each element is a tuple\r\n * containing the corresponding elements from the input arrays. If the input arrays are of\r\n * different lengths, the resulting array will have the length of the longest input array,\r\n * with undefined values for missing elements.\r\n *\r\n * @template T, U\r\n * @param {T[]} arr1 - The first array to zip.\r\n * @param {U[]} arr2 - The second array to zip.\r\n * @returns {Array<[T, U]>} A new array of tuples containing the corresponding elements from the input arrays.\r\n *\r\n * @example\r\n * const arr1 = [1, 2, 3];\r\n * const arr2 = ['a', 'b', 'c'];\r\n * const result = zip(arr1, arr2);\r\n * // result will be [[1, 'a'], [2, 'b'], [3, 'c']]\r\n */\r\nexport function zip<T, U>(arr1: readonly T[], arr2: readonly U[]): Array<[T, U]>;\r\n\r\n/**\r\n * Combines multiple arrays into a single array of tuples.\r\n *\r\n * This function takes multiple arrays and returns a new array where each element is a tuple\r\n * containing the corresponding elements from the input arrays. If the input arrays are of\r\n * different lengths, the resulting array will have the length of the longest input array,\r\n * with undefined values for missing elements.\r\n *\r\n * @template T, U, V\r\n * @param {T[]} arr1 - The first array to zip.\r\n * @param {U[]} arr2 - The second array to zip.\r\n * @param {V[]} arr3 - The third array to zip.\r\n * @returns {Array<[T, U, V]>} A new array of tuples containing the corresponding elements from the input arrays.\r\n *\r\n * @example\r\n * const arr1 = [1, 2, 3];\r\n * const arr2 = ['a', 'b', 'c'];\r\n * const arr3 = [true, false];\r\n * const result = zip(arr1, arr2, arr3);\r\n * // result will be [[1, 'a', true], [2, 'b', false], [3, 'c', undefined]]\r\n */\r\nexport function zip<T, U, V>(arr1: readonly T[], arr2: readonly U[], arr3: readonly V[]): Array<[T, U, V]>;\r\n\r\n/**\r\n * Combines multiple arrays into a single array of tuples.\r\n *\r\n * This function takes multiple arrays and returns a new array where each element is a tuple\r\n * containing the corresponding elements from the input arrays. If the input arrays are of\r\n * different lengths, the resulting array will have the length of the longest input array,\r\n * with undefined values for missing elements.\r\n *\r\n * @template T, U, V, W\r\n * @param {T[]} arr1 - The first array to zip.\r\n * @param {U[]} arr2 - The second array to zip.\r\n * @param {V[]} arr3 - The third array to zip.\r\n * @param {W[]} arr4 - The fourth array to zip.\r\n * @returns {Array<[T, U, V, W]>} A new array of tuples containing the corresponding elements from the input arrays.\r\n *\r\n * @example\r\n * const arr1 = [1, 2, 3];\r\n * const arr2 = ['a', 'b', 'c'];\r\n * const arr3 = [true, false];\r\n * const arr4 = [null, null, null];\r\n * const result = zip(arr1, arr2, arr3, arr4);\r\n * // result will be [[1, 'a', true, null], [2, 'b', false, null], [3, 'c', undefined, null]]\r\n */\r\nexport function zip<T, U, V, W>(\r\n  arr1: readonly T[],\r\n  arr2: readonly U[],\r\n  arr3: readonly V[],\r\n  arr4: readonly W[]\r\n): Array<[T, U, V, W]>;\r\n\r\n/**\r\n * Combines multiple arrays into a single array of tuples.\r\n *\r\n * This function takes multiple arrays and returns a new array where each element is a tuple\r\n * containing the corresponding elements from the input arrays. If the input arrays are of\r\n * different lengths, the resulting array will have the length of the longest input array,\r\n * with undefined values for missing elements.\r\n *\r\n * @template T\r\n * @param {...Array<readonly T[]>} arrs - The arrays to zip together.\r\n * @returns {T[][]} A new array of tuples containing the corresponding elements from the input arrays.\r\n *\r\n * @example\r\n * const arr1 = [1, 2, 3];\r\n * const arr2 = ['a', 'b', 'c'];\r\n * const arr3 = [true, false];\r\n * const result = zip(arr1, arr2, arr3);\r\n * // result will be [[1, 'a', true], [2, 'b', false], [3, 'c', undefined]]\r\n */\r\nexport function zip<T>(...arrs: Array<readonly T[]>): T[][] {\r\n  const rowCount = Math.max(...arrs.map(x => x.length));\r\n  const columnCount = arrs.length;\r\n  const result = Array(rowCount);\r\n\r\n  for (let i = 0; i < rowCount; ++i) {\r\n    const row = Array(columnCount);\r\n    for (let j = 0; j < columnCount; ++j) {\r\n      row[j] = arrs[j][i];\r\n    }\r\n    result[i] = row;\r\n  }\r\n  return result;\r\n}\r\n","/**\r\n * An error class representing an aborted operation.\r\n * @augments Error\r\n */\r\nexport class AbortError extends Error {\r\n  constructor(message = 'The operation was aborted') {\r\n    super(message);\r\n    this.name = 'AbortError';\r\n  }\r\n}\r\n","/**\r\n * An error class representing an timeout operation.\r\n * @augments Error\r\n */\r\nexport class TimeoutError extends Error {\r\n  constructor(message = 'The operation was timed out') {\r\n    super(message);\r\n    this.name = 'TimeoutError';\r\n  }\r\n}\r\n","interface DebounceTimer {\r\n  /**\r\n   * Checks if the timer is active.\r\n   * @returns {boolean} True if the timer is active, otherwise false.\r\n   */\r\n  isActive: () => boolean;\r\n\r\n  /**\r\n   * Triggers the debounce timer.\r\n   * This method resets the timer and schedules the execution of the debounced function\r\n   * after the specified delay. If the timer is already active, it clears the existing timeout\r\n   * before setting a new one.\r\n   */\r\n  trigger: () => void;\r\n\r\n  /**\r\n   * Cancels any pending execution of the debounced function.\r\n   * This method clears the active timer, ensuring that the function will not be called\r\n   * at the end of the debounce period. It also resets any stored context or arguments.\r\n   */\r\n  cancel: () => void;\r\n}\r\n\r\ninterface DebounceOptions {\r\n  /**\r\n   * An optional AbortSignal to cancel the debounced function.\r\n   */\r\n  signal?: AbortSignal;\r\n\r\n  /**\r\n   * An optional array specifying whether the function should be invoked on the leading edge, trailing edge, or both.\r\n   * If `edges` includes \"leading\", the function will be invoked at the start of the delay period.\r\n   * If `edges` includes \"trailing\", the function will be invoked at the end of the delay period.\r\n   * If both \"leading\" and \"trailing\" are included, the function will be invoked at both the start and end of the delay period.\r\n   * @default [\"trailing\"]\r\n   */\r\n  edges?: Array<'leading' | 'trailing'>;\r\n}\r\n\r\n/**\r\n * Creates a debounced function that delays invoking the provided function until after `debounceMs` milliseconds\r\n * have elapsed since the last time the debounced function was invoked. The debounced function also has a `cancel`\r\n * method to cancel any pending execution.\r\n *\r\n * @template F - The type of function.\r\n * @param {F} func - The function to debounce.\r\n * @param {number} debounceMs - The number of milliseconds to delay.\r\n * @param {DebounceOptions} options - The options object\r\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the debounced function.\r\n * @returns A new debounced function with a `cancel` method.\r\n *\r\n * @example\r\n * const debouncedFunction = debounce(() => {\r\n *   console.log('Function executed');\r\n * }, 1000);\r\n *\r\n * // Will log 'Function executed' after 1 second if not called again in that time\r\n * debouncedFunction();\r\n *\r\n * // Will not log anything as the previous call is canceled\r\n * debouncedFunction.cancel();\r\n *\r\n * // With AbortSignal\r\n * const controller = new AbortController();\r\n * const signal = controller.signal;\r\n * const debouncedWithSignal = debounce(() => {\r\n *  console.log('Function executed');\r\n * }, 1000, { signal });\r\n *\r\n * debouncedWithSignal();\r\n *\r\n * // Will cancel the debounced function call\r\n * controller.abort();\r\n */\r\nexport function debounce<F extends (...args: any[]) => void>(\r\n  func: F,\r\n  debounceMs: number,\r\n  { signal, edges }: DebounceOptions = {}\r\n): ((...args: Parameters<F>) => void) & {\r\n  /**\r\n   * Schedules the execution of the debounced function after the specified debounce delay.\r\n   * This method resets any existing timer, ensuring that the function is only invoked\r\n   * after the delay has elapsed since the last call to the debounced function.\r\n   * It is typically called internally whenever the debounced function is invoked.\r\n   *\r\n   * @returns {void}\r\n   */\r\n  schedule: () => void;\r\n\r\n  /**\r\n   * Cancels any pending execution of the debounced function.\r\n   * This method clears the active timer and resets any stored context or arguments.\r\n   */\r\n  cancel: () => void;\r\n\r\n  /**\r\n   * Immediately invokes the debounced function if there is a pending execution.\r\n   * This method also cancels the current timer, ensuring that the function executes right away.\r\n   */\r\n  flush: () => void;\r\n} {\r\n  let pendingThis: any = undefined;\r\n  let pendingArgs: Parameters<F> | null = null;\r\n\r\n  const leading = edges != null && edges.includes('leading');\r\n  const trailing = edges == null || edges.includes('trailing');\r\n\r\n  const invoke = () => {\r\n    if (pendingArgs !== null) {\r\n      func.apply(pendingThis, pendingArgs);\r\n      pendingThis = undefined;\r\n      pendingArgs = null;\r\n    }\r\n  };\r\n\r\n  const onTimerEnd = () => {\r\n    if (trailing) {\r\n      invoke();\r\n    }\r\n\r\n    cancel();\r\n  };\r\n\r\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\r\n\r\n  const schedule = () => {\r\n    if (timeoutId != null) {\r\n      clearTimeout(timeoutId);\r\n    }\r\n\r\n    timeoutId = setTimeout(() => {\r\n      timeoutId = null;\r\n\r\n      onTimerEnd();\r\n    }, debounceMs);\r\n  };\r\n\r\n  const cancelTimer = () => {\r\n    if (timeoutId !== null) {\r\n      clearTimeout(timeoutId);\r\n      timeoutId = null;\r\n    }\r\n  };\r\n\r\n  const cancel = () => {\r\n    cancelTimer();\r\n    pendingThis = undefined;\r\n    pendingArgs = null;\r\n  };\r\n\r\n  const flush = () => {\r\n    cancelTimer();\r\n    invoke();\r\n  };\r\n\r\n  const debounced = function (this: any, ...args: Parameters<F>) {\r\n    if (signal?.aborted) {\r\n      return;\r\n    }\r\n\r\n    pendingThis = this;\r\n    pendingArgs = args;\r\n\r\n    const isFirstCall = timeoutId == null;\r\n\r\n    schedule();\r\n\r\n    if (leading && isFirstCall) {\r\n      invoke();\r\n    }\r\n  };\r\n\r\n  debounced.schedule = schedule;\r\n  debounced.cancel = cancel;\r\n  debounced.flush = flush;\r\n\r\n  signal?.addEventListener('abort', cancel, { once: true });\r\n\r\n  return debounced;\r\n}\r\n","/**\r\n * A no-operation function that does nothing.\r\n * This can be used as a placeholder or default function.\r\n *\r\n * @example\r\n * noop(); // Does nothing\r\n *\r\n * @returns {void} This function does not return anything.\r\n */\r\nexport function noop(): void {}\r\n","/**\r\n * Creates a function that invokes func, with up to n arguments, ignoring any additional arguments.\r\n *\r\n * @template F - The type of the function.\r\n * @param {F} func - The function to cap arguments for.\r\n * @param {number} n - The arity cap.\r\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new capped function.\r\n *\r\n * @example\r\n * function fn(a: number, b: number, c: number) {\r\n *   return Array.from(arguments);\r\n * }\r\n *\r\n * ary(fn, 0)(1, 2, 3) // []\r\n * ary(fn, 1)(1, 2, 3) // [1]\r\n * ary(fn, 2)(1, 2, 3) // [1, 2]\r\n * ary(fn, 3)(1, 2, 3) // [1, 2, 3]\r\n */\r\nexport function ary<F extends (...args: any[]) => any>(func: F, n: number): (...args: any[]) => ReturnType<F> {\r\n  return function (this: any, ...args: Parameters<F>) {\r\n    return func.apply(this, args.slice(0, n));\r\n  };\r\n}\r\n","/**\r\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\r\n *\r\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\r\n *\r\n * Note: This method doesn't set the `length` property of partially applied functions.\r\n *\r\n * @template F The type of the function to partially apply.\r\n * @param {F} func The function to partially apply arguments to.\r\n * @param {any[]} partialArgs The arguments to be partially applied.\r\n * @returns {F} Returns the new partially applied function.\r\n *\r\n * @example\r\n * function greet(greeting, name) {\r\n *   return greeting + ' ' + name;\r\n * }\r\n *\r\n * const sayHelloTo = partial(greet, 'hello');\r\n * sayHelloTo('fred');\r\n * // => 'hello fred'\r\n *\r\n * // Partially applied with placeholders.\r\n * const greetFred = partial(greet, partial.placeholder, 'fred');\r\n * greetFred('hi');\r\n * // => 'hi fred'\r\n */\r\nexport function partial<F extends (...args: any[]) => any>(func: F, ...partialArgs: any[]): F {\r\n  return function (this: any, ...providedArgs: any[]) {\r\n    const args: any[] = [];\r\n\r\n    let startIndex = 0;\r\n    for (let i = 0; i < partialArgs.length; i++) {\r\n      const arg = partialArgs[i];\r\n\r\n      if (arg === partial.placeholder) {\r\n        args.push(providedArgs[startIndex++]);\r\n      } else {\r\n        args.push(arg);\r\n      }\r\n    }\r\n    for (let i = startIndex; i < providedArgs.length; i++) {\r\n      args.push(providedArgs[i]);\r\n    }\r\n\r\n    return func.apply(this, args);\r\n  } as any as F;\r\n}\r\n\r\nconst partialPlaceholder: unique symbol = Symbol('partial.placeholder');\r\npartial.placeholder = partialPlaceholder;\r\n","/**\r\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\r\n *\r\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\r\n *\r\n * Note: This method doesn't set the `length` property of partially applied functions.\r\n *\r\n * @template F The type of the function to partially apply.\r\n * @param {F} func The function to partially apply arguments to.\r\n * @param {any[]} partialArgs The arguments to be partially applied.\r\n * @returns {F} Returns the new partially applied function.\r\n *\r\n * @example\r\n * function greet(greeting, name) {\r\n *   return greeting + ' ' + name;\r\n * }\r\n *\r\n * const greetFred = partialRight(greet, 'fred');\r\n * greetFred('hi');\r\n * // => 'hi fred'\r\n *\r\n * // Partially applied with placeholders.\r\n * const sayHelloTo = partialRight(greet, 'hello', partialRight.placeholder);\r\n * sayHelloTo('fred');\r\n * // => 'hello fred'\r\n */\r\nexport function partialRight<F extends (...args: any[]) => any>(func: F, ...partialArgs: any[]): F {\r\n  return function (this: any, ...providedArgs: any[]) {\r\n    const placeholderLength = partialArgs.filter(arg => arg === partialRightPlaceholder).length;\r\n    const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);\r\n    const args: any[] = [];\r\n\r\n    let providedIndex = 0;\r\n    for (let i = 0; i < rangeLength; i++) {\r\n      args.push(providedArgs[providedIndex++]);\r\n    }\r\n    for (let i = 0; i < partialArgs.length; i++) {\r\n      const arg = partialArgs[i];\r\n\r\n      if (arg === partialRight.placeholder) {\r\n        args.push(providedArgs[providedIndex++]);\r\n      } else {\r\n        args.push(arg);\r\n      }\r\n    }\r\n    return func.apply(this, args);\r\n  } as any as F;\r\n}\r\n\r\nconst partialRightPlaceholder: unique symbol = Symbol('partialRight.placeholder');\r\npartialRight.placeholder = partialRightPlaceholder;\r\n","/**\r\n * Calculates the sum of an array of numbers.\r\n *\r\n * This function takes an array of numbers and returns the sum of all the elements in the array.\r\n *\r\n * @param {number[]} nums - An array of numbers to be summed.\r\n * @returns {number} The sum of all the numbers in the array.\r\n *\r\n * @example\r\n * const numbers = [1, 2, 3, 4, 5];\r\n * const result = sum(numbers);\r\n * // result will be 15\r\n */\r\nexport function sum(nums: readonly number[]): number {\r\n  let result = 0;\r\n\r\n  for (let i = 0; i < nums.length; i++) {\r\n    result += nums[i];\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { sum } from './sum.ts';\r\n\r\n/**\r\n * Calculates the average of an array of numbers.\r\n *\r\n * If the array is empty, this function returns `NaN`.\r\n *\r\n * @param {number[]} nums - An array of numbers to calculate the average.\r\n * @returns {number} The average of all the numbers in the array.\r\n *\r\n * @example\r\n * const numbers = [1, 2, 3, 4, 5];\r\n * const result = mean(numbers);\r\n * // result will be 3\r\n */\r\nexport function mean(nums: readonly number[]): number {\r\n  return sum(nums) / nums.length;\r\n}\r\n","/**\r\n * Checks if a value is a TypedArray.\r\n * @param {unknown} x The value to check.\r\n * @returns {x is\r\n *     Uint8Array\r\n *   | Uint8ClampedArray\r\n *   | Uint16Array\r\n *   | Uint32Array\r\n *   | BigUint64Array\r\n *   | Int8Array\r\n *   | Int16Array\r\n *   | Int32Array\r\n *   | BigInt64Array\r\n *   | Float32Array\r\n *   | Float64Array} Returns true if `x` is a TypedArray, false otherwise.\r\n *\r\n * @example\r\n * const arr = new Uint8Array([1, 2, 3]);\r\n * isTypedArray(arr); // true\r\n *\r\n * const regularArray = [1, 2, 3];\r\n * isTypedArray(regularArray); // false\r\n *\r\n * const buffer = new ArrayBuffer(16);\r\n * isTypedArray(buffer); // false\r\n */\r\nexport function isTypedArray(\r\n  x: unknown\r\n): x is\r\n  | Uint8Array\r\n  | Uint8ClampedArray\r\n  | Uint16Array\r\n  | Uint32Array\r\n  | BigUint64Array\r\n  | Int8Array\r\n  | Int16Array\r\n  | Int32Array\r\n  | BigInt64Array\r\n  | Float32Array\r\n  | Float64Array {\r\n  return ArrayBuffer.isView(x) && !(x instanceof DataView);\r\n}\r\n","/**\r\n * Checks whether a value is a JavaScript primitive.\r\n * JavaScript primitives include null, undefined, strings, numbers, booleans, symbols, and bigints.\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {value is\r\n *     null\r\n *   | undefined\r\n *   | string\r\n *   | number\r\n *   | boolean\r\n *   | symbol\r\n *   | bigint} Returns true if `value` is a primitive, false otherwise.\r\n *\r\n * @example\r\n * isPrimitive(null); // true\r\n * isPrimitive(undefined); // true\r\n * isPrimitive('123'); // true\r\n * isPrimitive(false); // true\r\n * isPrimitive(true); // true\r\n * isPrimitive(Symbol('a')); // true\r\n * isPrimitive(123n); // true\r\n * isPrimitive({}); // false\r\n * isPrimitive(new Date()); // false\r\n * isPrimitive(new Map()); // false\r\n * isPrimitive(new Set()); // false\r\n * isPrimitive([1, 2, 3]); // false\r\n */\r\nexport function isPrimitive(value: unknown): value is null | undefined | string | number | boolean | symbol | bigint {\r\n  return value == null || (typeof value !== 'object' && typeof value !== 'function');\r\n}\r\n","import { isTypedArray } from '../predicate/isTypedArray.ts';\r\nimport { isPrimitive } from '../predicate/isPrimitive.ts';\r\n\r\n/**\r\n * Creates a shallow clone of the given object.\r\n *\r\n * @template T - The type of the object.\r\n * @param {T} obj - The object to clone.\r\n * @returns {T} - A shallow clone of the given object.\r\n *\r\n * @example\r\n * // Clone a primitive values\r\n * const num = 29;\r\n * const clonedNum = clone(num);\r\n * console.log(clonedNum); // 29\r\n * console.log(clonedNum === num) ; // true\r\n *\r\n * @example\r\n * // Clone an array\r\n * const arr = [1, 2, 3];\r\n * const clonedArr = clone(arr);\r\n * console.log(clonedArr); // [1, 2, 3]\r\n * console.log(clonedArr === arr); // false\r\n *\r\n * @example\r\n * // Clone an object\r\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\r\n * const clonedObj = clone(obj);\r\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\r\n * console.log(clonedObj === obj); // false\r\n */\r\nexport function clone<T>(obj: T): T {\r\n  if (isPrimitive(obj)) {\r\n    return obj;\r\n  }\r\n\r\n  if (Array.isArray(obj) || isTypedArray(obj) || obj instanceof ArrayBuffer || obj instanceof SharedArrayBuffer) {\r\n    return obj.slice(0) as T;\r\n  }\r\n\r\n  const prototype = Object.getPrototypeOf(obj);\r\n  const Constructor = prototype.constructor;\r\n\r\n  if (obj instanceof Date || obj instanceof Map || obj instanceof Set) {\r\n    return new Constructor(obj);\r\n  }\r\n\r\n  if (obj instanceof RegExp) {\r\n    const newRegExp = new Constructor(obj);\r\n    newRegExp.lastIndex = obj.lastIndex;\r\n\r\n    return newRegExp;\r\n  }\r\n\r\n  if (obj instanceof DataView) {\r\n    return new Constructor(obj.buffer.slice(0));\r\n  }\r\n\r\n  if (obj instanceof Error) {\r\n    const newError = new Constructor(obj.message);\r\n\r\n    newError.stack = obj.stack;\r\n    newError.name = obj.name;\r\n    newError.cause = obj.cause;\r\n\r\n    return newError;\r\n  }\r\n\r\n  if (typeof File !== 'undefined' && obj instanceof File) {\r\n    const newFile = new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });\r\n    return newFile;\r\n  }\r\n\r\n  if (typeof obj === 'object') {\r\n    const newObject = Object.create(prototype);\r\n    return Object.assign(newObject, obj);\r\n  }\r\n\r\n  return obj;\r\n}\r\n","/**\r\n * Checks if a given value is a plain object.\r\n *\r\n * @param {object} object - The value to check.\r\n * @returns {boolean} - True if the value is a plain object, otherwise false.\r\n *\r\n * @example\r\n * console.log(isPlainObject({})); // true\r\n * console.log(isPlainObject([])); // false\r\n * console.log(isPlainObject(null)); // false\r\n * console.log(isPlainObject(Object.create(null))); // true\r\n * console.log(Buffer.from('hello, world')); // false\r\n */\r\nexport function isPlainObject(object: object): boolean {\r\n  if (typeof object !== 'object') {\r\n    return false;\r\n  }\r\n\r\n  if (object == null) {\r\n    return false;\r\n  }\r\n\r\n  if (Object.getPrototypeOf(object) === null) {\r\n    return true;\r\n  }\r\n\r\n  if (object.toString() !== '[object Object]') {\r\n    return false;\r\n  }\r\n\r\n  let proto = object;\r\n\r\n  while (Object.getPrototypeOf(proto) !== null) {\r\n    proto = Object.getPrototypeOf(proto);\r\n  }\r\n\r\n  return Object.getPrototypeOf(object) === proto;\r\n}\r\n","import { isPlainObject } from '../predicate/isPlainObject.ts';\r\n\r\n/**\r\n * Flattens a nested object into a single level object with dot-separated keys.\r\n *\r\n * @param {object} object - The object to flatten.\r\n * @returns {Record<string, any>} - The flattened object.\r\n *\r\n * @example\r\n * const nestedObject = {\r\n *   a: {\r\n *     b: {\r\n *       c: 1\r\n *     }\r\n *   },\r\n *   d: [2, 3]\r\n * };\r\n *\r\n * const flattened = flattenObject(nestedObject);\r\n * console.log(flattened);\r\n * // Output:\r\n * // {\r\n * //   'a.b.c': 1,\r\n * //   'd.0': 2,\r\n * //   'd.1': 3\r\n * // }\r\n */\r\nexport function flattenObject(object: object): Record<string, any> {\r\n  return flattenObjectImpl(object);\r\n}\r\n\r\nfunction flattenObjectImpl(object: object, prefix = ''): Record<string, any> {\r\n  const result: Record<string, any> = {};\r\n  const keys = Object.keys(object);\r\n\r\n  for (let i = 0; i < keys.length; i++) {\r\n    const key = keys[i];\r\n    const value = (object as any)[key];\r\n\r\n    const prefixedKey = prefix ? `${prefix}.${key}` : key;\r\n\r\n    if (isPlainObject(value) && Object.keys(value).length > 0) {\r\n      Object.assign(result, flattenObjectImpl(value, prefixedKey));\r\n      continue;\r\n    }\r\n\r\n    if (Array.isArray(value)) {\r\n      for (let index = 0; index < value.length; index++) {\r\n        result[`${prefixedKey}.${index}`] = value[index];\r\n      }\r\n      continue;\r\n    }\r\n\r\n    result[prefixedKey] = value;\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Creates a new object with the same values as the given object, but with keys generated\r\n * by running each own enumerable property of the object through the iteratee function.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the keys in the object.\r\n * @template K2 - The type of the new keys generated by the iteratee function.\r\n *\r\n * @param {T} object - The object to iterate over.\r\n * @param {(value: T[K1], key: K1, object: T) => K2} getNewKey - The function invoked per own enumerable property.\r\n * @returns {Record<K2, T[K1]>} - Returns the new mapped object.\r\n *\r\n * @example\r\n * // Example usage:\r\n * const obj = { a: 1, b: 2 };\r\n * const result = mapKeys(obj, (value, key) => key + value);\r\n * console.log(result); // { a1: 1, b2: 2 }\r\n */\r\nexport function mapKeys<T extends object, K1 extends keyof T, K2 extends PropertyKey>(\r\n  object: T,\r\n  getNewKey: (value: T[K1], key: K1, object: T) => K2\r\n): Record<K2, T[K1]> {\r\n  const result = {} as Record<K2, T[K1]>;\r\n  const keys = Object.keys(object);\r\n\r\n  for (let i = 0; i < keys.length; i++) {\r\n    const key = keys[i] as K1;\r\n    const value = object[key];\r\n\r\n    result[getNewKey(value, key, object)] = value as any;\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Creates a new object with the same keys as the given object, but with values generated\r\n * by running each own enumerable property of the object through the iteratee function.\r\n *\r\n * @template T - The type of the object.\r\n * @template K - The type of the keys in the object.\r\n * @template V - The type of the new values generated by the iteratee function.\r\n *\r\n * @param {T} object - The object to iterate over.\r\n * @param {(value: T[K], key: K, object: T) => V} getNewValue - The function invoked per own enumerable property.\r\n * @returns {Record<K, V>} - Returns the new mapped object.\r\n *\r\n * @example\r\n * // Example usage:\r\n * const obj = { a: 1, b: 2 };\r\n * const result = mapValues(obj, (value) => value * 2);\r\n * console.log(result); // { a: 2, b: 4 }\r\n */\r\nexport function mapValues<T extends object, K extends keyof T, V>(\r\n  object: T,\r\n  getNewValue: (value: T[K], key: K, object: T) => V\r\n): Record<K, V> {\r\n  const result = {} as Record<K, V>;\r\n  const keys = Object.keys(object);\r\n\r\n  for (let i = 0; i < keys.length; i++) {\r\n    const key = keys[i] as K;\r\n    const value = object[key];\r\n\r\n    result[key] = getNewValue(value, key, object);\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { isPrimitive } from '../predicate/isPrimitive.ts';\r\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\r\n\r\n/**\r\n * Creates a deep clone of the given object.\r\n *\r\n * @template T - The type of the object.\r\n * @param {T} obj - The object to clone.\r\n * @returns {T} - A deep clone of the given object.\r\n *\r\n * @example\r\n * // Clone a primitive values\r\n * const num = 29;\r\n * const clonedNum = clone(num);\r\n * console.log(clonedNum); // 29\r\n * console.log(clonedNum === num) ; // true\r\n *\r\n * @example\r\n * // Clone an array\r\n * const arr = [1, 2, 3];\r\n * const clonedArr = clone(arr);\r\n * console.log(clonedArr); // [1, 2, 3]\r\n * console.log(clonedArr === arr); // false\r\n *\r\n * @example\r\n * // Clone an array with nested objects\r\n * const arr = [1, { a: 1 }, [1, 2, 3]];\r\n * const clonedArr = clone(arr);\r\n * arr[1].a = 2;\r\n * console.log(arr); // [2, { a: 2 }, [1, 2, 3]]\r\n * console.log(clonedArr); // [1, { a: 1 }, [1, 2, 3]]\r\n * console.log(clonedArr === arr); // false\r\n *\r\n * @example\r\n * // Clone an object\r\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\r\n * const clonedObj = clone(obj);\r\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\r\n * console.log(clonedObj === obj); // false\r\n *\r\n * @example\r\n * // Clone an object with nested objects\r\n * const obj = { a: 1, b: { c: 1 } };\r\n * const clonedObj = clone(obj);\r\n * obj.b.c = 2;\r\n * console.log(obj); // { a: 1, b: { c: 2 } }\r\n * console.log(clonedObj); // { a: 1, b: { c: 1 } }\r\n * console.log(clonedObj === obj); // false\r\n */\r\nexport function cloneDeep<T>(obj: T): T {\r\n  return cloneDeepImpl(obj);\r\n}\r\n\r\nfunction cloneDeepImpl<T>(obj: T, stack = new Map<any, any>()): T {\r\n  if (isPrimitive(obj)) {\r\n    return obj as T;\r\n  }\r\n\r\n  if (stack.has(obj)) {\r\n    return stack.get(obj) as T;\r\n  }\r\n\r\n  if (Array.isArray(obj)) {\r\n    const result: any = new Array(obj.length);\r\n    stack.set(obj, result);\r\n\r\n    for (let i = 0; i < obj.length; i++) {\r\n      result[i] = cloneDeepImpl(obj[i], stack);\r\n    }\r\n\r\n    // For RegExpArrays\r\n    if (Object.prototype.hasOwnProperty.call(obj, 'index')) {\r\n      // eslint-disable-next-line\r\n      // @ts-ignore\r\n      result.index = obj.index;\r\n    }\r\n    if (Object.prototype.hasOwnProperty.call(obj, 'input')) {\r\n      // eslint-disable-next-line\r\n      // @ts-ignore\r\n      result.input = obj.input;\r\n    }\r\n\r\n    return result as T;\r\n  }\r\n\r\n  if (obj instanceof Date) {\r\n    return new Date(obj.getTime()) as T;\r\n  }\r\n\r\n  if (obj instanceof RegExp) {\r\n    const result = new RegExp(obj.source, obj.flags);\r\n\r\n    result.lastIndex = obj.lastIndex;\r\n\r\n    return result as T;\r\n  }\r\n\r\n  if (obj instanceof Map) {\r\n    const result = new Map();\r\n    stack.set(obj, result);\r\n\r\n    for (const [key, value] of obj.entries()) {\r\n      result.set(key, cloneDeepImpl(value, stack));\r\n    }\r\n\r\n    return result as T;\r\n  }\r\n\r\n  if (obj instanceof Set) {\r\n    const result = new Set();\r\n    stack.set(obj, result);\r\n\r\n    for (const value of obj.values()) {\r\n      result.add(cloneDeepImpl(value, stack));\r\n    }\r\n\r\n    return result as T;\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n  // @ts-ignore\r\n  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(obj)) {\r\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n    // @ts-ignore\r\n    return obj.subarray() as T;\r\n  }\r\n\r\n  if (isTypedArray(obj)) {\r\n    const result = new (Object.getPrototypeOf(obj).constructor)(obj.length);\r\n    stack.set(obj, result);\r\n\r\n    for (let i = 0; i < obj.length; i++) {\r\n      result[i] = cloneDeepImpl(obj[i], stack);\r\n    }\r\n\r\n    return result as T;\r\n  }\r\n\r\n  if (obj instanceof ArrayBuffer || (typeof SharedArrayBuffer !== 'undefined' && obj instanceof SharedArrayBuffer)) {\r\n    return obj.slice(0) as T;\r\n  }\r\n\r\n  if (obj instanceof DataView) {\r\n    const result = new DataView(obj.buffer.slice(0));\r\n    stack.set(obj, result);\r\n\r\n    copyProperties(result, obj, stack);\r\n\r\n    return result as T;\r\n  }\r\n\r\n  // For legacy NodeJS support\r\n  if (typeof File !== 'undefined' && obj instanceof File) {\r\n    const result = new File([obj], obj.name, { type: obj.type });\r\n    stack.set(obj, result);\r\n\r\n    copyProperties(result, obj, stack);\r\n\r\n    return result as T;\r\n  }\r\n\r\n  if (obj instanceof Blob) {\r\n    const result = new Blob([obj], { type: obj.type });\r\n    stack.set(obj, result);\r\n\r\n    copyProperties(result, obj, stack);\r\n\r\n    return result as T;\r\n  }\r\n\r\n  if (obj instanceof Error) {\r\n    const result = new (obj.constructor as { new (): Error })();\r\n    stack.set(obj, result);\r\n\r\n    result.message = obj.message;\r\n    result.name = obj.name;\r\n    result.stack = obj.stack;\r\n    result.cause = obj.cause;\r\n\r\n    copyProperties(result, obj, stack);\r\n\r\n    return result as T;\r\n  }\r\n\r\n  if (typeof obj === 'object' && obj !== null) {\r\n    const result = {};\r\n    stack.set(obj, result);\r\n\r\n    copyProperties(result, obj, stack);\r\n\r\n    return result as T;\r\n  }\r\n\r\n  return obj;\r\n}\r\n\r\n// eslint-disable-next-line\r\nexport function copyProperties(target: any, source: any, stack?: Map<any, any>): void {\r\n  const keys = Object.keys(source);\r\n\r\n  for (let i = 0; i < keys.length; i++) {\r\n    const key = keys[i];\r\n    const descriptor = Object.getOwnPropertyDescriptor(source, key);\r\n\r\n    if (descriptor?.writable || descriptor?.set) {\r\n      target[key] = cloneDeepImpl(source[key], stack);\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Checks if the given value is object-like.\r\n *\r\n * A value is object-like if its type is object and it is not null.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an object-like value.\r\n *\r\n * @template T - The type of value.\r\n * @param {T} value - The value to test if it is an object-like.\r\n * @returns {value is object} `true` if the value is an object-like, `false` otherwise.\r\n *\r\n * @example\r\n * const value1 = { a: 1 };\r\n * const value2 = [1, 2, 3];\r\n * const value3 = 'abc';\r\n * const value4 = () => {};\r\n * const value5 = null;\r\n *\r\n * console.log(isObjectLike(value1)); // true\r\n * console.log(isObjectLike(value2)); // true\r\n * console.log(isObjectLike(value3)); // false\r\n * console.log(isObjectLike(value4)); // false\r\n * console.log(isObjectLike(value5)); // false\r\n */\r\n\r\nexport function isObjectLike(value: unknown): value is object {\r\n  return typeof value === 'object' && value !== null;\r\n}\r\n","import { isObjectLike } from '../compat/predicate/isObjectLike.ts';\r\n\r\n/**\r\n * Merges the properties of the source object into the target object.\r\n *\r\n * This function performs a deep merge, meaning nested objects and arrays are merged recursively.\r\n * If a property in the source object is an array or an object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is undefined, it will not overwrite a defined property in the target object.\r\n *\r\n * Note that this function mutates the target object.\r\n *\r\n * @param {T} target - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S} source - The source object whose properties will be merged into the target object.\r\n * @returns {T & S} The updated target object with properties from the source object merged in.\r\n *\r\n * @template T - Type of the target object.\r\n * @template S - Type of the source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3, 2], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function merge<T, S>(target: T, source: S): T & S;\r\n/**\r\n * Merges the properties of the source object into the target object.\r\n *\r\n * This function performs a deep merge, meaning nested objects and arrays are merged recursively.\r\n * If a property in the source object is an array or an object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is undefined, it will not overwrite a defined property in the target object.\r\n *\r\n * Note that this function mutates the target object.\r\n *\r\n * @param {T} target - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S} source - The source object whose properties will be merged into the target object.\r\n * @returns {T & S} The updated target object with properties from the source object merged in.\r\n *\r\n * @template T - Type of the target object.\r\n * @template S - Type of the source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3, 2], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function merge(target: any, source: any) {\r\n  const sourceKeys = Object.keys(source);\r\n\r\n  for (let i = 0; i < sourceKeys.length; i++) {\r\n    const key = sourceKeys[i];\r\n\r\n    const sourceValue = source[key];\r\n    const targetValue = target[key];\r\n\r\n    if (Array.isArray(sourceValue)) {\r\n      target[key] = merge(targetValue ?? [], sourceValue);\r\n    } else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {\r\n      target[key] = merge(targetValue ?? {}, sourceValue);\r\n    } else if (targetValue === undefined || sourceValue !== undefined) {\r\n      target[key] = sourceValue;\r\n    }\r\n  }\r\n\r\n  return target;\r\n}\r\n","export const regexpTag = '[object RegExp]';\r\nexport const stringTag = '[object String]';\r\nexport const numberTag = '[object Number]';\r\nexport const booleanTag = '[object Boolean]';\r\nexport const argumentsTag = '[object Arguments]';\r\nexport const symbolTag = '[object Symbol]';\r\nexport const dateTag = '[object Date]';\r\nexport const mapTag = '[object Map]';\r\nexport const setTag = '[object Set]';\r\nexport const arrayTag = '[object Array]';\r\nexport const functionTag = '[object Function]';\r\nexport const arrayBufferTag = '[object ArrayBuffer]';\r\nexport const objectTag = '[object Object]';\r\nexport const errorTag = '[object Error]';\r\nexport const dataViewTag = '[object DataView]';\r\nexport const uint8ArrayTag = '[object Uint8Array]';\r\nexport const uint8ClampedArrayTag = '[object Uint8ClampedArray]';\r\nexport const uint16ArrayTag = '[object Uint16Array]';\r\nexport const uint32ArrayTag = '[object Uint32Array]';\r\nexport const bigUint64ArrayTag = '[object BigUint64Array]';\r\nexport const int8ArrayTag = '[object Int8Array]';\r\nexport const int16ArrayTag = '[object Int16Array]';\r\nexport const int32ArrayTag = '[object Int32Array]';\r\nexport const bigInt64ArrayTag = '[object BigInt64Array]';\r\nexport const float32ArrayTag = '[object Float32Array]';\r\nexport const float64ArrayTag = '[object Float64Array]';\r\n","export function getSymbols(object: any) {\r\n  return Object.getOwnPropertySymbols(object).filter(symbol =>\r\n    Object.prototype.propertyIsEnumerable.call(object, symbol)\r\n  );\r\n}\r\n","/**\r\n * Gets the `toStringTag` of `value`.\r\n *\r\n * @private\r\n * @param {T} value The value to query.\r\n * @returns {string} Returns the `Object.prototype.toString.call` result.\r\n */\r\nexport function getTag<T>(value: T) {\r\n  if (value == null) {\r\n    return value === undefined ? '[object Undefined]' : '[object Null]';\r\n  }\r\n  return Object.prototype.toString.call(value);\r\n}\r\n","import {\r\n  argumentsTag,\r\n  arrayBufferTag,\r\n  arrayTag,\r\n  bigInt64ArrayTag,\r\n  bigUint64ArrayTag,\r\n  booleanTag,\r\n  dataViewTag,\r\n  dateTag,\r\n  errorTag,\r\n  float32ArrayTag,\r\n  float64ArrayTag,\r\n  functionTag,\r\n  int16ArrayTag,\r\n  int32ArrayTag,\r\n  int8ArrayTag,\r\n  mapTag,\r\n  numberTag,\r\n  objectTag,\r\n  regexpTag,\r\n  setTag,\r\n  stringTag,\r\n  symbolTag,\r\n  uint16ArrayTag,\r\n  uint32ArrayTag,\r\n  uint8ArrayTag,\r\n  uint8ClampedArrayTag,\r\n} from '../compat/_internal/tags.ts';\r\nimport { getSymbols } from '../compat/_internal/getSymbols.ts';\r\nimport { getTag } from '../compat/_internal/getTag.ts';\r\nimport { isPlainObject } from './isPlainObject.ts';\r\n\r\ndeclare let Buffer:\r\n  | {\r\n      isBuffer: (a: any) => boolean;\r\n    }\r\n  | undefined;\r\n\r\n/**\r\n * Checks if two values are equal, including support for `Date`, `RegExp`, and deep object comparison.\r\n *\r\n * @param {unknown} a - The first value to compare.\r\n * @param {unknown} b - The second value to compare.\r\n * @returns {boolean} `true` if the values are equal, otherwise `false`.\r\n *\r\n * @example\r\n * isEqual(1, 1); // true\r\n * isEqual({ a: 1 }, { a: 1 }); // true\r\n * isEqual(/abc/g, /abc/g); // true\r\n * isEqual(new Date('2020-01-01'), new Date('2020-01-01')); // true\r\n * isEqual([1, 2, 3], [1, 2, 3]); // true\r\n */\r\nexport function isEqual(a: any, b: any): boolean {\r\n  if (typeof a === typeof b) {\r\n    switch (typeof a) {\r\n      case 'bigint':\r\n      case 'string':\r\n      case 'boolean':\r\n      case 'symbol':\r\n      case 'undefined': {\r\n        return a === b;\r\n      }\r\n      case 'number': {\r\n        return a === b || Object.is(a, b);\r\n      }\r\n      case 'function': {\r\n        return a === b;\r\n      }\r\n      case 'object': {\r\n        return areObjectsEqual(a, b);\r\n      }\r\n    }\r\n  }\r\n\r\n  return areObjectsEqual(a, b);\r\n}\r\n\r\nfunction areObjectsEqual(a: any, b: any, stack?: Map<any, any>) {\r\n  if (Object.is(a, b)) {\r\n    return true;\r\n  }\r\n\r\n  let aTag = getTag(a);\r\n  let bTag = getTag(b);\r\n\r\n  if (aTag === argumentsTag) {\r\n    aTag = objectTag;\r\n  }\r\n\r\n  if (bTag === argumentsTag) {\r\n    bTag = objectTag;\r\n  }\r\n\r\n  if (aTag !== bTag) {\r\n    return false;\r\n  }\r\n\r\n  switch (aTag) {\r\n    case stringTag:\r\n      return a.toString() === b.toString();\r\n\r\n    case numberTag: {\r\n      const x = a.valueOf();\r\n      const y = b.valueOf();\r\n\r\n      return x === y || (Number.isNaN(x) && Number.isNaN(y));\r\n    }\r\n\r\n    case booleanTag:\r\n    case dateTag:\r\n    case symbolTag:\r\n      return Object.is(a.valueOf(), b.valueOf());\r\n\r\n    case regexpTag: {\r\n      return a.source === b.source && a.flags === b.flags;\r\n    }\r\n\r\n    case functionTag: {\r\n      return a === b;\r\n    }\r\n  }\r\n\r\n  stack = stack ?? new Map();\r\n\r\n  const aStack = stack.get(a);\r\n  const bStack = stack.get(b);\r\n\r\n  if (aStack != null && bStack != null) {\r\n    return aStack === b;\r\n  }\r\n\r\n  stack.set(a, b);\r\n  stack.set(b, a);\r\n\r\n  try {\r\n    switch (aTag) {\r\n      case mapTag: {\r\n        if (a.size !== b.size) {\r\n          return false;\r\n        }\r\n\r\n        for (const [key, value] of a.entries()) {\r\n          if (!b.has(key) || !areObjectsEqual(value, b.get(key), stack)) {\r\n            return false;\r\n          }\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      case setTag: {\r\n        if (a.size !== b.size) {\r\n          return false;\r\n        }\r\n\r\n        const aValues = Array.from(a.values());\r\n        const bValues = Array.from(b.values());\r\n\r\n        for (let i = 0; i < aValues.length; i++) {\r\n          const aValue = aValues[i];\r\n          const index = bValues.findIndex(bValue => {\r\n            return areObjectsEqual(aValue, bValue, stack);\r\n          });\r\n\r\n          if (index === -1) {\r\n            return false;\r\n          }\r\n\r\n          bValues.splice(index, 1);\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      case arrayTag:\r\n      case uint8ArrayTag:\r\n      case uint8ClampedArrayTag:\r\n      case uint16ArrayTag:\r\n      case uint32ArrayTag:\r\n      case bigUint64ArrayTag:\r\n      case int8ArrayTag:\r\n      case int16ArrayTag:\r\n      case int32ArrayTag:\r\n      case bigInt64ArrayTag:\r\n      case float32ArrayTag:\r\n      case float64ArrayTag: {\r\n        // Buffers are also treated as [object Uint8Array]s.\r\n        if (typeof Buffer !== 'undefined' && Buffer.isBuffer(a) !== Buffer.isBuffer(b)) {\r\n          return false;\r\n        }\r\n\r\n        if (a.length !== b.length) {\r\n          return false;\r\n        }\r\n\r\n        for (let i = 0; i < a.length; i++) {\r\n          if (!areObjectsEqual(a[i], b[i], stack)) {\r\n            return false;\r\n          }\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      case arrayBufferTag: {\r\n        if (a.byteLength !== b.byteLength) {\r\n          return false;\r\n        }\r\n\r\n        return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack);\r\n      }\r\n\r\n      case dataViewTag: {\r\n        if (a.byteLength !== b.byteLength || a.byteOffset !== b.byteOffset) {\r\n          return false;\r\n        }\r\n\r\n        return areObjectsEqual(a.buffer, b.buffer, stack);\r\n      }\r\n\r\n      case errorTag: {\r\n        return a.name === b.name && a.message === b.message;\r\n      }\r\n\r\n      case objectTag: {\r\n        const areEqualInstances =\r\n          areObjectsEqual(a.constructor, b.constructor, stack) || (isPlainObject(a) && isPlainObject(b));\r\n\r\n        if (!areEqualInstances) {\r\n          return false;\r\n        }\r\n\r\n        const aKeys = [...Object.keys(a), ...getSymbols(a)];\r\n        const bKeys = [...Object.keys(b), ...getSymbols(b)];\r\n\r\n        if (aKeys.length !== bKeys.length) {\r\n          return false;\r\n        }\r\n\r\n        for (let i = 0; i < aKeys.length; i++) {\r\n          const propKey = aKeys[i];\r\n          const aProp = (a as any)[propKey];\r\n\r\n          if (!Object.prototype.hasOwnProperty.call(b, propKey)) {\r\n            return false;\r\n          }\r\n\r\n          const bProp = (b as any)[propKey];\r\n\r\n          if (!areObjectsEqual(aProp, bProp, stack)) {\r\n            return false;\r\n          }\r\n        }\r\n\r\n        return true;\r\n      }\r\n      default: {\r\n        return false;\r\n      }\r\n    }\r\n  } finally {\r\n    stack.delete(a);\r\n    stack.delete(b);\r\n  }\r\n}\r\n","/**\r\n * Checks if a given value is a valid length.\r\n *\r\n * A valid length is of type `number`, is a non-negative integer, and is less than or equal to\r\n * JavaScript's maximum safe integer (`Number.MAX_SAFE_INTEGER`).\r\n * It returns `true` if the value is a valid length, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the\r\n * argument to a valid length (`number`).\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\r\n *\r\n * @example\r\n * isLength(0); // true\r\n * isLength(42); // true\r\n * isLength(-1); // false\r\n * isLength(1.5); // false\r\n * isLength(Number.MAX_SAFE_INTEGER); // true\r\n * isLength(Number.MAX_SAFE_INTEGER + 1); // false\r\n */\r\nexport function isLength(value: unknown): value is number {\r\n  return Number.isSafeInteger(value) && (value as number) >= 0;\r\n}\r\n","import { AbortError } from '../error/AbortError.ts';\r\n\r\ninterface DelayOptions {\r\n  signal?: AbortSignal;\r\n}\r\n\r\n/**\r\n * Delays the execution of code for a specified number of milliseconds.\r\n *\r\n * This function returns a Promise that resolves after the specified delay, allowing you to use it\r\n * with async/await to pause execution.\r\n *\r\n * @param {number} ms - The number of milliseconds to delay.\r\n * @param {DelayOptions} options - The options object.\r\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the delay.\r\n * @returns {Promise<void>} A Promise that resolves after the specified delay.\r\n *\r\n * @example\r\n * async function foo() {\r\n *   console.log('Start');\r\n *   await delay(1000); // Delays execution for 1 second\r\n *   console.log('End');\r\n * }\r\n *\r\n * foo();\r\n *\r\n * // With AbortSignal\r\n * const controller = new AbortController();\r\n * const { signal } = controller;\r\n *\r\n * setTimeout(() => controller.abort(), 50); // Will cancel the delay after 50ms\r\n * try {\r\n *   await delay(100, { signal });\r\n *  } catch (error) {\r\n *   console.error(error); // Will log 'AbortError'\r\n *  }\r\n * }\r\n */\r\nexport function delay(ms: number, { signal }: DelayOptions = {}): Promise<void> {\r\n  return new Promise((resolve, reject) => {\r\n    const abortError = () => {\r\n      reject(new AbortError());\r\n    };\r\n\r\n    const abortHandler = () => {\r\n      clearTimeout(timeoutId);\r\n      abortError();\r\n    };\r\n\r\n    if (signal?.aborted) {\r\n      return abortError();\r\n    }\r\n\r\n    const timeoutId = setTimeout(() => {\r\n      signal?.removeEventListener('abort', abortHandler);\r\n      resolve();\r\n    }, ms);\r\n\r\n    signal?.addEventListener('abort', abortHandler, { once: true });\r\n  });\r\n}\r\n","import { delay } from './delay.ts';\r\nimport { TimeoutError } from '../error/TimeoutError.ts';\r\n\r\n/**\r\n * Returns a promise that rejects with a `TimeoutError` after a specified delay.\r\n *\r\n * @param {number} ms - The delay duration in milliseconds.\r\n * @returns {Promise<never>} A promise that rejects with a `TimeoutError` after the specified delay.\r\n * @throws {TimeoutError} Throws a `TimeoutError` after the specified delay.\r\n *\r\n * @example\r\n * try {\r\n *   await timeout(1000); // Timeout exception after 1 second\r\n * } catch (error) {\r\n *   console.error(error); // Will log 'The operation was timed out'\r\n * }\r\n */\r\nexport async function timeout(ms: number): Promise<never> {\r\n  await delay(ms);\r\n  throw new TimeoutError();\r\n}\r\n","/**\r\n * Converts the first character of string to upper case and the remaining to lower case.\r\n *\r\n * @template T - Literal type of the string.\r\n * @param {T} str - The string to be converted to uppercase.\r\n * @returns {Capitalize<T>} - The capitalized string.\r\n *\r\n * @example\r\n * const result = capitalize('fred') // returns 'Fred'\r\n * const result2 = capitalize('FRED') // returns 'Fred'\r\n */\r\n\r\nexport function capitalize<T extends string>(str: T): Capitalize<T> {\r\n  return (str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()) as Capitalize<T>;\r\n}\r\n\r\ntype Capitalize<T extends string> = T extends `${infer F}${infer R}` ? `${Uppercase<F>}${Lowercase<R>}` : T;\r\n","/**\r\n * Regular expression pattern to split strings into words for various case conversions\r\n *\r\n * This pattern matches sequences of characters in a string, considering the following case:\r\n * - Sequences of two or more uppercase letters followed by an uppercase letter and lowercase letters or digits (for acronyms)\r\n * - Sequences of one uppercase letter optionally followed by lowercase letters and digits\r\n * - Single uppercase letters\r\n * - Sequences of digis\r\n *\r\n * The resulting match can be used to convert camelCase, snake_case, kebab-case, and other mixed formats into\r\n * a consistent format like snake case.\r\n *\r\n * @example\r\n * const matches = 'camelCaseHTTPRequest'.match(CASE_SPLIT_PATTERN);\r\n * // matches: ['camel', 'Case', 'HTTP', 'Request']\r\n */\r\nconst CASE_SPLIT_PATTERN = /[A-Z]?[a-z]+|[0-9]+|[A-Z]+(?![a-z])/g;\r\n\r\nexport function getWords(str: string): string[] {\r\n  return Array.from(str.match(CASE_SPLIT_PATTERN) ?? []);\r\n}\r\n","/**\r\n * Removes leading whitespace or specified characters from a string.\r\n *\r\n * @param {string} str - The string from which leading characters will be trimmed.\r\n * @param {string | string[]} chars - The character(s) to remove from the end of the string.\r\n * @returns {string} - The resulting string after the specified leading character has been removed.\r\n *\r\n * @example\r\n * const trimmedStr1 = trimStart('---hello', '-') // returns 'hello'\r\n * const trimmedStr2 = trimStart('000123', '0') // returns '123'\r\n * const trimmedStr3 = trimStart('abcabcabc', 'a') // returns 'bcabcabc'\r\n * const trimmedStr4 = trimStart('xxxtrimmed', 'x') // returns 'trimmed'\r\n */\r\nexport function trimStart(str: string, chars?: string | string[]): string {\r\n  if (chars === undefined) {\r\n    return str.trimStart();\r\n  }\r\n  let startIndex = 0;\r\n\r\n  switch (typeof chars) {\r\n    case 'string': {\r\n      while (startIndex < str.length && str[startIndex] === chars) {\r\n        startIndex++;\r\n      }\r\n      break;\r\n    }\r\n    case 'object': {\r\n      while (startIndex < str.length && chars.includes(str[startIndex])) {\r\n        startIndex++;\r\n      }\r\n    }\r\n  }\r\n\r\n  return str.substring(startIndex);\r\n}\r\n","/**\r\n * Removes trailing whitespace or specified characters from a string.\r\n *\r\n * @param {string} str - The string from which trailing characters will be trimmed.\r\n * @param {string | string[]} chars - The character(s) to remove from the end of the string.\r\n * @returns {string} - The resulting string after the specified trailing character has been removed.\r\n *\r\n * @example\r\n * const trimmedStr1 = trimEnd('hello---', '-') // returns 'hello'\r\n * const trimmedStr2 = trimEnd('123000', '0') // returns '123'\r\n * const trimmedStr3 = trimEnd('abcabcabc', 'c') // returns 'abcabcab'\r\n * const trimmedStr4 = trimEnd('trimmedxxx', 'x') // returns 'trimmed'\r\n */\r\nexport function trimEnd(str: string, chars?: string | string[]): string {\r\n  if (chars === undefined) {\r\n    return str.trimEnd();\r\n  }\r\n\r\n  let endIndex = str.length;\r\n\r\n  switch (typeof chars) {\r\n    case 'string': {\r\n      while (endIndex > 0 && str[endIndex - 1] === chars) {\r\n        endIndex--;\r\n      }\r\n      break;\r\n    }\r\n    case 'object': {\r\n      while (endIndex > 0 && chars.includes(str[endIndex - 1])) {\r\n        endIndex--;\r\n      }\r\n    }\r\n  }\r\n\r\n  return str.substring(0, endIndex);\r\n}\r\n","import { trimStart } from './trimStart.ts';\r\nimport { trimEnd } from './trimEnd.ts';\r\n\r\n/**\r\n * Removes leading and trailing whitespace or specified characters from a string.\r\n *\r\n * @param {string} str - The string from which characters will be trimmed.\r\n * @param {string | string[]} chars - The character(s) to remove from the string. Can be a single character or an array of characters.\r\n * @returns {string} - The resulting string after the specified characters have been removed.\r\n *\r\n * @example\r\n * trim(\"  hello  \"); // \"hello\"\r\n * trim(\"--hello--\", \"-\"); // \"hello\"\r\n * trim(\"##hello##\", [\"#\", \"o\"]); // \"hell\"\r\n */\r\nexport function trim(str: string, chars?: string | string[]): string {\r\n  if (chars === undefined) {\r\n    return str.trim();\r\n  }\r\n\r\n  return trimStart(trimEnd(str, chars), chars);\r\n}\r\n","const deburrMap = new Map<string, string>(\r\n  Object.entries({\r\n    : 'Ae',\r\n    : 'D',\r\n    : 'O',\r\n    : 'Th',\r\n    : 'ss',\r\n    : 'ae',\r\n    : 'd',\r\n    : 'o',\r\n    : 'th',\r\n    : 'D',\r\n    : 'd',\r\n    : 'H',\r\n    : 'h',\r\n    : 'i',\r\n    : 'IJ',\r\n    : 'ij',\r\n    : 'k',\r\n    : 'L',\r\n    : 'l',\r\n    : 'L',\r\n    : 'l',\r\n    : \"'n\",\r\n    : 'N',\r\n    : 'n',\r\n    : 'Oe',\r\n    : 'oe',\r\n    : 'T',\r\n    : 't',\r\n    : 's',\r\n  })\r\n);\r\n\r\n/**\r\n * Converts a string by replacing special characters and diacritical marks with their ASCII equivalents.\r\n * For example, \"Crme brle\" becomes \"Creme brulee\".\r\n *\r\n * @param {string} str - The input string to be deburred.\r\n * @returns {string} - The deburred string with special characters replaced by their ASCII equivalents.\r\n *\r\n * @example\r\n * // Basic usage:\r\n * deburr('thelred') // returns 'Aethelred'\r\n *\r\n * @example\r\n * // Handling diacritical marks:\r\n * deburr('Mnchen') // returns 'Munchen'\r\n *\r\n * @example\r\n * // Special characters:\r\n * deburr('Crme brle') // returns 'Creme brulee'\r\n */\r\nexport function deburr(str: string): string {\r\n  str = str.normalize('NFD');\r\n\r\n  let result = '';\r\n\r\n  for (let i = 0; i < str.length; i++) {\r\n    const char = str[i];\r\n\r\n    if ((char >= '\\u0300' && char <= '\\u036f') || (char >= '\\ufe20' && char <= '\\ufe23')) {\r\n      continue;\r\n    }\r\n\r\n    result += deburrMap.get(char) ?? char;\r\n  }\r\n\r\n  return result;\r\n}\r\n","const htmlEscapes: Record<string, string> = {\r\n  '&': '&amp;',\r\n  '<': '&lt;',\r\n  '>': '&gt;',\r\n  '\"': '&quot;',\r\n  \"'\": '&#39;',\r\n};\r\n\r\n/**\r\n * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `str` to their corresponding HTML entities.\r\n * For example, \"<\" becomes \"&lt;\".\r\n *\r\n * @param {string} str  The string to escape.\r\n * @returns {string} Returns the escaped string.\r\n *\r\n * @example\r\n * escape('This is a <div> element.'); // returns 'This is a &lt;div&gt; element.'\r\n * escape('This is a \"quote\"'); // returns 'This is a &quot;quote&quot;'\r\n * escape(\"This is a 'quote'\"); // returns 'This is a &#39;quote&#39;'\r\n * escape('This is a & symbol'); // returns 'This is a &amp; symbol'\r\n */\r\nexport function escape(str: string): string {\r\n  return str.replace(/[&<>\"']/g, match => htmlEscapes[match]);\r\n}\r\n","const htmlUnescapes: Record<string, string> = {\r\n  '&amp;': '&',\r\n  '&lt;': '<',\r\n  '&gt;': '>',\r\n  '&quot;': '\"',\r\n  '&#39;': \"'\",\r\n};\r\n\r\n/**\r\n * Converts the HTML entities `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `str` to their corresponding characters.\r\n * It is the inverse of `escape`.\r\n *\r\n * @param {string} str The string to unescape.\r\n * @returns {string} Returns the unescaped string.\r\n *\r\n * @example\r\n * unescape('This is a &lt;div&gt; element.'); // returns 'This is a <div> element.'\r\n * unescape('This is a &quot;quote&quot;'); // returns 'This is a \"quote\"'\r\n * unescape('This is a &#39;quote&#39;'); // returns 'This is a 'quote''\r\n * unescape('This is a &amp; symbol'); // returns 'This is a & symbol'\r\n */\r\nexport function unescape(str: string): string {\r\n  return str.replace(/&(?:amp|lt|gt|quot|#(0+)?39);/g, match => htmlUnescapes[match] || \"'\");\r\n}\r\n","/**\r\n * Checks if a given key is a deep key.\r\n *\r\n * A deep key is a string that contains a dot (.) or square brackets with a property accessor.\r\n *\r\n * @param {PropertyKey} key - The key to check.\r\n * @returns {boolean} - Returns true if the key is a deep key, otherwise false.\r\n *\r\n * Examples:\r\n *\r\n * isDeepKey('a.b') // true\r\n * isDeepKey('a[b]') // true\r\n * isDeepKey('a') // false\r\n * isDeepKey(123) // false\r\n * isDeepKey('a.b.c') // true\r\n * isDeepKey('a[b][c]') // true\r\n */\r\nexport function isDeepKey(key: PropertyKey): boolean {\r\n  switch (typeof key) {\r\n    case 'number':\r\n    case 'symbol': {\r\n      return false;\r\n    }\r\n    case 'string': {\r\n      return key.includes('.') || key.includes('[') || key.includes(']');\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Converts `value` to a string key if it's not a string or symbol.\r\n *\r\n * @private\r\n * @param {*} value The value to inspect.\r\n * @returns {string|symbol} Returns the key.\r\n */\r\nexport function toKey(value: number) {\r\n  if (Object.is(value, -0)) {\r\n    return '-0';\r\n  }\r\n  return value.toString();\r\n}\r\n","const DOTS_KEY = /^[\\w.]+$/g;\r\n\r\nconst ESCAPE_REGEXP = /\\\\(\\\\)?/g;\r\nconst PROPERTY_REGEXP = RegExp(\r\n  // Match anything that isn't a dot or bracket.\r\n  '[^.[\\\\]]+' +\r\n    '|' +\r\n    // Or match property names within brackets.\r\n    '\\\\[(?:' +\r\n    // Match a non-string expression.\r\n    '([^\"\\'][^[]*)' +\r\n    '|' +\r\n    // Or match strings (supports escaping characters).\r\n    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\r\n    ')\\\\]' +\r\n    '|' +\r\n    // Or match \"\" as the space between consecutive dots or empty brackets.\r\n    '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))',\r\n  'g'\r\n);\r\n\r\n/**\r\n * Converts a deep key string into an array of path segments.\r\n *\r\n * This function takes a string representing a deep key (e.g., 'a.b.c' or 'a[b][c]') and breaks it down into an array of strings, each representing a segment of the path.\r\n *\r\n * @param {string} deepKey - The deep key string to convert.\r\n * @returns {string[]} An array of strings, each representing a segment of the path.\r\n *\r\n * Examples:\r\n *\r\n * toPath('a.b.c') // Returns ['a', 'b', 'c']\r\n * toPath('a[b][c]') // Returns ['a', 'b', 'c']\r\n * toPath('.a.b.c') // Returns ['', 'a', 'b', 'c']\r\n * toPath('a[\"b.c\"].d') // Returns ['a', 'b.c', 'd']\r\n * toPath('') // Returns []\r\n * toPath('.a[b].c.d[e][\"f.g\"].h') // Returns ['', 'a', 'b', 'c', 'd', 'e', 'f.g', 'h']\r\n */\r\nexport function toPath(deepKey: string): string[] {\r\n  if (DOTS_KEY.test(deepKey)) {\r\n    return deepKey.split('.');\r\n  }\r\n\r\n  const result: string[] = [];\r\n\r\n  if (deepKey[0] === '.') {\r\n    result.push('');\r\n  }\r\n\r\n  const matches = deepKey.matchAll(PROPERTY_REGEXP);\r\n\r\n  for (const match of matches) {\r\n    let key = match[0];\r\n    const expr = match[1];\r\n    const quote = match[2];\r\n    const substr = match[3];\r\n\r\n    if (quote) {\r\n      key = substr.replace(ESCAPE_REGEXP, '$1');\r\n    } else if (expr) {\r\n      key = expr;\r\n    }\r\n\r\n    result.push(key);\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { isDeepKey } from '../_internal/isDeepKey.ts';\r\nimport { toKey } from '../_internal/toKey.ts';\r\nimport { toPath } from '../util/toPath.ts';\r\nimport type { Get } from './get.types.ts';\r\n\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K - The type of the key in the object.\r\n * @template D - The type of the default value.\r\n *\r\n * @param {T} object - The object to query.\r\n * @param {K | [K]} path - The path of the property to get.\r\n * @returns {T[K]} - Returns the resolved value.\r\n */\r\nexport function get<T extends object, K extends keyof T>(object: T, path: K | readonly [K]): T[K];\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K - The type of the key in the object.\r\n *\r\n * @param {T | null | undefined} object - The object to query.\r\n * @param {K | [K]} path - The path of the property to get.\r\n * @returns {T[K] | undefined} - Returns the resolved value.\r\n */\r\nexport function get<T extends object, K extends keyof T>(\r\n  object: T | null | undefined,\r\n  path: K | readonly [K]\r\n): T[K] | undefined;\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K - The type of the key in the object.\r\n * @template D - The type of the default value.\r\n *\r\n * @param {T | null | undefined} object - The object to query.\r\n * @param {K | [K]} path - The path of the property to get.\r\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\r\n * @returns {Exclude<T[K], undefined> | D} - Returns the resolved value.\r\n */\r\nexport function get<T extends object, K extends keyof T, D>(\r\n  object: T | null | undefined,\r\n  path: K | readonly [K],\r\n  defaultValue: D\r\n): Exclude<T[K], undefined> | D;\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the first key in the object.\r\n * @template K2 - The type of the second key in the object.\r\n *\r\n * @param {T} object - The object to query.\r\n * @param {[K1, K2]} path - The path of the property to get.\r\n * @returns {T[K1][K2]} - Returns the resolved value.\r\n */\r\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1]>(\r\n  object: T,\r\n  path: readonly [K1, K2]\r\n): T[K1][K2];\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the first key in the object.\r\n * @template K2 - The type of the second key in the object.\r\n *\r\n * @param {T | null | undefined} object - The object to query.\r\n * @param {[K1, K2]} path - The path of the property to get.\r\n * @returns {T[K1][K2] | undefined} - Returns the resolved value.\r\n */\r\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1]>(\r\n  object: T | null | undefined,\r\n  path: readonly [K1, K2]\r\n): T[K1][K2] | undefined;\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the first key in the object.\r\n * @template K2 - The type of the second key in the object.\r\n * @template D - The type of the default value.\r\n *\r\n * @param {T | null | undefined} object - The object to query.\r\n * @param {[K1, K2]} path - The path of the property to get.\r\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\r\n * @returns {Exclude<T[K1][K2], undefined> | D} - Returns the resolved value.\r\n */\r\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], D>(\r\n  object: T | null | undefined,\r\n  path: readonly [K1, K2],\r\n  defaultValue: D\r\n): Exclude<T[K1][K2], undefined> | D;\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the first key in the object.\r\n * @template K2 - The type of the second key in the object.\r\n * @template K3 - The type of the third key in the object.\r\n *\r\n * @param {T} object - The object to query.\r\n * @param {[K1, K2, K3]} path - The path of the property to get.\r\n * @returns {T[K1][K2][K3]} - Returns the resolved value.\r\n */\r\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\r\n  object: T,\r\n  path: readonly [K1, K2, K3]\r\n): T[K1][K2][K3];\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the first key in the object.\r\n * @template K2 - The type of the second key in the object.\r\n * @template K3 - The type of the third key in the object.\r\n *\r\n * @param {T | null | undefined} object - The object to query.\r\n * @param {[K1, K2, K3]} path - The path of the property to get.\r\n * @returns {T[K1][K2][K3] | undefined} - Returns the resolved value.\r\n */\r\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\r\n  object: T | null | undefined,\r\n  path: readonly [K1, K2, K3]\r\n): T[K1][K2][K3] | undefined;\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the first key in the object.\r\n * @template K2 - The type of the second key in the object.\r\n * @template K3 - The type of the third key in the object.\r\n * @template D - The type of the default value.\r\n *\r\n * @param {T | null | undefined} object - The object to query.\r\n * @param {[K1, K2, K3]} path - The path of the property to get.\r\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\r\n * @returns {Exclude<T[K1][K2][K3], undefined> | D} - Returns the resolved value.\r\n */\r\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], D>(\r\n  object: T | null | undefined,\r\n  path: readonly [K1, K2, K3],\r\n  defaultValue: D\r\n): Exclude<T[K1][K2][K3], undefined> | D;\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the first key in the object.\r\n * @template K2 - The type of the second key in the object.\r\n * @template K3 - The type of the third key in the object.\r\n * @template K4 - The type of the fourth key in the object.\r\n *\r\n * @param {T} object - The object to query.\r\n * @param {[K1, K2, K3, K4]} path - The path of the property to get.\r\n * @returns {T[K1][K2][K3][K4]} - Returns the resolved value.\r\n */\r\nexport function get<\r\n  T extends object,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n>(object: T, path: readonly [K1, K2, K3, K4]): T[K1][K2][K3][K4];\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the first key in the object.\r\n * @template K2 - The type of the second key in the object.\r\n * @template K3 - The type of the third key in the object.\r\n * @template K4 - The type of the fourth key in the object.\r\n *\r\n * @param {T | null | undefined} object - The object to query.\r\n * @param {[K1, K2, K3, K4]} path - The path of the property to get.\r\n * @returns {T[K1][K2][K3][K4] | undefined} - Returns the resolved value.\r\n */\r\nexport function get<\r\n  T extends object,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n>(object: T | null | undefined, path: readonly [K1, K2, K3, K4]): T[K1][K2][K3][K4] | undefined;\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the first key in the object.\r\n * @template K2 - The type of the second key in the object.\r\n * @template K3 - The type of the third key in the object.\r\n * @template K4 - The type of the fourth key in the object.\r\n * @template D - The type of the default value.\r\n *\r\n * @param {T | null | undefined} object - The object to query.\r\n * @param {[K1, K2, K3, K4]} path - The path of the property to get.\r\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\r\n * @returns {Exclude<T[K1][K2][K3][K4], undefined> | D} - Returns the resolved value.\r\n */\r\nexport function get<\r\n  T extends object,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n  D,\r\n>(\r\n  object: T | null | undefined,\r\n  path: readonly [K1, K2, K3, K4],\r\n  defaultValue: D\r\n): Exclude<T[K1][K2][K3][K4], undefined> | D;\r\n/**\r\n * Retrieves the value at a given path from an object with numeric keys. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the value.\r\n *\r\n * @param {Record<number, T>} object - The object to query.\r\n * @param {number} path - The path of the property to get.\r\n * @returns {T} - Returns the resolved value.\r\n */\r\nexport function get<T>(object: Record<number, T>, path: number): T;\r\n/**\r\n * Retrieves the value at a given path from an object with numeric keys. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the value.\r\n *\r\n * @param {Record<number, T> | null | undefined} object - The object to query.\r\n * @param {number} path - The path of the property to get.\r\n * @returns {T | undefined} - Returns the resolved value.\r\n */\r\nexport function get<T>(object: Record<number, T> | null | undefined, path: number): T | undefined;\r\n/**\r\n * Retrieves the value at a given path from an object with numeric keys. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the value.\r\n * @template D - The type of the default value.\r\n *\r\n * @param {Record<number, T> | null | undefined} object - The object to query.\r\n * @param {number} path - The path of the property to get.\r\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\r\n * @returns {T | D} - Returns the resolved value.\r\n */\r\nexport function get<T, D>(object: Record<number, T> | null | undefined, path: number, defaultValue: D): T | D;\r\n/**\r\n * Retrieves the value at a given path from a null or undefined object, returning the default value.\r\n *\r\n * @template D - The type of the default value.\r\n *\r\n * @param {null | undefined} object - The object to query.\r\n * @param {PropertyKey} path - The path of the property to get.\r\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\r\n * @returns {D} - Returns the default value.\r\n */\r\nexport function get<D>(object: null | undefined, path: PropertyKey, defaultValue: D): D;\r\n/**\r\n * Retrieves the value at a given path from a null or undefined object, returning undefined.\r\n *\r\n * @param {null | undefined} object - The object to query.\r\n * @param {PropertyKey} path - The path of the property to get.\r\n * @returns {undefined} - Returns undefined.\r\n */\r\nexport function get(object: null | undefined, path: PropertyKey): undefined;\r\n/**\r\n * Retrieves the value at a given path from a string-keyed object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template P - The type of the path.\r\n *\r\n * @param {T} data - The object to query.\r\n * @param {P} path - The path of the property to get.\r\n * @returns {string extends P ? any : Get<T, P>} - Returns the resolved value.\r\n */\r\nexport function get<T, P extends string>(data: T, path: P): string extends P ? any : Get<T, P>;\r\n/**\r\n * Retrieves the value at a given path from a string-keyed object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template P - The type of the path.\r\n * @template D - The type of the default value.\r\n *\r\n * @param {T} data - The object to query.\r\n * @param {P} path - The path of the property to get.\r\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\r\n * @returns {Exclude<Get<T, P>, null | undefined> | D} - Returns the resolved value.\r\n */\r\nexport function get<T, P extends string, D = Get<T, P>>(\r\n  data: T,\r\n  path: P,\r\n  defaultValue: D\r\n): Exclude<Get<T, P>, null | undefined> | D;\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @param {unknown} object - The object to query.\r\n * @param {PropertyKey | readonly PropertyKey[]} path - The path of the property to get.\r\n * @param {unknown} [defaultValue] - The value returned if the resolved value is undefined.\r\n * @returns {any} - Returns the resolved value.\r\n */\r\nexport function get(object: unknown, path: PropertyKey | readonly PropertyKey[], defaultValue?: unknown): any;\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @param {unknown} object - The object to query.\r\n * @param {PropertyKey | readonly PropertyKey[]} path - The path of the property to get.\r\n * @param {unknown} [defaultValue] - The value returned if the resolved value is undefined.\r\n * @returns {any} - Returns the resolved value.\r\n */\r\nexport function get(object: any, path: PropertyKey | readonly PropertyKey[], defaultValue?: any): any {\r\n  if (object == null) {\r\n    return defaultValue;\r\n  }\r\n\r\n  switch (typeof path) {\r\n    case 'string': {\r\n      const result = object[path];\r\n\r\n      if (result === undefined) {\r\n        if (isDeepKey(path)) {\r\n          return get(object, toPath(path), defaultValue);\r\n        } else {\r\n          return defaultValue;\r\n        }\r\n      }\r\n\r\n      return result;\r\n    }\r\n    case 'number':\r\n    case 'symbol': {\r\n      if (typeof path === 'number') {\r\n        path = toKey(path);\r\n      }\r\n\r\n      const result = object[path];\r\n\r\n      if (result === undefined) {\r\n        return defaultValue;\r\n      }\r\n\r\n      return result;\r\n    }\r\n    default: {\r\n      if (Array.isArray(path)) {\r\n        return getWithPath(object, path, defaultValue);\r\n      }\r\n\r\n      if (Object.is(path?.valueOf(), -0)) {\r\n        path = '-0';\r\n      } else {\r\n        path = String(path);\r\n      }\r\n\r\n      const result = object[path];\r\n\r\n      if (result === undefined) {\r\n        return defaultValue;\r\n      }\r\n\r\n      return result;\r\n    }\r\n  }\r\n}\r\n\r\nfunction getWithPath(object: any, path: readonly PropertyKey[], defaultValue?: any): any {\r\n  if (path.length === 0) {\r\n    return defaultValue;\r\n  }\r\n\r\n  let current = object;\r\n\r\n  for (let index = 0; index < path.length; index++) {\r\n    if (current == null) {\r\n      return defaultValue;\r\n    }\r\n\r\n    current = current[path[index]];\r\n  }\r\n\r\n  if (current === undefined) {\r\n    return defaultValue;\r\n  }\r\n\r\n  return current;\r\n}\r\n","import { get } from './get.ts';\r\n\r\n/**\r\n * Creates a function that returns the value at a given path of an object.\r\n *\r\n * @param {PropertyKey | PropertyKey[]} path - The path of the property to get.\r\n * @returns {(object: unknown) => any} - Returns a new function that takes an object and returns the value at the specified path.\r\n *\r\n * @example\r\n * const getObjectValue = property('a.b.c');\r\n * const result = getObjectValue({ a: { b: { c: 3 } } });\r\n * console.log(result); // => 3\r\n *\r\n * @example\r\n * const getObjectValue = property(['a', 'b', 'c']);\r\n * const result = getObjectValue({ a: { b: { c: 3 } } });\r\n * console.log(result); // => 3\r\n */\r\nexport function property(path: PropertyKey | readonly PropertyKey[]): (object: unknown) => any {\r\n  return function (object: unknown) {\r\n    return get(object, path);\r\n  };\r\n}\r\n","import { isPrimitive } from '../../predicate/isPrimitive.ts';\r\n\r\n/**\r\n * Checks if the target matches the source by comparing their structures and values.\r\n * This function supports deep comparison for objects, arrays, maps, and sets.\r\n *\r\n * @param {unknown} target - The target value to match against.\r\n * @param {unknown} source - The source value to match with.\r\n * @returns {boolean} - Returns `true` if the target matches the source, otherwise `false`.\r\n *\r\n * @example\r\n * // Basic usage\r\n * isMatch({ a: 1, b: 2 }, { a: 1 }); // true\r\n *\r\n * @example\r\n * // Matching arrays\r\n * isMatch([1, 2, 3], [1, 2, 3]); // true\r\n *\r\n * @example\r\n * // Matching maps\r\n * const targetMap = new Map([['key1', 'value1'], ['key2', 'value2']]);\r\n * const sourceMap = new Map([['key1', 'value1']]);\r\n * isMatch(targetMap, sourceMap); // true\r\n *\r\n * @example\r\n * // Matching sets\r\n * const targetSet = new Set([1, 2, 3]);\r\n * const sourceSet = new Set([1, 2]);\r\n * isMatch(targetSet, sourceSet); // true\r\n */\r\nexport function isMatch(target: unknown, source: unknown): boolean;\r\n/**\r\n * Checks if the target matches the source by comparing their structures and values.\r\n * This function supports deep comparison for objects, arrays, maps, and sets.\r\n *\r\n * @param {unknown} target - The target value to match against.\r\n * @param {unknown} source - The source value to match with.\r\n * @returns {boolean} - Returns `true` if the target matches the source, otherwise `false`.\r\n *\r\n * @example\r\n * // Basic usage\r\n * isMatch({ a: 1, b: 2 }, { a: 1 }); // true\r\n *\r\n * @example\r\n * // Matching arrays\r\n * isMatch([1, 2, 3], [1, 2, 3]); // true\r\n *\r\n * @example\r\n * // Matching maps\r\n * const targetMap = new Map([['key1', 'value1'], ['key2', 'value2']]);\r\n * const sourceMap = new Map([['key1', 'value1']]);\r\n * isMatch(targetMap, sourceMap); // true\r\n *\r\n * @example\r\n * // Matching sets\r\n * const targetSet = new Set([1, 2, 3]);\r\n * const sourceSet = new Set([1, 2]);\r\n * isMatch(targetSet, sourceSet); // true\r\n */\r\nexport function isMatch(target: any, source: any): boolean {\r\n  if (source === target) {\r\n    return true;\r\n  }\r\n\r\n  switch (typeof source) {\r\n    case 'object': {\r\n      if (source == null) {\r\n        return true;\r\n      }\r\n\r\n      const keys = Object.keys(source as any);\r\n\r\n      if (target == null) {\r\n        if (keys.length === 0) {\r\n          return true;\r\n        }\r\n\r\n        return false;\r\n      }\r\n\r\n      if (Array.isArray(source)) {\r\n        return isArrayMatch(target, source);\r\n      }\r\n\r\n      if (source instanceof Map) {\r\n        return isMapMatch(target, source);\r\n      }\r\n\r\n      if (source instanceof Set) {\r\n        return isSetMatch(target, source);\r\n      }\r\n\r\n      for (let i = 0; i < keys.length; i++) {\r\n        const key = keys[i];\r\n\r\n        if (!isPrimitive(target) && !(key in target)) {\r\n          return false;\r\n        }\r\n\r\n        if (source[key] === undefined && target[key] !== undefined) {\r\n          return false;\r\n        }\r\n\r\n        if (!isMatch(target[key], source[key])) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    }\r\n    case 'function': {\r\n      if (Object.keys(source).length > 0) {\r\n        return isMatch(target, { ...source });\r\n      }\r\n\r\n      return false;\r\n    }\r\n    default: {\r\n      return !source;\r\n    }\r\n  }\r\n}\r\n\r\nexport function isMapMatch(target: unknown, source: Map<any, any>) {\r\n  if (source.size === 0) {\r\n    return true;\r\n  }\r\n\r\n  if (!(target instanceof Map)) {\r\n    return false;\r\n  }\r\n\r\n  for (const [key, value] of source.entries()) {\r\n    if (!isMatch(target.get(key), value)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isArrayMatch(target: unknown, source: readonly unknown[]) {\r\n  if (source.length === 0) {\r\n    return true;\r\n  }\r\n\r\n  if (!Array.isArray(target)) {\r\n    return false;\r\n  }\r\n\r\n  const countedIndex = new Set<number>();\r\n\r\n  for (let i = 0; i < source.length; i++) {\r\n    const sourceItem = source[i];\r\n    const index = target.findIndex((targetItem, index) => {\r\n      return isMatch(targetItem, sourceItem) && !countedIndex.has(index);\r\n    });\r\n\r\n    if (index === -1) {\r\n      return false;\r\n    }\r\n\r\n    countedIndex.add(index);\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isSetMatch(target: unknown, source: Set<any>) {\r\n  if (source.size === 0) {\r\n    return true;\r\n  }\r\n\r\n  if (!(target instanceof Set)) {\r\n    return false;\r\n  }\r\n\r\n  return isArrayMatch([...target], [...source]);\r\n}\r\n","import { cloneDeep } from '../../object/cloneDeep.ts';\r\nimport { isMatch } from './isMatch.ts';\r\n\r\n/**\r\n * Creates a function that performs a deep comparison between a given target and the source object.\r\n *\r\n * @param {unknown} source - The source object to create the matcher from.\r\n * @returns {(target: unknown) => boolean} - Returns a function that takes a target object and returns `true` if the target matches the source, otherwise `false`.\r\n *\r\n * @example\r\n * // Basic usage\r\n * const matcher = matches({ a: 1, b: 2 });\r\n * matcher({ a: 1, b: 2, c: 3 }); // true\r\n * matcher({ a: 1, c: 3 }); // false\r\n *\r\n * @example\r\n * // Matching arrays\r\n * const arrayMatcher = matches([1, 2, 3]);\r\n * arrayMatcher([1, 2, 3, 4]); // true\r\n * arrayMatcher([4, 5, 6]); // false\r\n *\r\n * @example\r\n * // Matching objects with nested structures\r\n * const nestedMatcher = matches({ a: { b: 2 } });\r\n * nestedMatcher({ a: { b: 2, c: 3 } }); // true\r\n * nestedMatcher({ a: { c: 3 } }); // false\r\n */\r\nexport function matches(source: unknown): (target: unknown) => boolean {\r\n  source = cloneDeep(source);\r\n\r\n  return (target?: unknown): boolean => {\r\n    return isMatch(target, source);\r\n  };\r\n}\r\n","import { cloneDeep as cloneDeepToolkit, copyProperties } from '../../object/cloneDeep.ts';\r\nimport { argumentsTag, booleanTag, numberTag, stringTag } from '../_internal/tags.ts';\r\n\r\n/**\r\n * Creates a deep clone of the given object.\r\n *\r\n * @template T - The type of the object.\r\n * @param {T} obj - The object to clone.\r\n * @returns {T} - A deep clone of the given object.\r\n *\r\n * @example\r\n * // Clone a primitive values\r\n * const num = 29;\r\n * const clonedNum = clone(num);\r\n * console.log(clonedNum); // 29\r\n * console.log(clonedNum === num) ; // true\r\n *\r\n * @example\r\n * // Clone an array\r\n * const arr = [1, 2, 3];\r\n * const clonedArr = clone(arr);\r\n * console.log(clonedArr); // [1, 2, 3]\r\n * console.log(clonedArr === arr); // false\r\n *\r\n * @example\r\n * // Clone an array with nested objects\r\n * const arr = [1, { a: 1 }, [1, 2, 3]];\r\n * const clonedArr = clone(arr);\r\n * arr[1].a = 2;\r\n * console.log(arr); // [2, { a: 2 }, [1, 2, 3]]\r\n * console.log(clonedArr); // [1, { a: 1 }, [1, 2, 3]]\r\n * console.log(clonedArr === arr); // false\r\n *\r\n * @example\r\n * // Clone an object\r\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\r\n * const clonedObj = clone(obj);\r\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\r\n * console.log(clonedObj === obj); // false\r\n *\r\n * @example\r\n * // Clone an object with nested objects\r\n * const obj = { a: 1, b: { c: 1 } };\r\n * const clonedObj = clone(obj);\r\n * obj.b.c = 2;\r\n * console.log(obj); // { a: 1, b: { c: 2 } }\r\n * console.log(clonedObj); // { a: 1, b: { c: 1 } }\r\n * console.log(clonedObj === obj); // false\r\n */\r\nexport function cloneDeep<T>(obj: T): T {\r\n  if (typeof obj !== 'object') {\r\n    return cloneDeepToolkit(obj);\r\n  }\r\n\r\n  switch (Object.prototype.toString.call(obj)) {\r\n    case numberTag:\r\n    case stringTag:\r\n    case booleanTag: {\r\n      // eslint-disable-next-line\r\n      // @ts-ignore\r\n      const result = new obj.constructor(obj?.valueOf()) as T;\r\n      copyProperties(result, obj);\r\n      return result;\r\n    }\r\n\r\n    case argumentsTag: {\r\n      const result = {} as any;\r\n\r\n      copyProperties(result, obj);\r\n\r\n      // eslint-disable-next-line\r\n      // @ts-ignore\r\n      result.length = obj.length;\r\n      // eslint-disable-next-line\r\n      // @ts-ignore\r\n      result[Symbol.iterator] = obj[Symbol.iterator];\r\n\r\n      return result as T;\r\n    }\r\n\r\n    default: {\r\n      return cloneDeepToolkit(obj);\r\n    }\r\n  }\r\n}\r\n","const IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\\d*)$/;\r\n\r\nexport function isIndex(value: PropertyKey) {\r\n  switch (typeof value) {\r\n    case 'number': {\r\n      return Number.isInteger(value) && value >= 0 && value < Number.MAX_SAFE_INTEGER;\r\n    }\r\n    case 'symbol': {\r\n      return false;\r\n    }\r\n    case 'string': {\r\n      return IS_UNSIGNED_INTEGER.test(value);\r\n    }\r\n  }\r\n}\r\n","import { getTag } from '../_internal/getTag.ts';\r\n\r\n/**\r\n * Checks if the given value is an arguments object.\r\n *\r\n * This function tests whether the provided value is an arguments object or not.\r\n * It returns `true` if the value is an arguments object, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an arguments object.\r\n *\r\n * @param {unknown} value - The value to test if it is an arguments object.\r\n * @returns {value is IArguments} `true` if the value is an arguments, `false` otherwise.\r\n *\r\n * @example\r\n * const args = (function() { return arguments; })();\r\n * const strictArgs = (function() { 'use strict'; return arguments; })();\r\n * const value = [1, 2, 3];\r\n *\r\n * console.log(isArguments(args)); // true\r\n * console.log(isArguments(strictArgs)); // true\r\n * console.log(isArguments(value)); // false\r\n */\r\nexport function isArguments(value?: unknown): value is IArguments {\r\n  return value !== null && typeof value === 'object' && getTag(value) === '[object Arguments]';\r\n}\r\n","import { isDeepKey } from '../_internal/isDeepKey.ts';\r\nimport { isIndex } from '../_internal/isIndex.ts';\r\nimport { toPath } from '../util/toPath.ts';\r\nimport { isArguments } from '../predicate/isArguments.ts';\r\n\r\n/**\r\n * Checks if a given path exists within an object.\r\n *\r\n * You can provide the path as a single property key, an array of property keys,\r\n * or a string representing a deep path.\r\n *\r\n * If the path is an index and the object is an array or an arguments object, the function will verify\r\n * if the index is valid and within the bounds of the array or arguments object, even if the array or\r\n * arguments object is sparse (i.e., not all indexes are defined).\r\n *\r\n * @param {object} object - The object to query.\r\n * @param {PropertyKey | PropertyKey[]} path - The path to check. This can be a single property key,\r\n *        an array of property keys, or a string representing a deep path.\r\n * @returns {boolean} Returns `true` if the path exists in the object, `false` otherwise.\r\n *\r\n * @example\r\n *\r\n * const obj = { a: { b: { c: 3 } } };\r\n *\r\n * has(obj, 'a'); // true\r\n * has(obj, ['a', 'b']); // true\r\n * has(obj, ['a', 'b', 'c']); // true\r\n * has(obj, 'a.b.c'); // true\r\n * has(obj, 'a.b.d'); // false\r\n * has(obj, ['a', 'b', 'c', 'd']); // false\r\n * has([], 0); // false\r\n * has([1, 2, 3], 2); // true\r\n * has([1, 2, 3], 5); // false\r\n */\r\nexport function has(object: unknown, path: PropertyKey | readonly PropertyKey[]): boolean;\r\n\r\n/**\r\n * Checks if a given path exists within an object.\r\n *\r\n * You can provide the path as a single property key, an array of property keys,\r\n * or a string representing a deep path.\r\n *\r\n * If the path is an index and the object is an array or an arguments object, the function will verify\r\n * if the index is valid and within the bounds of the array or arguments object, even if the array or\r\n * arguments object is sparse (i.e., not all indexes are defined).\r\n *\r\n * @param {object} object - The object to query.\r\n * @param {PropertyKey | PropertyKey[]} path - The path to check. This can be a single property key,\r\n *        an array of property keys, or a string representing a deep path.\r\n * @returns {boolean} Returns `true` if the path exists in the object, `false` otherwise.\r\n *\r\n * @example\r\n *\r\n * const obj = { a: { b: { c: 3 } } };\r\n *\r\n * has(obj, 'a'); // true\r\n * has(obj, ['a', 'b']); // true\r\n * has(obj, ['a', 'b', 'c']); // true\r\n * has(obj, 'a.b.c'); // true\r\n * has(obj, 'a.b.d'); // false\r\n * has(obj, ['a', 'b', 'c', 'd']); // false\r\n * has([], 0); // false\r\n * has([1, 2, 3], 2); // true\r\n * has([1, 2, 3], 5); // false\r\n */\r\nexport function has(object: any, path: PropertyKey | readonly PropertyKey[]): boolean {\r\n  let resolvedPath;\r\n\r\n  if (Array.isArray(path)) {\r\n    resolvedPath = path;\r\n  } else if (typeof path === 'string' && isDeepKey(path) && object?.[path] == null) {\r\n    resolvedPath = toPath(path);\r\n  } else {\r\n    resolvedPath = [path];\r\n  }\r\n\r\n  if (resolvedPath.length === 0) {\r\n    return false;\r\n  }\r\n\r\n  let current = object;\r\n\r\n  for (let i = 0; i < resolvedPath.length; i++) {\r\n    const key = resolvedPath[i];\r\n\r\n    // Check if the current key is a direct property of the current object\r\n    if (current == null || !Object.prototype.hasOwnProperty.call(current, key)) {\r\n      const isSparseIndex = (Array.isArray(current) || isArguments(current)) && isIndex(key) && key < current.length;\r\n\r\n      if (!isSparseIndex) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    current = current[key];\r\n  }\r\n\r\n  return true;\r\n}\r\n","import { toKey } from '../_internal/toKey.ts';\r\nimport { cloneDeep } from '../object/cloneDeep.ts';\r\nimport { get } from '../object/get.ts';\r\nimport { has } from '../object/has.ts';\r\nimport { isMatch } from './isMatch.ts';\r\n\r\n/**\r\n * Creates a function that checks if a given target object matches a specific property value.\r\n *\r\n * The returned function takes a target object and determines if the property at the\r\n * specified path within the target object is equal to the given value.\r\n *\r\n * @param {PropertyKey | PropertyKey[]} property - The property path to check within the target object.\r\n *     This can be a single property key or an array of property keys.\r\n * @param {unknown} source - The value to compare against the property value in the target object.\r\n *\r\n * @returns {(target: unknown) => boolean} - A function that takes a target object and returns\r\n *     `true` if the property value at the given path in the target object matches the provided value,\r\n *     otherwise returns `false`.\r\n *\r\n * @example\r\n * // Using a single property key\r\n * const checkName = matchesProperty('name', 'Alice');\r\n * console.log(checkName({ name: 'Alice' })); // true\r\n * console.log(checkName({ name: 'Bob' })); // false\r\n *\r\n * // Using an array of property keys\r\n * const checkNested = matchesProperty(['address', 'city'], 'New York');\r\n * console.log(checkNested({ address: { city: 'New York' } })); // true\r\n * console.log(checkNested({ address: { city: 'Los Angeles' } })); // false\r\n */\r\nexport function matchesProperty(\r\n  property: PropertyKey | readonly PropertyKey[],\r\n  source: unknown\r\n): (target?: unknown) => boolean {\r\n  switch (typeof property) {\r\n    case 'object': {\r\n      if (Object.is(property?.valueOf(), -0)) {\r\n        property = '-0';\r\n      }\r\n      break;\r\n    }\r\n    case 'number': {\r\n      property = toKey(property);\r\n      break;\r\n    }\r\n  }\r\n\r\n  source = cloneDeep(source);\r\n\r\n  return function (target?: unknown) {\r\n    const result = get(target, property as PropertyKey | PropertyKey[]);\r\n\r\n    if (result === undefined) {\r\n      return has(target, property as PropertyKey | PropertyKey[]);\r\n    }\r\n\r\n    if (source === undefined) {\r\n      return result === undefined;\r\n    }\r\n\r\n    return isMatch(result, source);\r\n  };\r\n}\r\n","/**\r\n * Flattens an array up to the specified depth.\r\n *\r\n * @template T - The type of elements within the array.\r\n * @template D - The depth to which the array should be flattened.\r\n * @param {T[] | object} value - The object to flatten.\r\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\r\n * @returns {Array<FlatArray<T[], D>> | []} A new array that has been flattened.\r\n *\r\n * @example\r\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 1);\r\n * // Returns: [1, 2, 3, 4, [5, 6]]\r\n *\r\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 2);\r\n * // Returns: [1, 2, 3, 4, 5, 6]\r\n */\r\nexport function flatten<T, D extends number = 1>(\r\n  value: readonly T[] | object,\r\n  depth = 1 as D\r\n): Array<FlatArray<T[], D>> | [] {\r\n  const result: Array<FlatArray<T[], D>> = [];\r\n  const flooredDepth = Math.floor(depth);\r\n\r\n  if (!Array.isArray(value)) {\r\n    return result;\r\n  }\r\n\r\n  const recursive = (arr: readonly T[], currentDepth: number) => {\r\n    for (const item of arr) {\r\n      if (\r\n        currentDepth < flooredDepth &&\r\n        (Array.isArray(item) ||\r\n          Boolean(item?.[Symbol.isConcatSpreadable as keyof object]) ||\r\n          (item !== null && typeof item === 'object' && Object.prototype.toString.call(item) === '[object Arguments]'))\r\n      ) {\r\n        if (Array.isArray(item)) {\r\n          recursive(item, currentDepth + 1);\r\n        } else {\r\n          recursive(Array.from(item as T[]), currentDepth + 1);\r\n        }\r\n      } else {\r\n        result.push(item as FlatArray<T[], D>);\r\n      }\r\n    }\r\n  };\r\n\r\n  recursive(value, 0);\r\n\r\n  return result;\r\n}\r\n","function getPriority(a: unknown): 0 | 1 | 2 | 3 | 4 {\r\n  if (typeof a === 'symbol') {\r\n    return 1;\r\n  }\r\n\r\n  if (a === null) {\r\n    return 2;\r\n  }\r\n\r\n  if (a === undefined) {\r\n    return 3;\r\n  }\r\n\r\n  if (a !== a) {\r\n    return 4;\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nexport const compareValues = <V>(a: V, b: V, order: string) => {\r\n  if (a !== b) {\r\n    // If both values are strings, compare them using localeCompare.\r\n    if (typeof a === 'string' && typeof b === 'string') {\r\n      return order === 'desc' ? b.localeCompare(a) : a.localeCompare(b);\r\n    }\r\n\r\n    const aPriority = getPriority(a);\r\n    const bPriority = getPriority(b);\r\n\r\n    // If both values are of the same priority and are normal values, compare them.\r\n    if (aPriority === bPriority && aPriority === 0) {\r\n      if (a < b) {\r\n        return order === 'desc' ? 1 : -1;\r\n      }\r\n\r\n      if (a > b) {\r\n        return order === 'desc' ? -1 : 1;\r\n      }\r\n    }\r\n\r\n    return order === 'desc' ? bPriority - aPriority : aPriority - bPriority;\r\n  }\r\n\r\n  return 0;\r\n};\r\n","/**\r\n * Check whether a value is a symbol.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `symbol`.\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {value is symbol} Returns `true` if `value` is a symbol, else `false`.\r\n * @example\r\n * isSymbol(Symbol.iterator);\r\n * // => true\r\n *\r\n * isSymbol('abc');\r\n * // => false\r\n */\r\nexport function isSymbol(value?: unknown): value is symbol {\r\n  return typeof value === 'symbol' || (value != null && value instanceof Symbol);\r\n}\r\n","import { isSymbol } from '../predicate/isSymbol.ts';\r\n\r\n/**  Matches any deep property path. (e.g. `a.b[0].c`)*/\r\nconst regexIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\r\n/**  Matches any word character (alphanumeric & underscore).*/\r\nconst regexIsPlainProp = /^\\w*$/;\r\n\r\n/**\r\n * Checks if `value` is a property name and not a property path. (It's ok that the `value` is not in the keys of the `object`)\r\n * @param {unknown} value The value to check.\r\n * @param {unknown} object The object to query.\r\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\r\n *\r\n * @example\r\n * isKey('a', { a: 1 });\r\n * // => true\r\n *\r\n * isKey('a.b', { a: { b: 2 } });\r\n * // => false\r\n */\r\nexport function isKey(value?: unknown, object?: unknown): boolean {\r\n  if (Array.isArray(value)) {\r\n    return false;\r\n  }\r\n\r\n  if (typeof value === 'number' || typeof value === 'boolean' || value == null || isSymbol(value)) {\r\n    return true;\r\n  }\r\n\r\n  return (\r\n    (typeof value === 'string' && (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value))) ||\r\n    (object != null && Object.hasOwn(object, value as PropertyKey))\r\n  );\r\n}\r\n","import { compareValues } from '../_internal/compareValues.ts';\r\nimport { isKey } from '../_internal/isKey.ts';\r\nimport { toPath } from '../util/toPath.ts';\r\n\r\nexport type Criterion<T> = ((item: T) => unknown) | PropertyKey | PropertyKey[] | null | undefined;\r\n/**\r\n * Sorts an array of objects based on multiple properties and their corresponding order directions.\r\n *\r\n * This function takes an array of objects, an array of criteria to sort by, and an array of order directions.\r\n * It returns the sorted array, ordering by each key according to its corresponding direction ('asc' for ascending or 'desc' for descending).\r\n * If values for a key are equal, it moves to the next key to determine the order.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param { T[] | object | null | undefined} collection - The array of objects to be sorted.\r\n * @param {Criterion<T> | Array<Criterion<T>>} criteria - An array of criteria (property names or property paths or custom key functions) to sort by.\r\n * @param {unknown | unknown[]} orders - An array of order directions ('asc' for ascending or 'desc' for descending).\r\n * @returns {T[]} - The sorted array.\r\n *\r\n * @example\r\n * // Sort an array of objects by 'user' in ascending order and 'age' in descending order.\r\n * const users = [\r\n *   { user: 'fred', age: 48 },\r\n *   { user: 'barney', age: 34 },\r\n *   { user: 'fred', age: 40 },\r\n *   { user: 'barney', age: 36 },\r\n * ];\r\n * const result = orderBy(users, ['user', (item) => item.age], ['asc', 'desc']);\r\n * // result will be:\r\n * // [\r\n * //   { user: 'barney', age: 36 },\r\n * //   { user: 'barney', age: 34 },\r\n * //   { user: 'fred', age: 48 },\r\n * //   { user: 'fred', age: 40 },\r\n * // ]\r\n */\r\nexport function orderBy<T>(\r\n  collection: readonly T[] | object | number | null | undefined,\r\n  criteria?: Criterion<T> | Array<Criterion<T>>,\r\n  orders?: unknown | unknown[]\r\n): T[] {\r\n  if (collection == null || typeof collection === 'number') {\r\n    return [];\r\n  }\r\n\r\n  if (typeof collection === 'object' && !Array.isArray(collection)) {\r\n    collection = Object.values(collection);\r\n  }\r\n\r\n  if (!Array.isArray(criteria)) {\r\n    criteria = criteria == null ? [null] : [criteria];\r\n  }\r\n\r\n  if (!Array.isArray(orders)) {\r\n    orders = orders == null ? [] : [orders];\r\n  }\r\n\r\n  // For Object('desc') case\r\n  orders = (orders as unknown[]).map(order => String(order));\r\n\r\n  const getValueByNestedPath = (object: object, path: PropertyKey[]) => {\r\n    let target: object = object;\r\n\r\n    for (let i = 0; i < path.length && target != null; ++i) {\r\n      target = target[path[i] as keyof typeof target];\r\n    }\r\n\r\n    return target;\r\n  };\r\n\r\n  const getValueByCriterion = (criterion: Criterion<T> | { key: PropertyKey; path: string[] }, object: T) => {\r\n    if (object == null || criterion == null) {\r\n      return object;\r\n    }\r\n\r\n    if (typeof criterion === 'object' && 'key' in criterion) {\r\n      if (Object.hasOwn(object, criterion.key)) {\r\n        return object[criterion.key as keyof typeof object];\r\n      }\r\n\r\n      return getValueByNestedPath(object, criterion.path);\r\n    }\r\n\r\n    if (typeof criterion === 'function') {\r\n      return criterion(object);\r\n    }\r\n\r\n    if (Array.isArray(criterion)) {\r\n      return getValueByNestedPath(object, criterion);\r\n    }\r\n\r\n    if (typeof object === 'object') {\r\n      return object[criterion as keyof typeof object];\r\n    }\r\n\r\n    return object;\r\n  };\r\n\r\n  // Prepare all cases for criteria\r\n  const preparedCriteria = criteria.map(criterion => {\r\n    // lodash handles a array with one element as a single criterion\r\n    if (Array.isArray(criterion) && criterion.length === 1) {\r\n      criterion = criterion[0];\r\n    }\r\n\r\n    if (criterion == null || typeof criterion === 'function' || Array.isArray(criterion) || isKey(criterion)) {\r\n      return criterion;\r\n    }\r\n\r\n    // If criterion is not key, it has possibility to be a deep path. So we have to prepare both cases.\r\n    return { key: criterion, path: toPath(criterion as string) } as const;\r\n  });\r\n\r\n  // Array.prototype.sort() always shifts the `undefined` values to the end of the array. So we have to prevent it by using a wrapper object.\r\n  const preparedCollection = (collection as T[]).map(item => ({\r\n    original: item,\r\n    criteria: preparedCriteria.map(criterion => getValueByCriterion(criterion, item)),\r\n  }));\r\n\r\n  return preparedCollection\r\n    .slice()\r\n    .sort((a, b) => {\r\n      for (let i = 0; i < preparedCriteria.length; i++) {\r\n        const comparedResult = compareValues(a.criteria[i], b.criteria[i], (orders as string[])[i]);\r\n\r\n        if (comparedResult !== 0) {\r\n          return comparedResult;\r\n        }\r\n      }\r\n\r\n      return 0;\r\n    })\r\n    .map(item => item.original);\r\n}\r\n","export function identity<T>(x: T) {\r\n  return x;\r\n}\r\n","import { isIndex } from '../_internal/isIndex.ts';\r\nimport { toPath } from '../util/toPath.ts';\r\n\r\n/**\r\n * Sets the value at the specified path of the given object. If any part of the path does not exist, it will be created.\r\n *\r\n * @template T - The type of the object.\r\n * @param {T} obj - The object to modify.\r\n * @param {PropertyKey | PropertyKey[]} path - The path of the property to set.\r\n * @param {any} value - The value to set.\r\n * @returns {T} - The modified object.\r\n *\r\n * @example\r\n * // Set a value in a nested object\r\n * const obj = { a: { b: { c: 3 } } };\r\n * set(obj, 'a.b.c', 4);\r\n * console.log(obj.a.b.c); // 4\r\n *\r\n * @example\r\n * // Set a value in an array\r\n * const arr = [1, 2, 3];\r\n * set(arr, 1, 4);\r\n * console.log(arr[1]); // 4\r\n *\r\n * @example\r\n * // Create non-existent path and set value\r\n * const obj = {};\r\n * set(obj, 'a.b.c', 4);\r\n * console.log(obj); // { a: { b: { c: 4 } } }\r\n */\r\nexport function set<T>(obj: object, path: PropertyKey | readonly PropertyKey[], value: unknown): T;\r\n/**\r\n * Sets the value at the specified path of the given object. If any part of the path does not exist, it will be created.\r\n *\r\n * @template T - The type of the object.\r\n * @param {T} obj - The object to modify.\r\n * @param {PropertyKey | PropertyKey[]} path - The path of the property to set.\r\n * @param {any} value - The value to set.\r\n * @returns {T} - The modified object.\r\n *\r\n * @example\r\n * // Set a value in a nested object\r\n * const obj = { a: { b: { c: 3 } } };\r\n * set(obj, 'a.b.c', 4);\r\n * console.log(obj.a.b.c); // 4\r\n *\r\n * @example\r\n * // Set a value in an array\r\n * const arr = [1, 2, 3];\r\n * set(arr, 1, 4);\r\n * console.log(arr[1]); // 4\r\n *\r\n * @example\r\n * // Create non-existent path and set value\r\n * const obj = {};\r\n * set(obj, 'a.b.c', 4);\r\n * console.log(obj); // { a: { b: { c: 4 } } }\r\n */\r\nexport function set<T extends object>(obj: T, path: PropertyKey | readonly PropertyKey[], value: unknown): T {\r\n  const resolvedPath = Array.isArray(path) ? path : typeof path === 'string' ? toPath(path) : [path];\r\n\r\n  let current: any = obj;\r\n\r\n  for (let i = 0; i < resolvedPath.length - 1; i++) {\r\n    const key = resolvedPath[i];\r\n    const nextKey = resolvedPath[i + 1];\r\n\r\n    if (current[key] == null) {\r\n      current[key] = isIndex(nextKey) ? [] : {};\r\n    }\r\n\r\n    current = current[key];\r\n  }\r\n\r\n  const lastKey = resolvedPath[resolvedPath.length - 1];\r\n  current[lastKey] = value;\r\n\r\n  return obj;\r\n}\r\n","/**\r\n * Creates a function that invokes `func` with the `this` binding of `thisArg` and `partials` prepended to the arguments it receives.\r\n *\r\n * The `bind.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\r\n *\r\n * Note: Unlike native `Function#bind`, this method doesn't set the `length` property of bound functions.\r\n *\r\n * @template F - The type of the function to bind.\r\n * @param {F} func - The function to bind.\r\n * @param {unknown} thisObj - The `this` binding of `func`.\r\n * @param {...any} partialArgs - The arguments to be partially applied.\r\n * @returns {F} - Returns the new bound function.\r\n *\r\n * @example\r\n * function greet(greeting, punctuation) {\r\n *   return greeting + ' ' + this.user + punctuation;\r\n * }\r\n * const object = { user: 'fred' };\r\n * let bound = bind(greet, object, 'hi');\r\n * bound('!');\r\n * // => 'hi fred!'\r\n *\r\n * bound = bind(greet, object, bind.placeholder, '!');\r\n * bound('hi');\r\n * // => 'hi fred!'\r\n */\r\nexport function bind<F extends (...args: any[]) => any>(func: F, thisObj?: unknown, ...partialArgs: any[]): F {\r\n  const bound = function (this: any, ...providedArgs: any[]) {\r\n    const args: any[] = [];\r\n\r\n    // Populate args by merging partialArgs and providedArgs.\r\n    // e.g.. when we call bind(func, {}, [1, bind.placeholder, 3])(2, 4);\r\n    // we have args with [1, 2, 3, 4].\r\n    let startIndex = 0;\r\n\r\n    for (let i = 0; i < partialArgs.length; i++) {\r\n      const arg = partialArgs[i];\r\n\r\n      if (arg === bind.placeholder) {\r\n        args.push(providedArgs[startIndex++]);\r\n      } else {\r\n        args.push(arg);\r\n      }\r\n    }\r\n\r\n    for (let i = startIndex; i < providedArgs.length; i++) {\r\n      args.push(providedArgs[i]);\r\n    }\r\n\r\n    if (this instanceof bound) {\r\n      // @ts-expect-error - fn is a constructor\r\n      return new func(...args);\r\n    }\r\n\r\n    return func.apply(thisObj, args);\r\n  };\r\n\r\n  return bound as any as F;\r\n}\r\n\r\nconst bindPlaceholder: unique symbol = Symbol('bind.placeholder');\r\nbind.placeholder = bindPlaceholder;\r\n","/**\r\n * Creates a function that invokes the method at `object[key]` with `partialArgs` prepended to the arguments it receives.\r\n *\r\n * This method differs from `bind` by allowing bound functions to reference methods that may be redefined or don't yet exist.\r\n *\r\n * The `bindKey.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\r\n *\r\n * @template T - The type of the object to bind.\r\n * @template K - The type of the key to bind.\r\n * @param {T} object - The object to invoke the method on.\r\n * @param {K} key - The key of the method.\r\n * @param {...any} partialArgs - The arguments to be partially applied.\r\n * @returns {T[K] extends (...args: any[]) => any ? (...args: any[]) => ReturnType<T[K]> : never} - Returns the new bound function.\r\n *\r\n * @example\r\n * const object = {\r\n *   user: 'fred',\r\n *   greet: function (greeting, punctuation) {\r\n *     return greeting + ' ' + this.user + punctuation;\r\n *   },\r\n * };\r\n *\r\n * let bound = bindKey(object, 'greet', 'hi');\r\n * bound('!');\r\n * // => 'hi fred!'\r\n *\r\n * object.greet = function (greeting, punctuation) {\r\n *   return greeting + 'ya ' + this.user + punctuation;\r\n * };\r\n *\r\n * bound('!');\r\n * // => 'hiya fred!'\r\n *\r\n * // Bound with placeholders.\r\n * bound = bindKey(object, 'greet', bindKey.placeholder, '!');\r\n * bound('hi');\r\n * // => 'hiya fred!'\r\n */\r\nexport function bindKey<T extends Record<PropertyKey, any>, K extends keyof T>(\r\n  object: T,\r\n  key: K,\r\n  ...partialArgs: any[]\r\n): T[K] extends (...args: any[]) => any ? (...args: any[]) => ReturnType<T[K]> : never {\r\n  const bound = function (this: any, ...providedArgs: any[]) {\r\n    const args: any[] = [];\r\n\r\n    // Populate args by merging partialArgs and providedArgs.\r\n    // e.g.. when we call bind(func, {}, [1, bind.placeholder, 3])(2, 4);\r\n    // we have args with [1, 2, 3, 4].\r\n    let startIndex = 0;\r\n\r\n    for (let i = 0; i < partialArgs.length; i++) {\r\n      const arg = partialArgs[i];\r\n\r\n      if (arg === bindKey.placeholder) {\r\n        args.push(providedArgs[startIndex++]);\r\n      } else {\r\n        args.push(arg);\r\n      }\r\n    }\r\n\r\n    for (let i = startIndex; i < providedArgs.length; i++) {\r\n      args.push(providedArgs[i]);\r\n    }\r\n\r\n    if (this instanceof bound) {\r\n      return new object[key](...args);\r\n    }\r\n\r\n    // eslint-disable-next-line prefer-spread\r\n    return object[key].apply(object, args);\r\n  };\r\n\r\n  return bound as any;\r\n}\r\n\r\nconst bindKeyPlaceholder: unique symbol = Symbol('bindKey.placeholder');\r\nbindKey.placeholder = bindKeyPlaceholder;\r\n","/**\r\n * Creates a function that accepts arguments of `func` and either invokes `func` returning its result, if at least `arity` number of arguments have been provided, or returns a function that accepts the remaining `func` arguments, and so on.\r\n * The arity of `func` may be specified if `func.length` is not sufficient.\r\n *\r\n * The `curry.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\r\n *\r\n * Note: This method doesn't set the `length` property of curried functions.\r\n *\r\n * @param {(...args: any[]) => any} func - The function to curry.\r\n * @param {number=func.length} arity - The arity of func.\r\n * @param {unknown} guard - Enables use as an iteratee for methods like `Array#map`.\r\n * @returns {((...args: any[]) => any) & { placeholder: typeof curry.placeholder }} - Returns the new curried function.\r\n *\r\n * @example\r\n * const abc = function(a, b, c) {\r\n *   return Array.from(arguments);\r\n * };\r\n *\r\n * let curried = curry(abc);\r\n *\r\n * curried(1)(2)(3);\r\n * // => [1, 2, 3]\r\n *\r\n * curried(1, 2)(3);\r\n * // => [1, 2, 3]\r\n *\r\n * curried(1, 2, 3);\r\n * // => [1, 2, 3]\r\n *\r\n * // Curried with placeholders.\r\n * curried(1)(curry.placeholder, 3)(2);\r\n * // => [1, 2, 3]\r\n *\r\n * // Curried with arity.\r\n * curried = curry(abc, 2);\r\n *\r\n * curried(1)(2);\r\n * // => [1, 2]\r\n */\r\nexport function curry(\r\n  func: (...args: any[]) => any,\r\n  arity: number = func.length,\r\n  guard?: unknown\r\n): ((...args: any[]) => any) & { placeholder: typeof curry.placeholder } {\r\n  arity = guard ? func.length : arity;\r\n  arity = Number.parseInt(arity as any, 10);\r\n  if (Number.isNaN(arity) || arity < 1) {\r\n    arity = 0;\r\n  }\r\n\r\n  const wrapper = function (this: any, ...partials: any[]) {\r\n    const holders = replaceHolders(partials);\r\n    const length = partials.length - holders.length;\r\n    if (length < arity) {\r\n      return makeCurry(func, holders, arity - length, partials);\r\n    }\r\n    if (this instanceof wrapper) {\r\n      // @ts-expect-error - fn is a constructor\r\n      return new func(...partials);\r\n    }\r\n    return func.apply(this, partials);\r\n  };\r\n\r\n  wrapper.placeholder = curryPlaceholder;\r\n\r\n  return wrapper;\r\n}\r\n\r\nfunction makeCurry(\r\n  func: (...args: any[]) => any,\r\n  holders: any[],\r\n  arity: number,\r\n  partials: any[]\r\n): ((...args: any[]) => any) & { placeholder: typeof curry.placeholder } {\r\n  function wrapper(this: any, ...args: any[]) {\r\n    const holdersCount = args.filter(item => item === curry.placeholder).length;\r\n    const length = args.length - holdersCount;\r\n    args = composeArgs(args, partials, holders);\r\n    if (length < arity) {\r\n      const newHolders = replaceHolders(args);\r\n      return makeCurry(func, newHolders, arity - length, args);\r\n    }\r\n    if (this instanceof wrapper) {\r\n      // @ts-expect-error - fn is a constructor\r\n      return new func(...args);\r\n    }\r\n    return func.apply(this, args);\r\n  }\r\n  wrapper.placeholder = curryPlaceholder;\r\n  return wrapper;\r\n}\r\n\r\nfunction replaceHolders(args: any[]): number[] {\r\n  const result = [];\r\n  for (let i = 0; i < args.length; i++) {\r\n    if (args[i] === curry.placeholder) {\r\n      result.push(i);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction composeArgs(args: any[], partials: any[], holders: number[]): any[] {\r\n  const result = [...partials];\r\n  const argsLength = args.length;\r\n  const holdersLength = holders.length;\r\n  let argsIndex = -1,\r\n    leftIndex = partials.length,\r\n    rangeLength = Math.max(argsLength - holdersLength, 0);\r\n  while (++argsIndex < holdersLength) {\r\n    if (argsIndex < argsLength) {\r\n      result[holders[argsIndex]] = args[argsIndex];\r\n    }\r\n  }\r\n  while (rangeLength--) {\r\n    result[leftIndex++] = args[argsIndex++];\r\n  }\r\n  return result;\r\n}\r\n\r\nconst curryPlaceholder: unique symbol = Symbol('curry.placeholder');\r\ncurry.placeholder = curryPlaceholder;\r\n","import { debounce as debounceToolkit } from '../../function/debounce.ts';\r\n\r\ninterface DebounceOptions {\r\n  /**\r\n   * An optional AbortSignal to cancel the debounced function.\r\n   */\r\n  signal?: AbortSignal;\r\n\r\n  /**\r\n   * If `true`, the function will be invoked on the leading edge of the timeout.\r\n   * @default false\r\n   */\r\n  leading?: boolean;\r\n\r\n  /**\r\n   * If `true`, the function will be invoked on the trailing edge of the timeout.\r\n   * @default true\r\n   */\r\n  trailing?: boolean;\r\n\r\n  /**\r\n   * The maximum time `func` is allowed to be delayed before it's invoked.\r\n   * @default Infinity\r\n   */\r\n  maxWait?: number;\r\n}\r\n\r\n/**\r\n * Creates a debounced function that delays invoking the provided function until after `debounceMs` milliseconds\r\n * have elapsed since the last time the debounced function was invoked. The debounced function also has a `cancel`\r\n * method to cancel any pending execution.\r\n *\r\n * You can set the debounced function to run at the start (`leading`) or end (`trailing`) of the delay period.\r\n * If `leading` is true, the function runs immediately on the first call.\r\n * If `trailing` is true, the function runs after `debounceMs` milliseconds have passed since the last call.\r\n * If both `leading` and `trailing` are true, the function runs at both the start and end, but it must be called at least twice within `debounceMs` milliseconds for this to happen\r\n * (since one debounced function call cannot trigger the function twice).\r\n *\r\n * You can also set a `maxWait` time, which is the maximum time the function is allowed to be delayed before it is called.\r\n *\r\n * @template F - The type of function.\r\n * @param {F} func - The function to debounce.\r\n * @param {number} debounceMs - The number of milliseconds to delay.\r\n * @param {DebounceOptions} options - The options object\r\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the debounced function.\r\n * @param {boolean} options.leading - If `true`, the function will be invoked on the leading edge of the timeout.\r\n * @param {boolean} options.trailing - If `true`, the function will be invoked on the trailing edge of the timeout.\r\n * @param {number} options.maxWait - The maximum time `func` is allowed to be delayed before it's invoked.\r\n * @returns A new debounced function with a `cancel` method.\r\n *\r\n * @example\r\n * const debouncedFunction = debounce(() => {\r\n *   console.log('Function executed');\r\n * }, 1000);\r\n *\r\n * // Will log 'Function executed' after 1 second if not called again in that time\r\n * debouncedFunction();\r\n *\r\n * // Will not log anything as the previous call is canceled\r\n * debouncedFunction.cancel();\r\n *\r\n * // With AbortSignal\r\n * const controller = new AbortController();\r\n * const signal = controller.signal;\r\n * const debouncedWithSignal = debounce(() => {\r\n *  console.log('Function executed');\r\n * }, 1000, { signal });\r\n *\r\n * debouncedWithSignal();\r\n *\r\n * // Will cancel the debounced function call\r\n * controller.abort();\r\n */\r\nexport function debounce<F extends (...args: any[]) => any>(\r\n  func: F,\r\n  debounceMs: number = 0,\r\n  options: DebounceOptions = {}\r\n): ((...args: Parameters<F>) => ReturnType<F> | undefined) & {\r\n  cancel: () => void;\r\n  flush: () => void;\r\n} {\r\n  if (typeof options !== 'object') {\r\n    options = {};\r\n  }\r\n\r\n  const { signal, leading = false, trailing = true, maxWait } = options;\r\n\r\n  const edges = Array(2);\r\n\r\n  if (leading) {\r\n    edges[0] = 'leading';\r\n  }\r\n\r\n  if (trailing) {\r\n    edges[1] = 'trailing';\r\n  }\r\n\r\n  let result: ReturnType<F> | undefined = undefined;\r\n  let pendingAt: number | null = null;\r\n\r\n  const _debounced = debounceToolkit(\r\n    function (this: any, ...args: Parameters<F>) {\r\n      result = func.apply(this, args);\r\n      pendingAt = null;\r\n    },\r\n    debounceMs,\r\n    { signal, edges }\r\n  );\r\n\r\n  const debounced = function (this: any, ...args: Parameters<F>) {\r\n    if (maxWait != null) {\r\n      if (pendingAt === null) {\r\n        pendingAt = Date.now();\r\n      } else {\r\n        if (Date.now() - pendingAt >= maxWait) {\r\n          result = func.apply(this, args);\r\n          pendingAt = Date.now();\r\n\r\n          _debounced.cancel();\r\n          _debounced.schedule();\r\n\r\n          return result;\r\n        }\r\n      }\r\n    }\r\n\r\n    _debounced.apply(this, args);\r\n    return result;\r\n  };\r\n\r\n  const flush = () => {\r\n    _debounced.flush();\r\n    return result;\r\n  };\r\n\r\n  debounced.cancel = _debounced.cancel;\r\n  debounced.flush = flush;\r\n\r\n  return debounced;\r\n}\r\n","/**\r\n * Checks if a given value is null or undefined.\r\n *\r\n * This function tests whether the provided value is either `null` or `undefined`.\r\n * It returns `true` if the value is `null` or `undefined`, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null` or `undefined`.\r\n *\r\n * @param {unknown} x - The value to test for null or undefined.\r\n * @returns {boolean} `true` if the value is null or undefined, `false` otherwise.\r\n *\r\n * @example\r\n * const value1 = null;\r\n * const value2 = undefined;\r\n * const value3 = 42;\r\n * const result1 = isNil(value1); // true\r\n * const result2 = isNil(value2); // true\r\n * const result3 = isNil(value3); // false\r\n */\r\nexport function isNil(x?: unknown): x is null | undefined {\r\n  return x == null;\r\n}\r\n","import { isDeepKey } from '../_internal/isDeepKey.ts';\r\nimport { toKey } from '../_internal/toKey.ts';\r\nimport { toPath } from '../util/toPath.ts';\r\nimport { get } from './get.ts';\r\n\r\n/**\r\n * Removes the property at the given path of the object.\r\n *\r\n * @param {unknown} obj - The object to modify.\r\n * @param {PropertyKey | readonly PropertyKey[]} path - The path of the property to unset.\r\n * @returns {boolean} - Returns true if the property is deleted, else false.\r\n *\r\n * @example\r\n * const obj = { a: { b: { c: 42 } } };\r\n * unset(obj, 'a.b.c'); // true\r\n * console.log(obj); // { a: { b: {} } }\r\n *\r\n * @example\r\n * const obj = { a: { b: { c: 42 } } };\r\n * unset(obj, ['a', 'b', 'c']); // true\r\n * console.log(obj); // { a: { b: {} } }\r\n */\r\nexport function unset(obj: any, path: PropertyKey | readonly PropertyKey[]): boolean {\r\n  if (obj == null) {\r\n    return true;\r\n  }\r\n\r\n  switch (typeof path) {\r\n    case 'symbol':\r\n    case 'number':\r\n    case 'object': {\r\n      if (Array.isArray(path)) {\r\n        return unsetWithPath(obj, path);\r\n      }\r\n\r\n      if (typeof path === 'number') {\r\n        path = toKey(path);\r\n      } else if (typeof path === 'object') {\r\n        if (Object.is(path?.valueOf(), -0)) {\r\n          path = '-0';\r\n        } else {\r\n          path = String(path);\r\n        }\r\n      }\r\n\r\n      if (obj?.[path] === undefined) {\r\n        return true;\r\n      }\r\n\r\n      try {\r\n        delete obj[path];\r\n        return true;\r\n      } catch {\r\n        return false;\r\n      }\r\n    }\r\n    case 'string': {\r\n      if (obj?.[path] === undefined && isDeepKey(path)) {\r\n        return unsetWithPath(obj, toPath(path));\r\n      }\r\n\r\n      try {\r\n        delete obj[path];\r\n        return true;\r\n      } catch {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction unsetWithPath(obj: unknown, path: readonly PropertyKey[]): boolean {\r\n  const parent = get(obj, path.slice(0, -1), obj);\r\n  const lastKey = path[path.length - 1];\r\n\r\n  if (parent?.[lastKey] === undefined) {\r\n    return true;\r\n  }\r\n\r\n  try {\r\n    delete parent[lastKey];\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n","/**\r\n * Checks if a given value is a plain object.\r\n *\r\n * A plain object is an object created by the `{}` literal, `new Object()`, or\r\n * `Object.create(null)`.\r\n *\r\n * This function also handles objects with custom\r\n * `Symbol.toStringTag` properties.\r\n *\r\n * `Symbol.toStringTag` is a built-in symbol that a constructor can use to customize the\r\n * default string description of objects.\r\n *\r\n * @param {unknown} [object] - The value to check.\r\n * @returns {boolean} - True if the value is a plain object, otherwise false.\r\n *\r\n * @example\r\n * console.log(isPlainObject({})); // true\r\n * console.log(isPlainObject([])); // false\r\n * console.log(isPlainObject(null)); // false\r\n * console.log(isPlainObject(Object.create(null))); // true\r\n * console.log(isPlainObject(new Map())); // false\r\n */\r\nexport function isPlainObject(object?: unknown): boolean {\r\n  if (typeof object !== 'object') {\r\n    return false;\r\n  }\r\n\r\n  if (object == null) {\r\n    return false;\r\n  }\r\n\r\n  if (Object.getPrototypeOf(object) === null) {\r\n    return true;\r\n  }\r\n\r\n  if (Object.prototype.toString.call(object) !== '[object Object]') {\r\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n    // @ts-ignore\r\n    const tag = object[Symbol.toStringTag];\r\n\r\n    if (tag == null) {\r\n      return false;\r\n    }\r\n\r\n    const isTagReadonly = !Object.getOwnPropertyDescriptor(object, Symbol.toStringTag)?.writable;\r\n\r\n    if (isTagReadonly) {\r\n      return false;\r\n    }\r\n\r\n    return object.toString() === `[object ${tag}]`;\r\n  }\r\n\r\n  let proto = object;\r\n\r\n  while (Object.getPrototypeOf(proto) !== null) {\r\n    proto = Object.getPrototypeOf(proto);\r\n  }\r\n\r\n  return Object.getPrototypeOf(object) === proto;\r\n}\r\n","import { isTypedArray as isTypedArrayToolkit } from '../../predicate/isTypedArray.ts';\r\n\r\n/**\r\n * Checks if a value is a TypedArray.\r\n * @param {unknown} x The value to check.\r\n * @returns {x is\r\n *     Uint8Array\r\n *   | Uint8ClampedArray\r\n *   | Uint16Array\r\n *   | Uint32Array\r\n *   | BigUint64Array\r\n *   | Int8Array\r\n *   | Int16Array\r\n *   | Int32Array\r\n *   | BigInt64Array\r\n *   | Float32Array\r\n *   | Float64Array} Returns true if `x` is a TypedArray, false otherwise.\r\n *\r\n * @example\r\n * const arr = new Uint8Array([1, 2, 3]);\r\n * isTypedArray(arr); // true\r\n *\r\n * const regularArray = [1, 2, 3];\r\n * isTypedArray(regularArray); // false\r\n *\r\n * const buffer = new ArrayBuffer(16);\r\n * isTypedArray(buffer); // false\r\n */\r\nexport function isTypedArray(\r\n  x?: unknown\r\n): x is\r\n  | Uint8Array\r\n  | Uint8ClampedArray\r\n  | Uint16Array\r\n  | Uint32Array\r\n  | BigUint64Array\r\n  | Int8Array\r\n  | Int16Array\r\n  | Int32Array\r\n  | BigInt64Array\r\n  | Float32Array\r\n  | Float64Array {\r\n  return isTypedArrayToolkit(x);\r\n}\r\n","import { clone } from '../../object/clone.ts';\r\nimport { getSymbols } from '../_internal/getSymbols.ts';\r\nimport { isArguments } from '../predicate/isArguments.ts';\r\nimport { isObjectLike } from '../predicate/isObjectLike.ts';\r\nimport { isPlainObject } from '../predicate/isPlainObject.ts';\r\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\r\nimport { cloneDeep } from './cloneDeep.ts';\r\n\r\ndeclare let Buffer:\r\n  | {\r\n      isBuffer: (a: any) => boolean;\r\n    }\r\n  | undefined;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\r\n *\r\n * - `targetValue`: The current value of the property in the target object.\r\n * - `sourceValue`: The value of the property in the source object.\r\n * - `key`: The key of the property being merged.\r\n * - `target`: The target object.\r\n * - `source`: The source object.\r\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\r\n *\r\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {T} target - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S} source - The first source object whose properties will be merged into the target object.\r\n * @param {(targetValue: any, sourceValue: any, key: string, target: T, source: S, stack: Map<any, any>) => any} merge - The function to customize merging properties.\r\n * @returns {T & S} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @template T - Type of the target object.\r\n * @template S - Type of the first source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: 2 };\r\n * const source = { b: 3, c: 4 };\r\n *\r\n * mergeWith(target, source, (targetValue, sourceValue) => {\r\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\r\n *     return targetValue + sourceValue;\r\n *   }\r\n * });\r\n * // Returns { a: 1, b: 5, c: 4 }\r\n * @example\r\n * const target = { a: [1], b: [2] };\r\n * const source = { a: [3], b: [4] };\r\n *\r\n * const result = mergeWith(target, source, (objValue, srcValue) => {\r\n *   if (Array.isArray(objValue)) {\r\n *     return objValue.concat(srcValue);\r\n *   }\r\n * });\r\n *\r\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\r\n */\r\nexport function mergeWith<T, S>(\r\n  target: T,\r\n  source: S,\r\n  merge: (targetValue: any, sourceValue: any, key: string, target: T, source: S, stack: Map<any, any>) => any\r\n): T & S;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\r\n *\r\n * - `targetValue`: The current value of the property in the target object.\r\n * - `sourceValue`: The value of the property in the source object.\r\n * - `key`: The key of the property being merged.\r\n * - `target`: The target object.\r\n * - `source`: The source object.\r\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\r\n *\r\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S1} source1 - The first source object to be merged into the target object.\r\n * @param {S2} source2 - The second source object to be merged into the target object.\r\n * @param {(targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any} merge - The function to customize merging properties.\r\n * @returns {O & S1 & S2} The updated target object with properties from the source objects merged in.\r\n *\r\n * @template O - Type of the target object.\r\n * @template S1 - Type of the first source object.\r\n * @template S2 - Type of the second source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: 2 };\r\n * const source = { b: 3, c: 4 };\r\n *\r\n * mergeWith(target, source, (targetValue, sourceValue) => {\r\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\r\n *     return targetValue + sourceValue;\r\n *   }\r\n * });\r\n * // Returns { a: 1, b: 5, c: 4 }\r\n * @example\r\n * const target = { a: [1], b: [2] };\r\n * const source = { a: [3], b: [4] };\r\n *\r\n * const result = mergeWith(target, source, (objValue, srcValue) => {\r\n *   if (Array.isArray(objValue)) {\r\n *     return objValue.concat(srcValue);\r\n *   }\r\n * });\r\n *\r\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\r\n */\r\nexport function mergeWith<O, S1, S2>(\r\n  object: O,\r\n  source1: S1,\r\n  source2: S2,\r\n  merge: (targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any\r\n): O & S1 & S2;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\r\n *\r\n * - `targetValue`: The current value of the property in the target object.\r\n * - `sourceValue`: The value of the property in the source object.\r\n * - `key`: The key of the property being merged.\r\n * - `target`: The target object.\r\n * - `source`: The source object.\r\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\r\n *\r\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S1} source1 - The first source object whose properties will be merged into the target object.\r\n * @param {S2} source2 - The second source object whose properties will be merged into the target object.\r\n * @param {S3} source3 - The third source object whose properties will be merged into the target object.\r\n * @param {(targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any} merge - The function to customize merging properties.\r\n * @returns {O & S1 & S2 & S3} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @template O - Type of the target object.\r\n * @template S1 - Type of the first source object.\r\n * @template S2 - Type of the second source object.\r\n * @template S3 - Type of the third source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: 2 };\r\n * const source = { b: 3, c: 4 };\r\n *\r\n * mergeWith(target, source, (targetValue, sourceValue) => {\r\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\r\n *     return targetValue + sourceValue;\r\n *   }\r\n * });\r\n * // Returns { a: 1, b: 5, c: 4 }\r\n * @example\r\n * const target = { a: [1], b: [2] };\r\n * const source = { a: [3], b: [4] };\r\n *\r\n * const result = mergeWith(target, source, (objValue, srcValue) => {\r\n *   if (Array.isArray(objValue)) {\r\n *     return objValue.concat(srcValue);\r\n *   }\r\n * });\r\n *\r\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\r\n */\r\nexport function mergeWith<O, S1, S2, S3>(\r\n  object: O,\r\n  source1: S1,\r\n  source2: S2,\r\n  source3: S3,\r\n  merge: (targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any\r\n): O & S1 & S2 & S3;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\r\n *\r\n * - `targetValue`: The current value of the property in the target object.\r\n * - `sourceValue`: The value of the property in the source object.\r\n * - `key`: The key of the property being merged.\r\n * - `target`: The target object.\r\n * - `source`: The source object.\r\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\r\n *\r\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S1} source1 - The first source object whose properties will be merged into the target object.\r\n * @param {S2} source2 - The second source object whose properties will be merged into the target object.\r\n * @param {S3} source3 - The third source object whose properties will be merged into the target object.\r\n * @param {S4} source4 - The fourth source object whose properties will be merged into the target object.\r\n * @param {(targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any} merge - The function to customize merging properties.\r\n * @returns {O & S1 & S2 & S3 & S4} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @template O - Type of the target object.\r\n * @template S1 - Type of the first source object.\r\n * @template S2 - Type of the second source object.\r\n * @template S3 - Type of the third source object.\r\n * @template S4 - Type of the fourth source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: 2 };\r\n * const source = { b: 3, c: 4 };\r\n *\r\n * mergeWith(target, source, (targetValue, sourceValue) => {\r\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\r\n *     return targetValue + sourceValue;\r\n *   }\r\n * });\r\n * // Returns { a: 1, b: 5, c: 4 }\r\n * @example\r\n * const target = { a: [1], b: [2] };\r\n * const source = { a: [3], b: [4] };\r\n *\r\n * const result = mergeWith(target, source, (objValue, srcValue) => {\r\n *   if (Array.isArray(objValue)) {\r\n *     return objValue.concat(srcValue);\r\n *   }\r\n * });\r\n *\r\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\r\n */\r\nexport function mergeWith<O, S1, S2, S3, S4>(\r\n  object: O,\r\n  source1: S1,\r\n  source2: S2,\r\n  source3: S3,\r\n  source4: S4,\r\n  merge: (targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any\r\n): O & S1 & S2 & S3;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\r\n *\r\n * - `targetValue`: The current value of the property in the target object.\r\n * - `sourceValue`: The value of the property in the source object.\r\n * - `key`: The key of the property being merged.\r\n * - `target`: The target object.\r\n * - `source`: The source object.\r\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\r\n *\r\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {any} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {any[]} sources - The source objects whose properties will be merged into the target object.\r\n * @param {...any} otherArgs - Additional source objects to merge into the target object, including the custom `merge` function.\r\n * @returns {any} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @example\r\n * const target = { a: 1, b: 2 };\r\n * const source = { b: 3, c: 4 };\r\n *\r\n * mergeWith(target, source, (targetValue, sourceValue) => {\r\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\r\n *     return targetValue + sourceValue;\r\n *   }\r\n * });\r\n * // Returns { a: 1, b: 5, c: 4 }\r\n * @example\r\n * const target = { a: [1], b: [2] };\r\n * const source = { a: [3], b: [4] };\r\n *\r\n * const result = mergeWith(target, source, (objValue, srcValue) => {\r\n *   if (Array.isArray(objValue)) {\r\n *     return objValue.concat(srcValue);\r\n *   }\r\n * });\r\n *\r\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\r\n */\r\nexport function mergeWith(object: any, ...otherArgs: any[]): any;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\r\n *\r\n * - `targetValue`: The current value of the property in the target object.\r\n * - `sourceValue`: The value of the property in the source object.\r\n * - `key`: The key of the property being merged.\r\n * - `target`: The target object.\r\n * - `source`: The source object.\r\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\r\n *\r\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {any} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {any[]} sources - The source objects whose properties will be merged into the target object.\r\n * @param {...any} otherArgs - Additional source objects to merge into the target object, including the custom `merge` function.\r\n * @returns {any} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @example\r\n * const target = { a: 1, b: 2 };\r\n * const source = { b: 3, c: 4 };\r\n *\r\n * mergeWith(target, source, (targetValue, sourceValue) => {\r\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\r\n *     return targetValue + sourceValue;\r\n *   }\r\n * });\r\n * // Returns { a: 1, b: 5, c: 4 }\r\n * @example\r\n * const target = { a: [1], b: [2] };\r\n * const source = { a: [3], b: [4] };\r\n *\r\n * const result = mergeWith(target, source, (objValue, srcValue) => {\r\n *   if (Array.isArray(objValue)) {\r\n *     return objValue.concat(srcValue);\r\n *   }\r\n * });\r\n *\r\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\r\n */\r\nexport function mergeWith(object: any, ...otherArgs: any[]): any {\r\n  const sources = otherArgs.slice(0, -1);\r\n  const merge = otherArgs[otherArgs.length - 1] as (\r\n    targetValue: any,\r\n    sourceValue: any,\r\n    key: string | symbol,\r\n    target: any,\r\n    source: any,\r\n    stack: Map<any, any>\r\n  ) => any;\r\n\r\n  let result = object;\r\n\r\n  for (let i = 0; i < sources.length; i++) {\r\n    const source = sources[i];\r\n\r\n    result = mergeWithDeep(object, source, merge, new Map());\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction mergeWithDeep(\r\n  target: any,\r\n  source: any,\r\n  merge: (\r\n    targetValue: any,\r\n    sourceValue: any,\r\n    key: string | symbol,\r\n    target: any,\r\n    source: any,\r\n    stack: Map<any, any>\r\n  ) => any,\r\n  stack: Map<any, any>\r\n) {\r\n  if (source == null || typeof source !== 'object') {\r\n    return target;\r\n  }\r\n\r\n  if (stack.has(source)) {\r\n    return clone(stack.get(source));\r\n  }\r\n\r\n  stack.set(source, target);\r\n\r\n  if (Array.isArray(source)) {\r\n    source = source.slice();\r\n    for (let i = 0; i < source.length; i++) {\r\n      source[i] = source[i] ?? undefined;\r\n    }\r\n  }\r\n\r\n  const sourceKeys = [...Object.keys(source), ...getSymbols(source)];\r\n\r\n  for (let i = 0; i < sourceKeys.length; i++) {\r\n    const key = sourceKeys[i];\r\n\r\n    let sourceValue = source[key];\r\n    let targetValue = target[key];\r\n\r\n    if (isArguments(sourceValue)) {\r\n      sourceValue = { ...sourceValue };\r\n    }\r\n\r\n    if (isArguments(targetValue)) {\r\n      targetValue = { ...targetValue };\r\n    }\r\n\r\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(sourceValue)) {\r\n      sourceValue = cloneDeep(sourceValue);\r\n    }\r\n\r\n    if (Array.isArray(sourceValue)) {\r\n      if (typeof targetValue === 'object') {\r\n        const cloned: any = [];\r\n        const targetKeys = Reflect.ownKeys(targetValue);\r\n\r\n        for (let i = 0; i < targetKeys.length; i++) {\r\n          const targetKey = targetKeys[i];\r\n          cloned[targetKey] = targetValue[targetKey];\r\n        }\r\n\r\n        targetValue = cloned;\r\n      } else {\r\n        targetValue = [];\r\n      }\r\n    }\r\n\r\n    const merged = merge(targetValue, sourceValue, key, target, source, stack);\r\n\r\n    if (merged != null) {\r\n      target[key] = merged;\r\n    } else if (Array.isArray(sourceValue)) {\r\n      target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\r\n    } else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {\r\n      target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\r\n    } else if (targetValue == null && isPlainObject(sourceValue)) {\r\n      target[key] = mergeWithDeep({}, sourceValue, merge, stack);\r\n    } else if (targetValue == null && isTypedArray(sourceValue)) {\r\n      target[key] = cloneDeep(sourceValue);\r\n    } else if (targetValue === undefined || sourceValue !== undefined) {\r\n      target[key] = sourceValue;\r\n    }\r\n  }\r\n\r\n  return target;\r\n}\r\n","import { isLength } from '../../predicate/isLength.ts';\r\n\r\n/**\r\n * Checks if `value` is array-like.\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {value is ArrayLike<unknown>} Returns `true` if `value` is array-like, else `false`.\r\n *\r\n * @example\r\n * isArrayLike([1, 2, 3]); // true\r\n * isArrayLike('abc'); // true\r\n * isArrayLike({ 0: 'a', length: 1 }); // true\r\n * isArrayLike({}); // false\r\n * isArrayLike(null); // false\r\n * isArrayLike(undefined); // false\r\n */\r\nexport function isArrayLike(value: unknown): value is ArrayLike<unknown> {\r\n  return value != null && typeof value !== 'function' && isLength((value as ArrayLike<unknown>).length);\r\n}\r\n","/**\r\n * Checks if `object` conforms to `source` by invoking the predicate properties of `source` with the corresponding property values of `object`.\r\n *\r\n * Note: This method is equivalent to `conforms` when source is partially applied.\r\n *\r\n * @param {Record<PropertyKey, any>} target The object to inspect.\r\n * @param {Record<PropertyKey, (value: any) => boolean>} source The object of property predicates to conform to.\r\n * @returns {boolean} Returns `true` if `object` conforms, else `false`.\r\n *\r\n * @example\r\n *\r\n * const object = { 'a': 1, 'b': 2 };\r\n * const source = {\r\n *   'a': (n) => n > 0,\r\n *   'b': (n) => n > 1\r\n * };\r\n *\r\n * console.log(conformsTo(object, source)); // => true\r\n *\r\n * const source2 = {\r\n *   'a': (n) => n > 1,\r\n *   'b': (n) => n > 1\r\n * };\r\n *\r\n * console.log(conformsTo(object, source2)); // => false\r\n */\r\nexport function conformsTo(\r\n  target: Record<PropertyKey, any>,\r\n  source: Record<PropertyKey, (value: any) => boolean>\r\n): boolean {\r\n  if (source == null) {\r\n    return true;\r\n  }\r\n\r\n  if (target == null) {\r\n    return Object.keys(source).length === 0;\r\n  }\r\n\r\n  for (const key of Object.keys(source)) {\r\n    const predicate = source[key];\r\n    const value = target[key];\r\n    if ((value === undefined && !(key in target)) || !predicate(value)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n","/**\r\n * Converts `value` to a string.\r\n *\r\n * An empty string is returned for `null` and `undefined` values.\r\n * The sign of `-0` is preserved.\r\n *\r\n * @param {unknown} value - The value to convert.\r\n * @returns {string} Returns the converted string.\r\n *\r\n * @example\r\n * toString(null) // returns ''\r\n * toString(undefined) // returns ''\r\n * toString(-0) // returns '-0'\r\n * toString([1, 2, -0]) // returns '1,2,-0'\r\n * toString([Symbol('a'), Symbol('b')]) // returns 'Symbol(a),Symbol(b)'\r\n */\r\nexport function toString(value?: unknown): string {\r\n  if (value == null) {\r\n    return '';\r\n  }\r\n\r\n  if (Array.isArray(value)) {\r\n    return value.map(toString).join(',');\r\n  }\r\n\r\n  const result = String(value);\r\n\r\n  if (result === '0' && Object.is(Number(value), -0)) {\r\n    return '-0';\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { toString } from '../util/toString.ts';\r\n\r\nexport function normalizeForCase(str: unknown): string {\r\n  // Coerce to string\r\n  if (typeof str !== 'string') {\r\n    str = toString(str);\r\n  }\r\n\r\n  // Remove constraction apostrophes\r\n  return (str as string).replace(/['\\u2019]/g, '');\r\n}\r\n","import { clamp as clampToolkit } from '../../math/clamp.ts';\r\n\r\n/**\r\n * Clamps a number within the inclusive upper bound.\r\n *\r\n * This function takes a number and a maximum bound, and returns the number clamped within the specified upper bound.\r\n * If only one bound is provided, it returns the minimum of the value and the bound.\r\n *\r\n * @param {number} value - The number to clamp.\r\n * @param {number} maximum - The maximum bound to clamp the number.\r\n * @returns {number} The clamped number within the specified upper bound.\r\n *\r\n * @example\r\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\r\n */\r\nexport function clamp(value: number, maximum: number): number;\r\n\r\n/**\r\n * Clamps a number within the inclusive lower and upper bounds.\r\n *\r\n * This function takes a number and two bounds, and returns the number clamped within the specified bounds.\r\n *\r\n * @param {number} value - The number to clamp.\r\n * @param {number} minimum - The minimum bound to clamp the number.\r\n * @param {number} maximum - The maximum bound to clamp the number.\r\n * @returns {number} The clamped number within the specified bounds.\r\n *\r\n * @example\r\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\r\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\r\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\r\n */\r\nexport function clamp(value: number, minimum: number, maximum: number): number;\r\n\r\n/**\r\n * Clamps a number within the specified bounds.\r\n *\r\n * This function takes a number and one or two bounds, and returns the number clamped within the specified bounds.\r\n * If only one bound is provided, it returns the minimum of the value and the bound.\r\n *\r\n * @param {number} value - The number to clamp.\r\n * @param {number} bound1 - The minimum bound to clamp the number, or the maximum bound if bound2 is not provided.\r\n * @param {number} [bound2] - The maximum bound to clamp the number. If not provided, the function will only consider bound1 as the upper limit.\r\n * @returns {number} The clamped number within the specified bounds.\r\n *\r\n * @example\r\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\r\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\r\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\r\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\r\n */\r\nexport function clamp(value: number, bound1: number, bound2?: number): number {\r\n  if (Number.isNaN(bound1)) {\r\n    bound1 = 0;\r\n  }\r\n\r\n  if (Number.isNaN(bound2)) {\r\n    bound2 = 0;\r\n  }\r\n\r\n  return clampToolkit(value, bound1, bound2!);\r\n}\r\n","/**\r\n * Clamps a number within the inclusive upper bound.\r\n *\r\n * This function takes a number and a maximum bound, and returns the number clamped within the specified upper bound.\r\n * If only one bound is provided, it returns the minimum of the value and the bound.\r\n *\r\n * @param {number} value - The number to clamp.\r\n * @param {number} maximum - The maximum bound to clamp the number.\r\n * @returns {number} The clamped number within the specified upper bound.\r\n *\r\n * @example\r\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\r\n */\r\nexport function clamp(value: number, maximum: number): number;\r\n\r\n/**\r\n * Clamps a number within the inclusive lower and upper bounds.\r\n *\r\n * This function takes a number and two bounds, and returns the number clamped within the specified bounds.\r\n *\r\n * @param {number} value - The number to clamp.\r\n * @param {number} minimum - The minimum bound to clamp the number.\r\n * @param {number} maximum - The maximum bound to clamp the number.\r\n * @returns {number} The clamped number within the specified bounds.\r\n *\r\n * @example\r\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\r\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\r\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\r\n */\r\nexport function clamp(value: number, minimum: number, maximum: number): number;\r\n\r\n/**\r\n * Clamps a number within the specified bounds.\r\n *\r\n * This function takes a number and one or two bounds, and returns the number clamped within the specified bounds.\r\n * If only one bound is provided, it returns the minimum of the value and the bound.\r\n *\r\n * @param {number} value - The number to clamp.\r\n * @param {number} bound1 - The minimum bound to clamp the number, or the maximum bound if bound2 is not provided.\r\n * @param {number} [bound2] - The maximum bound to clamp the number. If not provided, the function will only consider bound1 as the upper limit.\r\n * @returns {number} The clamped number within the specified bounds.\r\n *\r\n * @example\r\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\r\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\r\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\r\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\r\n */\r\nexport function clamp(value: number, bound1: number, bound2?: number): number {\r\n  if (bound2 == null) {\r\n    return Math.min(value, bound1);\r\n  }\r\n\r\n  return Math.min(Math.max(value, bound1), bound2);\r\n}\r\n","export function decimalAdjust(\r\n  type: 'round' | 'floor' | 'ceil',\r\n  number: number | string,\r\n  precision: number | string = 0\r\n): number {\r\n  number = Number(number);\r\n  if (Object.is(number, -0)) {\r\n    number = '-0';\r\n  }\r\n  precision = Math.min(Number.parseInt(precision as string, 10), 292);\r\n  if (precision) {\r\n    const [magnitude, exponent = 0] = number.toString().split('e');\r\n    let adjustedValue: string | number = Math[type](Number(`${magnitude}e${Number(exponent) + precision}`));\r\n    if (Object.is(adjustedValue, -0)) {\r\n      adjustedValue = '-0';\r\n    }\r\n    const [newMagnitude, newExponent = 0] = adjustedValue.toString().split('e');\r\n    return Number(`${newMagnitude}e${Number(newExponent) - precision}`);\r\n  }\r\n  return Math[type](Number(number));\r\n}\r\n","/**\r\n * Creates a function that only executes starting from the `n`-th call.\r\n * The provided function will be invoked starting from the `n`-th call.\r\n *\r\n * This is particularly useful for scenarios involving events or asynchronous operations\r\n * where an action should occur only after a certain number of invocations.\r\n *\r\n * @template F - The type of the function to be invoked.\r\n * @param {number} n - The number of calls required for `func` to execute.\r\n * @param {F} func - The function to be invoked.\r\n * @returns {F} - A new function that:\r\n * - Tracks the number of calls.\r\n * - Invokes `func` starting from the `n`-th call.\r\n * - Returns `undefined` if fewer than `n` calls have been made.\r\n * @throws {Error} - Throws an error if `n` is negative.\r\n * @example\r\n *\r\n * const afterFn = after(3, () => {\r\n *  console.log(\"called\")\r\n * });\r\n *\r\n * // Will not log anything.\r\n * afterFn()\r\n * // Will not log anything.\r\n * afterFn()\r\n * // Will log 'called'.\r\n * afterFn()\r\n */\r\n\r\nexport function after<F extends (...args: any[]) => any>(n: number, func: F): F {\r\n  if (!Number.isInteger(n) || n < 0) {\r\n    throw new Error(`n must be a non-negative integer.`);\r\n  }\r\n\r\n  let counter = 0;\r\n  return ((...args: Parameters<F>) => {\r\n    if (++counter >= n) {\r\n      return func(...args);\r\n    }\r\n    return undefined;\r\n  }) as F;\r\n}\r\n","import { ary as aryToolkit } from '../../function/ary.ts';\r\n\r\n/**\r\n * Creates a function that invokes func, with up to `n` arguments, ignoring any additional arguments.\r\n *\r\n * @template F - The type of the function.\r\n * @param {F} func - The function to cap arguments for.\r\n * @param {number} n - The arity cap.\r\n * @param {unknown} guard - The value to guard the arity cap.\r\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new capped function.\r\n *\r\n * @example\r\n * function fn(a: number, b: number, c: number) {\r\n *   return Array.from(arguments);\r\n * }\r\n *\r\n * ary(fn, 0)(1, 2, 3); // []\r\n * ary(fn, 1)(1, 2, 3); // [1]\r\n * ary(fn, 2)(1, 2, 3); // [1, 2]\r\n * ary(fn, 3)(1, 2, 3); // [1, 2, 3]\r\n */\r\nexport function ary<F extends (...args: any[]) => any>(\r\n  func: F,\r\n  n: number = func.length,\r\n  guard?: unknown\r\n): (...args: any[]) => ReturnType<F> {\r\n  if (guard) {\r\n    n = func.length;\r\n  }\r\n\r\n  if (Number.isNaN(n) || n < 0) {\r\n    n = 0;\r\n  }\r\n\r\n  return aryToolkit(func, n);\r\n}\r\n","/**\r\n * Attempts to execute a function with the provided arguments.\r\n * If the function throws an error, it catches the error and returns it.\r\n * If the caught error is not an instance of Error, it wraps it in a new Error.\r\n *\r\n * @param {F} func - The function to be executed.\r\n * @param {...Parameters<F>} args - The arguments to pass to the function.\r\n * @returns {ReturnType<F> | Error} The return value of the function if successful, or an Error if an exception is thrown.\r\n *\r\n * @template F - The type of the function being attempted.\r\n *\r\n * @example\r\n * // Example 1: Successful execution\r\n * const result = attempt((x, y) => x + y, 2, 3);\r\n * console.log(result); // Output: 5\r\n *\r\n * @example\r\n * // Example 2: Function throws an error\r\n * const errorResult = attempt(() => {\r\n *   throw new Error(\"Something went wrong\");\r\n * });\r\n * console.log(errorResult); // Output: Error: Something went wrong\r\n *\r\n * @example\r\n * // Example 3: Non-Error thrown\r\n * const nonErrorResult = attempt(() => {\r\n *   throw \"This is a string error\";\r\n * });\r\n * console.log(nonErrorResult); // Output: Error: This is a string error\r\n */\r\nexport function attempt<F extends (...args: any[]) => any>(func: F, ...args: Parameters<F>): ReturnType<F> | Error {\r\n  try {\r\n    return func(...args);\r\n  } catch (e: any) {\r\n    return e instanceof Error ? e : new Error(e);\r\n  }\r\n}\r\n","/**\r\n * Creates a function that limits the number of times the given function (`func`) can be called.\r\n *\r\n * @template F - The type of the function to be invoked.\r\n * @param {number} n - The number of times the returned function is allowed to call `func` before stopping.\r\n * - If `n` is 0, `func` will never be called.\r\n * - If `n` is a positive integer, `func` will be called up to `n-1` times.\r\n * @param {F} func - The function to be called with the limit applied.\r\n * @returns {F} - A new function that:\r\n * - Tracks the number of calls.\r\n * - Invokes `func` until the `n-1`-th call.\r\n * - Returns `undefined` if the number of calls reaches or exceeds `n`, stopping further calls.\r\n * @throws {Error} - Throw an error if `n` is negative.\r\n * @example\r\n *\r\n * const beforeFn = before(3, () => {\r\n *  console.log(\"called\");\r\n * })\r\n *\r\n * // Will log 'called'.\r\n * beforeFn();\r\n *\r\n * // Will log 'called'.\r\n * beforeFn();\r\n *\r\n * // Will not log anything.\r\n * beforeFn();\r\n */\r\n\r\nexport function before<F extends (...args: any[]) => any>(n: number, func: F): F {\r\n  if (!Number.isInteger(n) || n < 0) {\r\n    throw new Error('n must be a non-negative integer.');\r\n  }\r\n\r\n  let counter = 0;\r\n  return ((...args: Parameters<F>) => {\r\n    if (++counter < n) {\r\n      return func(...args);\r\n    }\r\n    return undefined;\r\n  }) as F;\r\n}\r\n","import { camelCase as camelCaseToolkit } from '../../string/camelCase.ts';\r\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\r\n\r\n/**\r\n * Converts a string to camel case.\r\n *\r\n * Camel case is the naming convention in which the first word is written in lowercase and\r\n * each subsequent word begins with a capital letter, concatenated without any separator characters.\r\n *\r\n * @param {string | object} str - The string that is to be changed to camel case.\r\n * @returns {string} - The converted string to camel case.\r\n *\r\n * @example\r\n * const convertedStr1 = camelCase('camelCase') // returns 'camelCase'\r\n * const convertedStr2 = camelCase('some whitespace') // returns 'someWhitespace'\r\n * const convertedStr3 = camelCase('hyphen-text') // returns 'hyphenText'\r\n * const convertedStr4 = camelCase('HTTPRequest') // returns 'httpRequest'\r\n */\r\n\r\nexport function camelCase(str?: string | object): string {\r\n  return camelCaseToolkit(normalizeForCase(str));\r\n}\r\n","import { capitalize } from './capitalize.ts';\r\nimport { getWords } from './_internal/getWords.ts';\r\n\r\n/**\r\n * Converts a string to camel case.\r\n *\r\n * Camel case is the naming convention in which the first word is written in lowercase and\r\n * each subsequent word begins with a capital letter, concatenated without any separator characters.\r\n *\r\n * @param {string} str - The string that is to be changed to camel case.\r\n * @returns {string} - The converted string to camel case.\r\n *\r\n * @example\r\n * const convertedStr1 = camelCase('camelCase') // returns 'camelCase'\r\n * const convertedStr2 = camelCase('some whitespace') // returns 'someWhitespace'\r\n * const convertedStr3 = camelCase('hyphen-text') // returns 'hyphenText'\r\n * const convertedStr4 = camelCase('HTTPRequest') // returns 'httpRequest'\r\n */\r\n\r\nexport function camelCase(str: string): string {\r\n  const words = getWords(str);\r\n\r\n  if (words.length === 0) {\r\n    return '';\r\n  }\r\n\r\n  const [first, ...rest] = words;\r\n\r\n  return `${first.toLowerCase()}${rest.map(word => capitalize(word)).join('')}`;\r\n}\r\n","/**\r\n * Casts value as an array if it's not one.\r\n *\r\n * @template T The type of elements in the array.\r\n * @param {T | readonly T[]} value The value to be cast to an array.\r\n * @returns {T[]} An array containing the input value if it wasn't an array, or the original array if it was.\r\n *\r\n * @example\r\n * const arr1 = castArray(1);\r\n * // Returns: [1]\r\n *\r\n * const arr2 = castArray([1]);\r\n * // Returns: [1]\r\n *\r\n * const arr3 = castArray({'a': 1});\r\n * // Returns: [{'a': 1}]\r\n *\r\n * const arr4 =  castArray(null);\r\n * // Returns: [null]\r\n *\r\n * const arr5 = castArray(undefined);\r\n * // Returns: [undefined]\r\n *\r\n * const arr6 = castArray();\r\n * // Returns: []\r\n */\r\n\r\nexport function castArray<T>(value?: T | readonly T[]): T[] {\r\n  if (arguments.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  return Array.isArray(value) ? value : ([value] as T[]);\r\n}\r\n","import { decimalAdjust } from '../_internal/decimalAdjust.ts';\r\n\r\n/**\r\n * Computes number rounded up to precision.\r\n *\r\n * @param {number | string} number The number to round up.\r\n * @param {number | string} precision The precision to round up to.\r\n * @returns {number} Returns the rounded up number.\r\n *\r\n * @example\r\n * ceil(4.006); // => 5\r\n * ceil(6.004, 2); // => 6.01\r\n * ceil(6040, -2); // => 6100\r\n */\r\nexport function ceil(number: number | string, precision: number | string = 0): number {\r\n  return decimalAdjust('ceil', number, precision);\r\n}\r\n","import { chunk as chunkToolkit } from '../../array/chunk.ts';\r\n\r\n/**\r\n * Splits an array into smaller arrays of a specified length.\r\n *\r\n * This function takes an input array and divides it into multiple smaller arrays,\r\n * each of a specified length. If the input array cannot be evenly divided,\r\n * the final sub-array will contain the remaining elements.\r\n *\r\n * @template T The type of elements in the array.\r\n * @param {T[]} arr - The array to be chunked into smaller arrays.\r\n * @param {number} size - The size of each smaller array. Must be a positive integer.\r\n * @returns {T[][]} A two-dimensional array where each sub-array has a maximum length of `size`.\r\n * @throws {Error} Throws an error if `size` is not a positive integer.\r\n *\r\n * @example\r\n * // Splits an array of numbers into sub-arrays of length 2\r\n * chunk([1, 2, 3, 4, 5], 2);\r\n * // Returns: [[1, 2], [3, 4], [5]]\r\n *\r\n * @example\r\n * // Splits an array of strings into sub-arrays of length 3\r\n * chunk(['a', 'b', 'c', 'd', 'e', 'f', 'g'], 3);\r\n * // Returns: [['a', 'b', 'c'], ['d', 'e', 'f'], ['g']]\r\n */\r\nexport function chunk<T>(arr: readonly T[], size = 1): T[][] {\r\n  size = Math.max(Math.floor(size), 0);\r\n\r\n  if (size === 0) {\r\n    return [];\r\n  }\r\n\r\n  return chunkToolkit(arr, size);\r\n}\r\n","/**\r\n * Splits an array into smaller arrays of a specified length.\r\n *\r\n * This function takes an input array and divides it into multiple smaller arrays,\r\n * each of a specified length. If the input array cannot be evenly divided,\r\n * the final sub-array will contain the remaining elements.\r\n *\r\n * @template T The type of elements in the array.\r\n * @param {T[]} arr - The array to be chunked into smaller arrays.\r\n * @param {number} size - The size of each smaller array. Must be a positive integer.\r\n * @returns {T[][]} A two-dimensional array where each sub-array has a maximum length of `size`.\r\n * @throws {Error} Throws an error if `size` is not a positive integer.\r\n *\r\n * @example\r\n * // Splits an array of numbers into sub-arrays of length 2\r\n * chunk([1, 2, 3, 4, 5], 2);\r\n * // Returns: [[1, 2], [3, 4], [5]]\r\n *\r\n * @example\r\n * // Splits an array of strings into sub-arrays of length 3\r\n * chunk(['a', 'b', 'c', 'd', 'e', 'f', 'g'], 3);\r\n * // Returns: [['a', 'b', 'c'], ['d', 'e', 'f'], ['g']]\r\n */\r\nexport function chunk<T>(arr: readonly T[], size: number): T[][] {\r\n  if (!Number.isInteger(size) || size <= 0) {\r\n    throw new Error('Size must be an integer greater than zero.');\r\n  }\r\n\r\n  const chunkLength = Math.ceil(arr.length / size);\r\n  const result: T[][] = Array(chunkLength);\r\n\r\n  for (let index = 0; index < chunkLength; index++) {\r\n    const start = index * size;\r\n    const end = start + size;\r\n\r\n    result[index] = arr.slice(start, end);\r\n  }\r\n\r\n  return result;\r\n}\r\n","type NotFalsey<T> = Exclude<T, false | null | 0 | '' | undefined>;\r\n\r\n/**\r\n * Removes falsey values (false, null, 0, '', undefined, NaN) from an array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The input array to remove falsey values.\r\n * @returns {Array<Exclude<T, false | null | 0 | '' | undefined>>} - A new array with all falsey values removed.\r\n *\r\n * @example\r\n * compact([0, 1, false, 2, '', 3, null, undefined, 4, NaN, 5]);\r\n * Returns: [1, 2, 3, 4, 5]\r\n */\r\nexport function compact<T>(arr: readonly T[]): Array<NotFalsey<T>> {\r\n  const result: Array<NotFalsey<T>> = [];\r\n\r\n  for (const item of arr) {\r\n    if (item) {\r\n      result.push(item as NotFalsey<T>);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { flatten } from '../../array/flatten.ts';\r\n\r\n/**\r\n * Concatenates multiple arrays and values into a single array.\r\n *\r\n * @template T The type of elements in the array.\r\n * @param {...(T | T[])} values - The values and/or arrays to concatenate.\r\n * @returns {T[]} A new array containing all the input values.\r\n *\r\n * @example\r\n * // Concatenate individual values\r\n * concat(1, 2, 3);\r\n * // returns [1, 2, 3]\r\n *\r\n * @example\r\n * // Concatenate arrays of values\r\n * concat([1, 2], [3, 4]);\r\n * // returns [1, 2, 3, 4]\r\n *\r\n * @example\r\n * // Concatenate a mix of individual values and arrays\r\n * concat(1, [2, 3], 4);\r\n * // returns [1, 2, 3, 4]\r\n *\r\n * @example\r\n * // Concatenate nested arrays\r\n * concat([1, [2, 3]], 4);\r\n * // returns [1, [2, 3], 4]\r\n */\r\nexport function concat<T>(...values: Array<T | readonly T[]>): T[] {\r\n  return flatten(values) as T[];\r\n}\r\n","import { conformsTo } from './conformsTo.ts';\r\nimport { cloneDeep } from '../../object/cloneDeep.ts';\r\n\r\n/**\r\n * Creates a function that invokes the predicate properties of `source` with the corresponding property values of a given object, returning `true` if all predicates return truthy, else `false`.\r\n *\r\n * Note: The created function is equivalent to `conformsTo` with source partially applied.\r\n *\r\n * @param {Record<PropertyKey, (value: any) => boolean>} source The object of property predicates to conform to.\r\n * @returns {(object: Record<PropertyKey, any>) => boolean} Returns the new spec function.\r\n *\r\n * @example\r\n * const isPositive = (n) => n > 0;\r\n * const isEven = (n) => n % 2 === 0;\r\n * const predicates = { a: isPositive, b: isEven };\r\n * const conform = conforms(predicates);\r\n *\r\n * console.log(conform({ a: 2, b: 4 })); // true\r\n * console.log(conform({ a: -1, b: 4 })); // false\r\n * console.log(conform({ a: 2, b: 3 })); // false\r\n * console.log(conform({ a: 0, b: 2 })); // false\r\n */\r\nexport function conforms(\r\n  source: Record<PropertyKey, (value: any) => boolean>\r\n): (object: Record<PropertyKey, any>) => boolean {\r\n  source = cloneDeep(source);\r\n\r\n  return function (object: Record<PropertyKey, any>) {\r\n    return conformsTo(object, source);\r\n  };\r\n}\r\n","/**\r\n * Count the occurrences of each item in an array\r\n * based on a transformation function.\r\n *\r\n * This function takes an array and a transformation function\r\n * that converts each item in the array to a key. It then\r\n * counts the occurrences of each transformed item and returns\r\n * an object with the transformed items as keys and the counts\r\n * as values.\r\n *\r\n * @template T - The type of the items in the input array.\r\n * @template K - The type of keys.\r\n * @param {T[]} arr - The input array to count occurrences.\r\n * @param {(item: T) => K} mapper - The transformation function that maps each item to a key.\r\n * @returns {Record<K, number>} An object containing the transformed items as keys and the\r\n * counts as values.\r\n *\r\n * @example\r\n * const array = ['a', 'b', 'c', 'a', 'b', 'a'];\r\n * const result = countBy(array, x => x);\r\n * // result will be { a: 3, b: 2, c: 1 }\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * const result = countBy(array, item => item % 2 === 0 ? 'even' : 'odd');\r\n * // result will be { odd: 3, even: 2 }\r\n */\r\nexport function countBy<T, K extends PropertyKey>(arr: readonly T[], mapper: (item: T) => K): Record<K, number> {\r\n  const result = {} as Record<K, number>;\r\n\r\n  for (const item of arr) {\r\n    const key = mapper(item);\r\n\r\n    result[key] = (result[key] ?? 0) + 1;\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { difference as differenceToolkit } from '../../array/difference.ts';\r\nimport { flatten } from '../../array/flatten.ts';\r\n\r\n/**\r\n * Computes the difference between an array and multiple arrays.\r\n *\r\n * @template T\r\n * @param {T[]} arr - The primary array from which to derive the difference. This is the main array\r\n * from which elements will be compared and filtered.\r\n * @param {...T[]} values - Multiple arrays containing elements to be excluded from the primary array.\r\n * These arrays will be flattened into a single array, and each element in this array will be checked against the primary array.\r\n * If a match is found, that element will be excluded from the result.\r\n * @returns {T[]} A new array containing the elements that are present in the primary array but not\r\n * in the flattened array.\r\n *\r\n * @example\r\n * const array1 = [1, 2, 3, 4, 5];\r\n * const array2 = [2, 4];\r\n * const array3 = [5, 6];\r\n * const result = difference(array1, array2, array3);\r\n * // result will be [1, 3] since 2, 4, and 5 are in the other arrays and are excluded from the result.\r\n */\r\nexport function difference<T>(arr: readonly T[], ...values: Array<readonly T[]>): T[] {\r\n  const arr1 = arr;\r\n  const arr2 = flatten(values);\r\n\r\n  return differenceToolkit(arr1, arr2);\r\n}\r\n","/**\r\n * Removes a specified number of elements from the beginning of an array and returns the rest.\r\n *\r\n * This function takes an array and a number, and returns a new array with the specified number\r\n * of elements removed from the start.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param { T[] |  null | undefined} collection - - The array from which to drop elements.\r\n * @param {number} itemsCount - The number of elements to drop from the beginning of the array.\r\n * @returns {T[]} A new array with the specified number of elements removed from the start.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * const result = drop(array, 2);\r\n * result will be [3, 4, 5] since the first two elements are dropped.\r\n */\r\nexport function drop<T>(collection: readonly T[] | null | undefined, itemsCount: number): T[] {\r\n  if (collection === null || collection === undefined) {\r\n    return [];\r\n  }\r\n\r\n  itemsCount = Math.max(itemsCount, 0);\r\n\r\n  return collection.slice(itemsCount);\r\n}\r\n","/**\r\n * Removes a specified number of elements from the end of an array and returns the rest.\r\n *\r\n * This function takes an array and a number, and returns a new array with the specified number\r\n * of elements removed from the end.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array from which to drop elements.\r\n * @param {number} itemsCount - The number of elements to drop from the end of the array.\r\n * @returns {T[]} A new array with the specified number of elements removed from the end.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * const result = dropRight(array, 2);\r\n * // result will be [1, 2, 3] since the last two elements are dropped.\r\n */\r\nexport function dropRight<T>(arr: readonly T[], itemsCount: number): T[] {\r\n  itemsCount = Math.min(-itemsCount, 0);\r\n\r\n  if (itemsCount === 0) {\r\n    return arr.slice();\r\n  }\r\n\r\n  return arr.slice(0, itemsCount);\r\n}\r\n","/**\r\n * Removes elements from the end of an array until the predicate returns false.\r\n *\r\n * This function iterates over an array from the end and drops elements until the provided\r\n * predicate function returns false. It then returns a new array with the remaining elements.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array from which to drop elements.\r\n * @param {(item: T) => boolean} canContinueDropping - A predicate function that determines\r\n * whether to continue dropping elements. The function is called with each element from the end,\r\n * and dropping continues as long as it returns true.\r\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * const result = dropRightWhile(array, x => x > 3);\r\n * // result will be [1, 2, 3] since elements greater than 3 are dropped from the end.\r\n */\r\nexport function dropRightWhile<T>(arr: readonly T[], canContinueDropping: (item: T) => boolean): T[] {\r\n  for (let i = arr.length - 1; i >= 0; i--) {\r\n    if (!canContinueDropping(arr[i])) {\r\n      return arr.slice(0, i + 1);\r\n    }\r\n  }\r\n\r\n  return [];\r\n}\r\n","/**\r\n * Removes elements from the beginning of an array until the predicate returns false.\r\n *\r\n * This function iterates over an array and drops elements from the start until the provided\r\n * predicate function returns false. It then returns a new array with the remaining elements.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array from which to drop elements.\r\n * @param {(item: T) => boolean} canContinueDropping - A predicate function that determines\r\n * whether to continue dropping elements. The function is called with each element, and dropping\r\n * continues as long as it returns true.\r\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * const result = dropWhile(array, x => x < 3);\r\n * // result will be [3, 4, 5] since elements less than 3 are dropped.\r\n */\r\nexport function dropWhile<T>(arr: readonly T[], canContinueDropping: (item: T) => boolean): T[] {\r\n  const dropEndIndex = arr.findIndex(item => !canContinueDropping(item));\r\n  if (dropEndIndex === -1) {\r\n    return [];\r\n  }\r\n\r\n  return arr.slice(dropEndIndex);\r\n}\r\n","/**\r\n * Checks if a string contains another string at the end of the string.\r\n *\r\n * Checks if one string endsWith another string. Optional position parameter to offset searching before a certain index.\r\n *\r\n * @param {string} str - The string that might contain the target string.\r\n * @param {string} target - The string to search for.\r\n * @param {number} position - An optional position from the start to search up to this index\r\n * @returns {boolean} - True if the str string ends with the target string.\r\n *\r\n * @example\r\n * const isPrefix = endsWith('fooBar', 'foo') // returns true\r\n * const isPrefix = endsWith('fooBar', 'bar') // returns false\r\n * const isPrefix = endsWith('fooBar', 'abc') // returns false\r\n * const isPrefix = endsWith('fooBar', 'foo', 3) // returns true\r\n * const isPrefix = endsWith('fooBar', 'abc', 5) // returns false\r\n */\r\nexport function endsWith(str: string, target: string, position: number = str.length): boolean {\r\n  return str.endsWith(target, position);\r\n}\r\n","/**\r\n * Escapes the RegExp special characters \"^\", \"$\", \"\\\\\", \".\", \"*\", \"+\", \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `str`.\r\n *\r\n * @param {string} str The string to escape.\r\n * @returns {string} Returns the escaped string.\r\n *\r\n * @example\r\n * import { escapeRegExp } from 'es-toolkit/string';\r\n *\r\n * escapeRegExp('[es-toolkit](https://es-toolkit.slash.page/)'); // returns '\\[es-toolkit\\]\\(https://es-toolkit\\.slash\\.page/\\)'\r\n */\r\nexport function escapeRegExp(str: string): string {\r\n  return str.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&');\r\n}\r\n","import { fill as fillToolkit } from '../../array/fill.ts';\r\n\r\n/**\r\n * Fills the whole array with a specified value.\r\n *\r\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\r\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\r\n * entire array.\r\n *\r\n * @template T, U, S, V\r\n * @param {Array<T | U>} array - The array to fill.\r\n * @param {U} value - The value to fill the array with.\r\n * @returns {Array<T | U>} The array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result = fill(array, 'a');\r\n * // => ['a', 'a', 'a']\r\n *\r\n * const result = fill(Array(3), 2);\r\n * // => [2, 2, 2]\r\n *\r\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\r\n * // => [4, '*', '*', 10]\r\n *\r\n * const result = fill(array, '*', -2, -1);\r\n * // => [1, '*', 3]\r\n */\r\nexport function fill<T>(array: unknown[], value?: T): T[];\r\n/**\r\n * Fills elements of an array with a specified value from the start position to the end.\r\n *\r\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\r\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\r\n * entire array.\r\n *\r\n * @template T, U, S, V\r\n * @param {Array<T | U>} array - The array to fill.\r\n * @param {U} value - The value to fill the array with.\r\n * @param {S} [start=0] - The start position. Defaults to 0.\r\n * @returns {Array<T | U>} The array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result = fill(array, 'a');\r\n * // => ['a', 'a', 'a']\r\n *\r\n * const result = fill(Array(3), 2);\r\n * // => [2, 2, 2]\r\n *\r\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\r\n * // => [4, '*', '*', 10]\r\n *\r\n * const result = fill(array, '*', -2, -1);\r\n * // => [1, '*', 3]\r\n */\r\nexport function fill<T, U, S>(array: Array<T | U>, value: U, start: S): Array<T | U>;\r\n/**\r\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\r\n *\r\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\r\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\r\n * entire array.\r\n *\r\n * @template T, U, S, V\r\n * @param {Array<T | U>} array - The array to fill.\r\n * @param {U} value - The value to fill the array with.\r\n * @param {S} [start=0] - The start position. Defaults to 0.\r\n * @param {V} [end=arr.length] - The end position. Defaults to the array's length.\r\n * @returns {Array<T | U>} The array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result = fill(array, 'a');\r\n * // => ['a', 'a', 'a']\r\n *\r\n * const result = fill(Array(3), 2);\r\n * // => [2, 2, 2]\r\n *\r\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\r\n * // => [4, '*', '*', 10]\r\n *\r\n * const result = fill(array, '*', -2, -1);\r\n * // => [1, '*', 3]\r\n */\r\nexport function fill<T, U, S, V>(array: Array<T | U>, value: U, start: S, end: V): Array<T | U>;\r\n/**\r\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\r\n *\r\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\r\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\r\n * entire array.\r\n *\r\n * @template T, U, S, V\r\n * @param {Array<T | U>} array - The array to fill.\r\n * @param {U} value - The value to fill the array with.\r\n * @param {S} [start=0] - The start position. Defaults to 0.\r\n * @param {V} [end=arr.length] - The end position. Defaults to the array's length.\r\n * @returns {Array<T | U>} The array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result = fill(array, 'a');\r\n * // => ['a', 'a', 'a']\r\n *\r\n * const result = fill(Array(3), 2);\r\n * // => [2, 2, 2]\r\n *\r\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\r\n * // => [4, '*', '*', 10]\r\n *\r\n * const result = fill(array, '*', -2, -1);\r\n * // => [1, '*', 3]\r\n */\r\nexport function fill<T, U>(array: Array<T | U>, value: U, start = 0, end = array.length): Array<T | U> {\r\n  start = Math.floor(start);\r\n  end = Math.floor(end);\r\n\r\n  if (!start) {\r\n    start = 0;\r\n  }\r\n  if (!end) {\r\n    end = 0;\r\n  }\r\n\r\n  return fillToolkit(array, value, start, end);\r\n}\r\n","/**\r\n * Fills the whole array with a specified value.\r\n *\r\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\r\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\r\n * entire array.\r\n *\r\n * @template T, U\r\n * @param {Array<T | U>} array - The array to fill.\r\n * @param {U} value - The value to fill the array with.\r\n * @returns {Array<T | U>} The array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result = fill(array, 'a');\r\n * // => ['a', 'a', 'a']\r\n *\r\n * const result = fill(Array(3), 2);\r\n * // => [2, 2, 2]\r\n *\r\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\r\n * // => [4, '*', '*', 10]\r\n *\r\n * const result = fill(array, '*', -2, -1);\r\n * // => [1, '*', 3]\r\n */\r\nexport function fill<T>(array: unknown[], value: T): T[];\r\n/**\r\n * Fills elements of an array with a specified value from the start position up to the end of the array.\r\n *\r\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\r\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\r\n * entire array.\r\n *\r\n * @template T, U\r\n * @param {Array<T | U>} array - The array to fill.\r\n * @param {U} value - The value to fill the array with.\r\n * @param {number} [start=0] - The start position. Defaults to 0.\r\n * @returns {Array<T | U>} The array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result = fill(array, 'a');\r\n * // => ['a', 'a', 'a']\r\n *\r\n * const result = fill(Array(3), 2);\r\n * // => [2, 2, 2]\r\n *\r\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\r\n * // => [4, '*', '*', 10]\r\n *\r\n * const result = fill(array, '*', -2, -1);\r\n * // => [1, '*', 3]\r\n */\r\nexport function fill<T, U>(array: Array<T | U>, value: U, start: number): Array<T | U>;\r\n/**\r\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\r\n *\r\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\r\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\r\n * entire array.\r\n *\r\n * @template T, U\r\n * @param {Array<T | U>} array - The array to fill.\r\n * @param {U} value - The value to fill the array with.\r\n * @param {number} [start=0] - The start position. Defaults to 0.\r\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\r\n * @returns {Array<T | U>} The array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result = fill(array, 'a');\r\n * // => ['a', 'a', 'a']\r\n *\r\n * const result = fill(Array(3), 2);\r\n * // => [2, 2, 2]\r\n *\r\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\r\n * // => [4, '*', '*', 10]\r\n *\r\n * const result = fill(array, '*', -2, -1);\r\n * // => [1, '*', 3]\r\n */\r\nexport function fill<T, U>(array: Array<T | U>, value: U, start: number, end: number): Array<T | U>;\r\n/**\r\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\r\n *\r\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\r\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\r\n * entire array.\r\n *\r\n * @template T, U\r\n * @param {Array<T | U>} array - The array to fill.\r\n * @param {U} value - The value to fill the array with.\r\n * @param {number} [start=0] - The start position. Defaults to 0.\r\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\r\n * @returns {Array<T | U>} The array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result = fill(array, 'a');\r\n * // => ['a', 'a', 'a']\r\n *\r\n * const result = fill(Array(3), 2);\r\n * // => [2, 2, 2]\r\n *\r\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\r\n * // => [4, '*', '*', 10]\r\n *\r\n * const result = fill(array, '*', -2, -1);\r\n * // => [1, '*', 3]\r\n */\r\nexport function fill<T, U>(array: Array<T | U>, value: U, start = 0, end = array.length): Array<T | U> {\r\n  const length = array.length;\r\n  const finalStart = Math.max(start >= 0 ? start : length + start, 0);\r\n  const finalEnd = Math.min(end >= 0 ? end : length + end, length);\r\n\r\n  for (let i = finalStart; i < finalEnd; i++) {\r\n    array[i] = value;\r\n  }\r\n\r\n  return array;\r\n}\r\n","import { property } from '../object/property.ts';\r\nimport { matches } from '../predicate/matches.ts';\r\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\r\n\r\n/**\r\n * Finds the first item in an array that matches the given predicate function.\r\n *\r\n * @template T\r\n * @param {T[]} arr - The array to search through.\r\n * @param {(item: T, index: number, arr: T[]) => unknown} doesMatch - A function that takes an item, its index, and the array, and returns a truthy value if the item matches the criteria.\r\n * @returns {T | undefined} - The first item that matches the predicate, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a predicate function\r\n * const items = [1, 2, 3, 4, 5];\r\n * const result = find(items, (item) => item > 3);\r\n * console.log(result); // 4\r\n */\r\nexport function find<T>(\r\n  arr: readonly T[],\r\n  doesMatch: (item: T, index: number, arr: readonly T[]) => unknown\r\n): T | undefined;\r\n\r\n/**\r\n * Finds the first item in an array that matches the given partial object.\r\n *\r\n * @template T\r\n * @param {T[]} arr - The array to search through.\r\n * @param {Partial<T>} doesMatch - A partial object that specifies the properties to match.\r\n * @returns {T | undefined} - The first item that matches the partial object, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a partial object\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = find(items, { name: 'Bob' });\r\n * console.log(result); // { id: 2, name: 'Bob' }\r\n */\r\nexport function find<T>(arr: readonly T[], doesMatch: Partial<T>): T | undefined;\r\n\r\n/**\r\n * Finds the first item in an array that matches a property with a specific value.\r\n *\r\n * @template T\r\n * @param {readonly T[]} arr - The array to search through.\r\n * @param {[keyof T, unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\r\n * @returns {T | undefined} - The first item that has the specified property value, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property-value pair\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = find(items, ['name', 'Alice']);\r\n * console.log(result); // { id: 1, name: 'Alice' }\r\n */\r\nexport function find<T>(arr: readonly T[], doesMatchProperty: [keyof T, unknown]): T | undefined;\r\n\r\n/**\r\n * Finds the first item in an array that has a specific property, where the property name is provided as a string.\r\n *\r\n * @template T\r\n * @param {readonly T[]} arr - The array to search through.\r\n * @param {string} propertyToCheck - The property name to check.\r\n * @returns {T | undefined} - The first item that has the specified property, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property name\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = find(items, 'name');\r\n * console.log(result); // { id: 1, name: 'Alice' }\r\n */\r\nexport function find<T>(arr: readonly T[], propertyToCheck: string): T | undefined;\r\n\r\n/**\r\n * Finds the first item in an object that matches the given predicate function.\r\n *\r\n * @template T\r\n * @param {T extends Record<string, unknown> ? T : never} object - The object to search through.\r\n * @param {(item: T[keyof T], index: number, arr: T) => unknown} doesMatch - A function that takes an item, its key, and the object, and returns a truthy value if the item matches the criteria.\r\n * @returns {T | undefined} - The first property value that matches the predicate, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a predicate function\r\n * const obj = { a: 1, b: 2, c: 3 };\r\n * const result = find(obj, (item) => item > 2);\r\n * console.log(result); // 3\r\n */\r\nexport function find<T extends Record<string, unknown>>(\r\n  object: T,\r\n  doesMatch: (item: T[keyof T], index: number, object: T) => unknown\r\n): T | undefined;\r\n\r\n/**\r\n * Finds the first item in an object that matches the given partial value.\r\n *\r\n * @template T\r\n * @param {T extends Record<string, unknown> ? T : never} object - The object to search through.\r\n * @param {Partial<T[keyof T]>} doesMatch - A partial value to match against the values of the object.\r\n * @returns {T | undefined} - The first property value that matches the partial value, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a partial value\r\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } };\r\n * const result = find(obj, { name: 'Bob' });\r\n * console.log(result); // { id: 2, name: 'Bob' }\r\n */\r\nexport function find<T extends Record<string, unknown>>(object: T, doesMatch: Partial<T[keyof T]>): T | undefined;\r\n\r\n/**\r\n * Finds the first item in an object that matches a property with a specific value.\r\n *\r\n * @template T\r\n * @param {readonly T[]} object - The object to search through.\r\n * @param {[keyof T, unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\r\n * @returns {T | undefined} - The first item that has the specified property value, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property-value pair\r\n * const items = { alice: { id: 1, name: 'Alice' }, bob: { id: 2, name: 'Bob' } };\r\n * const result = find(items, ['name', 'Alice']);\r\n * console.log(result); // { id: 1, name: 'Alice' }\r\n */\r\nexport function find<T extends Record<string, unknown>>(\r\n  object: T,\r\n  doesMatchProperty: [keyof T, unknown]\r\n): T | undefined;\r\n\r\n/**\r\n * Finds the first item in an object that has a specific property, where the property name is provided as a string.\r\n *\r\n * @template T\r\n * @param {T extends Record<string, unknown> ? T : never} object - The object to search through.\r\n * @param {string} propertyToCheck - The property name to check.\r\n * @returns {T | undefined} - The first property value that has the specified property, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property name\r\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } };\r\n * const result = find(obj, 'name');\r\n * console.log(result); // { id: 1, name: 'Alice' }\r\n */\r\nexport function find<T extends Record<string, unknown>>(object: T, propertyToCheck: string): T | undefined;\r\n\r\n/**\r\n * Finds the first item in an object that has a specific property, where the property name is provided as a string.\r\n *\r\n * @template T\r\n * @param {T extends Record<string, unknown> ? T : never} object - The object to search through.\r\n * @param {readonly T[] | Record<any, any>} source - The source array or object to search through.\r\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string} doesMatch - The criteria to match. It can be a function, a partial object, a key-value pair, or a property name.\r\n * @param {string} propertyToCheck - The property name to check.\r\n * @returns {T | undefined} - The first property value that has the specified property, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property name\r\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } };\r\n * const result = find(obj, 'name');\r\n * console.log(result); // { id: 1, name: 'Alice' }\r\n */\r\nexport function find<T>(\r\n  source: readonly T[] | Record<any, any>,\r\n  doesMatch: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string\r\n): T | undefined {\r\n  let values = source;\r\n\r\n  if (!Array.isArray(source)) {\r\n    values = Object.values(source);\r\n  }\r\n\r\n  switch (typeof doesMatch) {\r\n    case 'function': {\r\n      if (!Array.isArray(source)) {\r\n        const entries: any[] = Object.entries(source);\r\n\r\n        for (let i = 0; i < entries.length; i++) {\r\n          const entry = entries[i];\r\n          const key = entry[0];\r\n          const value = entry[1];\r\n\r\n          if (doesMatch(value, key, source)) {\r\n            return value;\r\n          }\r\n        }\r\n\r\n        return undefined;\r\n      }\r\n\r\n      return values.find(doesMatch);\r\n    }\r\n    case 'object': {\r\n      if (Array.isArray(doesMatch) && doesMatch.length === 2) {\r\n        const key = doesMatch[0];\r\n        const value = doesMatch[1];\r\n\r\n        return values.find(matchesProperty(key, value));\r\n      } else {\r\n        return values.find(matches(doesMatch));\r\n      }\r\n    }\r\n    case 'string': {\r\n      return values.find(property(doesMatch));\r\n    }\r\n  }\r\n}\r\n","import { property } from '../object/property.ts';\r\nimport { matches } from '../predicate/matches.ts';\r\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\r\n\r\n/**\r\n * Finds the index of the first item in an array that matches the given predicate function.\r\n *\r\n * @template T\r\n * @param {T[]} arr - The array to search through.\r\n * @param {(item: T, index: number, arr: T[]) => unknown} doesMatch - A function that takes an item, its index, and the array, and returns a truthy value if the item matches the criteria.\r\n * @returns {number} - The index of the first item that matches the predicate, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a predicate function\r\n * const items = [1, 2, 3, 4, 5];\r\n * const result = find(items, (item) => item > 3);\r\n * console.log(result); // 4\r\n */\r\nexport function findIndex<T>(\r\n  arr: readonly T[],\r\n  doesMatch: (item: T, index: number, arr: readonly T[]) => unknown\r\n): number;\r\n\r\n/**\r\n * Finds the index of the first item in an array that matches the given partial object.\r\n *\r\n * @template T\r\n * @param {T[]} arr - The array to search through.\r\n * @param {Partial<T>} doesMatch - A partial object that specifies the properties to match.\r\n * @returns {number} - The index of the first item that matches the partial object, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a partial object\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = findIndex(items, { name: 'Bob' });\r\n * console.log(result); // 1\r\n */\r\nexport function findIndex<T>(arr: readonly T[], doesMatch: Partial<T>): number;\r\n\r\n/**\r\n * Finds the index of the first item in an array that matches a property with a specific value.\r\n *\r\n * @template T\r\n * @param {readonly T[]} arr - The array to search through.\r\n * @param {[keyof T, unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\r\n * @returns {number} - The index of the first item that has the specified property value, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property-value pair\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = findIndex(items, ['name', 'Alice']);\r\n * console.log(result); // 0\r\n */\r\nexport function findIndex<T>(arr: readonly T[], doesMatchProperty: [keyof T, unknown]): number;\r\n\r\n/**\r\n * Finds the index of the first item in an array that has a specific property, where the property name is provided as a string.\r\n *\r\n * @template T\r\n * @param {readonly T[]} arr - The array to search through.\r\n * @param {string} propertyToCheck - The property name to check.\r\n * @returns {number} - The index of the first item that has the specified property, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property name\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = findIndex(items, 'name');\r\n * console.log(result); // 0\r\n */\r\nexport function findIndex<T>(arr: readonly T[], propertyToCheck: string): number;\r\n\r\n/**\r\n * Finds the index of the first item in an array that has a specific property, where the property name is provided as a string.\r\n *\r\n * @template T\r\n * @param {readonly T[]} arr - The array to search through.\r\n * @param {readonly T[]} source - The source array to search for the matching item.\r\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string} doesMatch - The criteria to match against the items in the array. This can be a function, a partial object, a key-value pair, or a property name.\r\n * @param {string} propertyToCheck - The property name to check for in the items of the array.\r\n * @returns {number} - The index of the first item that has the specified property, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property name\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = findIndex(items, 'name');\r\n * console.log(result); // 0\r\n */\r\nexport function findIndex<T>(\r\n  source: readonly T[],\r\n  doesMatch: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string\r\n): number {\r\n  switch (typeof doesMatch) {\r\n    case 'function': {\r\n      return source.findIndex(doesMatch);\r\n    }\r\n    case 'object': {\r\n      if (Array.isArray(doesMatch) && doesMatch.length === 2) {\r\n        const key = doesMatch[0];\r\n        const value = doesMatch[1];\r\n\r\n        return source.findIndex(matchesProperty(key, value));\r\n      } else {\r\n        return source.findIndex(matches(doesMatch));\r\n      }\r\n    }\r\n    case 'string': {\r\n      return source.findIndex(property(doesMatch));\r\n    }\r\n  }\r\n}\r\n","import { property } from '../object/property.ts';\r\nimport { matches } from '../predicate/matches.ts';\r\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\r\n\r\n/**\r\n * Iterates through an array in reverse order and returns the index of the first item that matches the given predicate function.\r\n *\r\n * @template T\r\n * @param {T[]} arr - The array to search through.\r\n * @param {(item: T, index: number, arr: T[]) => unknown} doesMatch - A function that takes an item, its index, and the array, and returns a truthy value if the item matches the criteria.\r\n * @param {number} [fromIndex=arr.length - 1] - The index to start the search from, defaults to the last index of the array.\r\n * @returns {number} - The index of the first item that matches the predicate, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a predicate function\r\n * const items = [1, 2, 3, 4, 5];\r\n * const result = findLastIndex(items, (item) => item > 3)\r\n * console.log(result); // 4\r\n */\r\nexport function findLastIndex<T>(\r\n  arr: readonly T[],\r\n  doesMatch: (item: T, index: number, arr: readonly T[]) => unknown,\r\n  fromIndex?: number\r\n): number;\r\n\r\n/**\r\n * Finds the index of the first item in an array that matches the given partial object.\r\n *\r\n * @template T\r\n * @param {readonly T[]} arr - The array to search through.\r\n * @param {Partial<T>} doesMatch - A partial object that specifies the properties to match.\r\n * @param {number} [fromIndex=arr.length - 1] - The index to start the search from, defaults to the last index of the array.\r\n * @returns {number} - The index of the first item that matches the partial object, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a partial object\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = findLastIndex(items, { name: 'Bob' });\r\n * console.log(result); // 1\r\n */\r\nexport function findLastIndex<T>(arr: readonly T[], doesMatch: Partial<T>, fromIndex?: number): number;\r\n\r\n/**\r\n * Finds the index of the first item in an array that matches a property with a specific value.\r\n *\r\n * @template T\r\n * @param {readonly T[]} arr - The array to search through.\r\n * @param {[keyof T, unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\r\n * @param {number} [fromIndex=arr.length - 1] - The index to start the search from, defaults to the last index of the array.\r\n * @returns {number} - The index of the first item that has the specified property value, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property-value pair\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = findLastIndex(items, ['name', 'Alice']);\r\n * console.log(result); // 0\r\n */\r\nexport function findLastIndex<T>(arr: readonly T[], doesMatchProperty: [keyof T, unknown], fromIndex?: number): number;\r\n\r\n/**\r\n * Finds the index of the first item in an array that has a specific property, where the property name is provided as a string.\r\n *\r\n * @template T\r\n * @param {readonly T[]} arr - The array to search through.\r\n * @param {string} propertyToCheck - The property name to check.\r\n * @param {number} [fromIndex=arr.length - 1] - The index to start the search from, defaults to the last index of the array.\r\n * @returns {number} - The index of the first item that has the specified property, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property name\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = findLastIndex(items, 'name');\r\n * console.log(result); // 1\r\n */\r\nexport function findLastIndex<T>(arr: readonly T[], propertyToCheck: string, fromIndex?: number): number;\r\n\r\n/**\r\n * Finds the index of the first item in an array that has a specific property, where the property name is provided as a string.\r\n *\r\n * @template T\r\n * @param {T[]} arr - The array to search through.\r\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string} doesMatch - The property name to check.\r\n * @param {number} [fromIndex=arr.length - 1] - The index to start the search from, defaults to the last index of the array.\r\n * @returns {number} - The index of the first item that has the specified property, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property name\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = findLastIndex(items, 'name');\r\n * console.log(result); // 1\r\n */\r\nexport function findLastIndex<T>(\r\n  arr: readonly T[],\r\n  doesMatch: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string,\r\n  fromIndex: number = arr.length - 1\r\n): number {\r\n  if (fromIndex < 0) {\r\n    fromIndex = Math.max(arr.length + fromIndex, 0);\r\n  } else {\r\n    fromIndex = Math.min(fromIndex, arr.length - 1);\r\n  }\r\n\r\n  arr = arr.slice(0, fromIndex + 1);\r\n\r\n  switch (typeof doesMatch) {\r\n    case 'function': {\r\n      return arr.findLastIndex(doesMatch);\r\n    }\r\n    case 'object': {\r\n      if (Array.isArray(doesMatch) && doesMatch.length === 2) {\r\n        const key = doesMatch[0];\r\n        const value = doesMatch[1];\r\n\r\n        return arr.findLastIndex(matchesProperty(key, value));\r\n      } else {\r\n        return arr.findLastIndex(matches(doesMatch));\r\n      }\r\n    }\r\n    case 'string': {\r\n      return arr.findLastIndex(property(doesMatch));\r\n    }\r\n  }\r\n}\r\n","import { flatten } from './flatten.ts';\r\n\r\n/**\r\n * Maps each element in the array using the iteratee function and flattens the result up to the specified depth.\r\n *\r\n * @template T - The type of elements within the array.\r\n * @template U - The type of elements within the returned array from the iteratee function.\r\n * @template D - The depth to which the array should be flattened.\r\n * @param {T[]} arr - The array to flatten.\r\n * @param {(item: T) => U} iteratee - The function that produces the new array elements.\r\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\r\n * @returns {Array<FlatArray<U[], D>>} The new array with the mapped and flattened elements.\r\n *\r\n * @example\r\n * const arr = [1, 2, 3];\r\n *\r\n * flatMap(arr, (item: number) => [item, item]);\r\n * // [1, 1, 2, 2, 3, 3]\r\n *\r\n * flatMap(arr, (item: number) => [[item, item]], 2);\r\n * // [1, 1, 2, 2, 3, 3]\r\n */\r\nexport function flatMap<T, U, D extends number>(\r\n  arr: readonly T[],\r\n  iteratee: (item: T) => U,\r\n  depth = 1 as D\r\n): Array<FlatArray<U[], D>> {\r\n  return flatten(\r\n    arr.map(item => iteratee(item)),\r\n    depth\r\n  );\r\n}\r\n","import { ExtractNestedArrayType, flattenDeep } from './flattenDeep.ts';\r\n\r\n/**\r\n * Recursively maps each element in an array using a provided iteratee function and then deeply flattens the resulting array.\r\n *\r\n * @template T - The type of elements within the array.\r\n * @template U - The type of elements within the returned array from the iteratee function.\r\n * @param {T[]} arr - The array to flatten.\r\n * @param {(item: T) => U} iteratee - The function that produces the new array elements.\r\n * @returns {Array<ExtractNestedArrayType<U>>} A new array that has been flattened.\r\n *\r\n * @example\r\n * const result = flatMapDeep([1, 2, 3], n => [[n, n]]);\r\n * // [1, 1, 2, 2, 3, 3]\r\n */\r\nexport function flatMapDeep<T, U>(arr: readonly T[], iteratee: (item: T) => U): Array<ExtractNestedArrayType<U>> {\r\n  return flattenDeep(arr.map((item: T) => iteratee(item)));\r\n}\r\n","import { flatten } from './flatten.ts';\r\n\r\n/**\r\n * Utility type for recursively unpacking nested array types to extract the type of the innermost element\r\n *\r\n * @example\r\n * ExtractNestedArrayType<(number | (number | number[])[])[]>\r\n * // number\r\n *\r\n * ExtractNestedArrayType<(boolean | (string | number[])[])[]>\r\n * // string | number | boolean\r\n */\r\nexport type ExtractNestedArrayType<T> = T extends ReadonlyArray<infer U> ? ExtractNestedArrayType<U> : T;\r\n\r\n/**\r\n * Flattens all depths of a nested array.\r\n *\r\n * @template T - The type of elements within the array.\r\n * @param {T[]} arr - The array to flatten.\r\n * @returns {Array<ExtractNestedArrayType<T>>} A new array that has been flattened.\r\n *\r\n * @example\r\n * const arr = flattenDeep([1, [2, [3]], [4, [5, 6]]]);\r\n * // Returns: [1, 2, 3, 4, 5, 6]\r\n */\r\nexport function flattenDeep<T>(arr: readonly T[]): Array<ExtractNestedArrayType<T>> {\r\n  return flatten(arr, Infinity) as Array<ExtractNestedArrayType<T>>;\r\n}\r\n","import { flatten } from './flatten.ts';\r\n\r\n/**\r\n * Utility type for recursively unpacking nested array types to extract the type of the innermost element\r\n *\r\n * @example\r\n * ExtractNestedArrayType<(number | (number | number[])[])[]>\r\n * // number\r\n *\r\n * ExtractNestedArrayType<(boolean | (string | number[])[])[]>\r\n * // string | number | boolean\r\n */\r\ntype ExtractNestedArrayType<T> = T extends ReadonlyArray<infer U> ? ExtractNestedArrayType<U> : T;\r\n\r\n/**\r\n * Flattens all depths of a nested array.\r\n *\r\n * @template T - The type of elements within the array.\r\n * @param {T[] | object} value - The value to flatten.\r\n * @returns {Array<ExtractNestedArrayType<T>> | []} A new array that has been flattened.\r\n *\r\n * @example\r\n * const value = flattenDeep([1, [2, [3]], [4, [5, 6]]]);\r\n * // Returns: [1, 2, 3, 4, 5, 6]\r\n */\r\nexport function flattenDeep<T>(value: readonly T[] | object): Array<ExtractNestedArrayType<T>> | [] {\r\n  return flatten(value, Infinity) as Array<ExtractNestedArrayType<T>>;\r\n}\r\n","import { flatten } from './flatten.ts';\r\n\r\n/**\r\n * Flattens an array up to the specified depth.\r\n *\r\n * @template T - The type of elements within the array.\r\n * @template D - The depth to which the array should be flattened.\r\n * @param {T[] | object} value - The value to flatten.\r\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\r\n * @returns {Array<FlatArray<T[], D>> | []} A new array that has been flattened.\r\n *\r\n * @example\r\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 1);\r\n * // Returns: [1, 2, 3, 4, [5, 6]]\r\n *\r\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 2);\r\n * // Returns: [1, 2, 3, 4, 5, 6]\r\n */\r\nexport function flattenDepth<T, D extends number = 1>(\r\n  value: readonly T[] | object,\r\n  depth = 1 as D\r\n): Array<FlatArray<T[], D>> | [] {\r\n  return flatten(value, depth);\r\n}\r\n","import { decimalAdjust } from '../_internal/decimalAdjust.ts';\r\n\r\n/**\r\n * Computes number rounded down to precision.\r\n *\r\n * @param {number | string} number The number to round down.\r\n * @param {number | string} precision The precision to round down to.\r\n * @returns {number} Returns the rounded down number.\r\n *\r\n * @example\r\n * floor(4.006); // => 4\r\n * floor(0.046, 2); // => 0.04\r\n * floor(4060, -2); // => 4000\r\n */\r\nexport function floor(number: number | string, precision: number | string = 0): number {\r\n  return decimalAdjust('floor', number, precision);\r\n}\r\n","/**\r\n * Iterates over elements of 'arr' from right to left and invokes 'callback' for each element.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to iterate over.\r\n * @param {(value: T, index: number, arr: T[]) => void} callback - The function invoked per iteration.\r\n * The callback function receives three arguments:\r\n *  - 'value': The current element being processed in the array.\r\n *  - 'index': The index of the current element being processed in the array.\r\n *  - 'arr': The array 'forEachRight' was called upon.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result: number[] = [];\r\n *\r\n * // Use the forEachRight function to iterate through the array and add each element to the result array.\r\n * forEachRight(array, (value) => {\r\n *  result.push(value);\r\n * })\r\n *\r\n * console.log(result) // Output: [3, 2, 1]\r\n */\r\nexport function forEachRight<T>(arr: T[], callback: (value: T, index: number, arr: T[]) => void): void;\r\n/**\r\n * Iterates over elements of 'arr' from right to left and invokes 'callback' for each element.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to iterate over.\r\n * @param {(value: T, index: number, arr: T[]) => void} callback - The function invoked per iteration.\r\n * The callback function receives three arguments:\r\n *  - 'value': The current element being processed in the array.\r\n *  - 'index': The index of the current element being processed in the array.\r\n *  - 'arr': The array 'forEachRight' was called upon.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result: number[] = [];\r\n *\r\n * // Use the forEachRight function to iterate through the array and add each element to the result array.\r\n * forEachRight(array, (value) => {\r\n *  result.push(value);\r\n * })\r\n *\r\n * console.log(result) // Output: [3, 2, 1]\r\n */\r\nexport function forEachRight<T>(\r\n  arr: readonly T[],\r\n  callback: (value: T, index: number, arr: readonly T[]) => void\r\n): void;\r\n\r\n/**\r\n * Iterates over elements of 'arr' from right to left and invokes 'callback' for each element.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to iterate over.\r\n * @param {(value: T, index: number, arr: T[]) => void} callback - The function invoked per iteration.\r\n * The callback function receives three arguments:\r\n *  - 'value': The current element being processed in the array.\r\n *  - 'index': The index of the current element being processed in the array.\r\n *  - 'arr': The array 'forEachRight' was called upon.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result: number[] = [];\r\n *\r\n * // Use the forEachRight function to iterate through the array and add each element to the result array.\r\n * forEachRight(array, (value) => {\r\n *  result.push(value);\r\n * })\r\n *\r\n * console.log(result) // Output: [3, 2, 1]\r\n */\r\nexport function forEachRight<T>(arr: readonly T[], callback: (value: T, index: number, arr: T[]) => void): void {\r\n  for (let i = arr.length - 1; i >= 0; i--) {\r\n    const element = arr[i];\r\n    callback(element, i, arr as T[]);\r\n  }\r\n}\r\n","import { isArrayLike } from '../predicate/isArrayLike.ts';\r\n\r\n/**\r\n * Converts an array of key-value pairs into an object.\r\n *\r\n * @param {any[]} pairs - An array of key-value pairs where each key is a `PropertyKey` and each value is of type `U`.\r\n * @returns {Record<string, any>} - An object where the keys are from the first element and values are from the second element.\r\n *\r\n * @example\r\n * const pairs = [['a', 1], ['b', 2]];\r\n * const result = fromPairs(pairs);\r\n * // result will be: { a: 1, b: 2 }\r\n */\r\nexport function fromPairs(pairs: readonly any[]): Record<string, any>;\r\n/**\r\n * Converts an array of key-value pairs into an object.\r\n *\r\n * @template T - The type of the keys in the resulting object. It must extend `PropertyKey`.\r\n * @template U - The type of the values in the resulting object.\r\n *\r\n * @param {Array<[T, U]>} pairs - An array of key-value pairs where each key is a `PropertyKey` and each value is of type `U`.\r\n * @returns {Record<T, U>} - An object where the keys are of type `T` and the values are of type `U`.\r\n *\r\n * @example\r\n * const pairs = [['a', 1], ['b', 2]];\r\n * const result = fromPairs(pairs);\r\n * // result will be: { a: 1, b: 2 }\r\n */\r\nexport function fromPairs<T extends PropertyKey, U>(pairs: ReadonlyArray<[T, U]> | Map<T, U>): Record<T, U>;\r\n/**\r\n * Converts an array of key-value pairs into an object.\r\n *\r\n * @template T - The type of the keys in the resulting object. It must extend `PropertyKey`.\r\n * @template U - The type of the values in the resulting object.\r\n *\r\n * @param {Array<[T, U]>} pairs - An array of key-value pairs where each key is a `PropertyKey` and each value is of type `U`.\r\n * @returns {Record<T, U>} - An object where the keys are of type `T` and the values are of type `U`.\r\n *\r\n * @example\r\n * const pairs = [['a', 1], ['b', 2]];\r\n * const result = fromPairs(pairs);\r\n * // result will be: { a: 1, b: 2 }\r\n */\r\nexport function fromPairs<T extends PropertyKey, U>(pairs: ReadonlyArray<[T, U]> | Map<T, U>): Record<T, U> {\r\n  if (!isArrayLike(pairs) && !(pairs instanceof Map)) {\r\n    return {} as Record<T, U>;\r\n  }\r\n\r\n  const result = {} as Record<T, U>;\r\n\r\n  for (const [key, value] of pairs) {\r\n    result[key as T] = value;\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Groups the elements of an array based on a provided key-generating function.\r\n *\r\n * This function takes an array and a function that generates a key from each element. It returns\r\n * an object where the keys are the generated keys and the values are arrays of elements that share\r\n * the same key.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @template K - The type of keys.\r\n * @param {T[]} arr - The array to group.\r\n * @param {(item: T) => K} getKeyFromItem - A function that generates a key from an element.\r\n * @returns {Record<K, T[]>} An object where each key is associated with an array of elements that\r\n * share that key.\r\n *\r\n * @example\r\n * const array = [\r\n *   { category: 'fruit', name: 'apple' },\r\n *   { category: 'fruit', name: 'banana' },\r\n *   { category: 'vegetable', name: 'carrot' }\r\n * ];\r\n * const result = groupBy(array, item => item.category);\r\n * // result will be:\r\n * // {\r\n * //   fruit: [\r\n * //     { category: 'fruit', name: 'apple' },\r\n * //     { category: 'fruit', name: 'banana' }\r\n * //   ],\r\n * //   vegetable: [\r\n * //     { category: 'vegetable', name: 'carrot' }\r\n * //   ]\r\n * // }\r\n */\r\nexport function groupBy<T, K extends PropertyKey>(arr: readonly T[], getKeyFromItem: (item: T) => K): Record<K, T[]> {\r\n  const result = Object.create(null) as Record<K, T[]>;\r\n\r\n  for (const item of arr) {\r\n    const key = getKeyFromItem(item);\r\n\r\n    if (result[key] == null) {\r\n      result[key] = [];\r\n    }\r\n\r\n    result[key].push(item);\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { inRange as inRangeToolkit } from '../../math/inRange.ts';\r\n\r\n/**\r\n * Checks if the value is less than the maximum.\r\n *\r\n * @param {number} value The value to check.\r\n * @param {number} maximum The upper bound of the range (exclusive).\r\n * @returns {boolean} `true` if the value is less than the maximum, otherwise `false`.\r\n *\r\n * @example\r\n * const result = inRange(3, 5); // result will be true.\r\n * const result2 = inRange(5, 5); // result2 will be false.\r\n */\r\nexport function inRange(value: number, maximum: number): boolean;\r\n\r\n/**\r\n * Checks if the value is within the range defined by minimum (inclusive) and maximum (exclusive).\r\n *\r\n * @param {number} value The value to check.\r\n * @param {number} minimum The lower bound of the range (inclusive).\r\n * @param {number} maximum The upper bound of the range (exclusive).\r\n * @returns {boolean} `true` if the value is within the specified range, otherwise `false`.\r\n *\r\n * @example\r\n * const result = inRange(3, 2, 5); // result will be true.\r\n * const result2 = inRange(1, 2, 5); // result2 will be false.\r\n */\r\nexport function inRange(value: number, minimum: number, maximum: number): boolean;\r\n\r\n/**\r\n * Checks if the value is within a specified range.\r\n *\r\n * @param {number} value The value to check.\r\n * @param {number} minimum The lower bound of the range (inclusive).\r\n * @param {number} maximum The upper bound of the range (exclusive).\r\n * @returns {boolean} `true` if the value is within the specified range, otherwise `false`.\r\n * @throws {Error} Throws an error if the `minimum` is greater or equal than the `maximum`.\r\n *\r\n * @example\r\n * const result1 = inRange(3, 5); // result1 will be true.\r\n * const result2 = inRange(1, 2, 5); // result2 will be false.\r\n * const result3 = inRange(1, 5, 2); // If the minimum is greater or equal than the maximum, an error is thrown.\r\n */\r\nexport function inRange(value: number, minimum: number, maximum?: number): boolean {\r\n  if (!minimum) {\r\n    minimum = 0;\r\n  }\r\n\r\n  if (maximum != null && !maximum) {\r\n    maximum = 0;\r\n  }\r\n\r\n  if (minimum != null && typeof minimum !== 'number') {\r\n    minimum = Number(minimum);\r\n  }\r\n\r\n  if (maximum == null && minimum === 0) {\r\n    return false;\r\n  }\r\n\r\n  if (maximum != null && typeof maximum !== 'number') {\r\n    maximum = Number(maximum);\r\n  }\r\n\r\n  if (maximum != null && minimum > maximum) {\r\n    [minimum, maximum] = [maximum, minimum];\r\n  }\r\n\r\n  if (minimum === maximum) {\r\n    return false;\r\n  }\r\n\r\n  return inRangeToolkit(value, minimum, maximum!);\r\n}\r\n","/**\r\n * Checks if the value is less than the maximum.\r\n *\r\n * @param {number} value The value to check.\r\n * @param {number} maximum The upper bound of the range (exclusive).\r\n * @returns {boolean} `true` if the value is less than the maximum, otherwise `false`.\r\n *\r\n * @example\r\n * const result = inRange(3, 5); // result will be true.\r\n * const result2 = inRange(5, 5); // result2 will be false.\r\n */\r\nexport function inRange(value: number, maximum: number): boolean;\r\n\r\n/**\r\n * Checks if the value is within the range defined by minimum (inclusive) and maximum (exclusive).\r\n *\r\n * @param {number} value The value to check.\r\n * @param {number} minimum The lower bound of the range (inclusive).\r\n * @param {number} maximum The upper bound of the range (exclusive).\r\n * @returns {boolean} `true` if the value is within the specified range, otherwise `false`.\r\n *\r\n * @example\r\n * const result = inRange(3, 2, 5); // result will be true.\r\n * const result2 = inRange(1, 2, 5); // result2 will be false.\r\n */\r\nexport function inRange(value: number, minimum: number, maximum: number): boolean;\r\n\r\n/**\r\n * Checks if the value is within a specified range.\r\n *\r\n * @param {number} value The value to check.\r\n * @param {number} minimum The lower bound of the range (inclusive).\r\n * @param {number} maximum The upper bound of the range (exclusive).\r\n * @returns {boolean} `true` if the value is within the specified range, otherwise `false`.\r\n * @throws {Error} Throws an error if the `minimum` is greater or equal than the `maximum`.\r\n *\r\n * @example\r\n * const result1 = inRange(3, 5); // result1 will be true.\r\n * const result2 = inRange(1, 2, 5); // result2 will be false.\r\n * const result3 = inRange(1, 5, 2); // If the minimum is greater or equal than the maximum, an error is thrown.\r\n */\r\nexport function inRange(value: number, minimum: number, maximum?: number): boolean {\r\n  if (maximum == null) {\r\n    maximum = minimum;\r\n    minimum = 0;\r\n  }\r\n\r\n  if (minimum >= maximum) {\r\n    throw new Error('The maximum value must be greater than the minimum value.');\r\n  }\r\n\r\n  return minimum <= value && value < maximum;\r\n}\r\n","/**\r\n * Finds the index of the first occurrence of a value in an array.\r\n *\r\n * This method is similar to `Array.prototype.indexOf`, but it also finds `NaN` values.\r\n * It uses strict equality (`===`) to compare elements.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @template U - The type of the value to search for.\r\n * @param {T[] | null | undefined} array - The array to search.\r\n * @param {T} searchElement - The value to search for.\r\n * @param {number} [fromIndex] - The index to start the search at.\r\n * @returns {number} The index (zero-based) of the first occurrence of the value in the array, or `-1` if the value is not found.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, NaN];\r\n * indexOf(array, 3); // => 2\r\n * indexOf(array, NaN); // => 3\r\n */\r\nexport function indexOf<T>(array: readonly T[] | null | undefined, searchElement: T, fromIndex?: number): number {\r\n  if (array == null) {\r\n    return -1;\r\n  }\r\n\r\n  // `Array.prototype.indexOf` doesn't find `NaN` values, so we need to handle that case separately.\r\n  if (Number.isNaN(searchElement)) {\r\n    fromIndex = fromIndex ?? 0;\r\n\r\n    if (fromIndex < 0) {\r\n      fromIndex = Math.max(0, array.length + fromIndex);\r\n    }\r\n\r\n    for (let i = fromIndex; i < array.length; i++) {\r\n      if (Number.isNaN(array[i])) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  // Array.prototype.indexOf already handles `fromIndex < -array.length`, `fromIndex >= array.length` and converts `fromIndex` to an integer, so we don't need to handle those cases here.\r\n  // And it uses strict equality (===) to compare elements like `lodash/indexOf` does.\r\n  return array.indexOf(searchElement as T, fromIndex);\r\n}\r\n","/**\r\n * Returns an empty array when the input is a tuple containing exactly one element.\r\n *\r\n * @template T The type of the single element.\r\n * @param {[T]} arr - A tuple containing exactly one element.\r\n * @returns {[]} An empty array since there is only one element.\r\n *\r\n * @example\r\n * const array = [100] as const;\r\n * const result = initial(array);\r\n * // result will be []\r\n */\r\nexport function initial<T>(arr: readonly [T]): [];\r\n\r\n/**\r\n * Returns an empty array when the input array is empty.\r\n *\r\n * @returns {[]} Always returns an empty array for an empty input.\r\n *\r\n * @example\r\n * const array = [] as const;\r\n * const result = initial(array);\r\n * // result will be []\r\n */\r\nexport function initial(arr: readonly []): [];\r\n\r\n/**\r\n * Returns a new array containing all elements except the last one from a tuple with multiple elements.\r\n *\r\n * @template T The types of the initial elements.\r\n * @template U The type of the last element in the tuple.\r\n * @param {[...T[], U]} arr - A tuple with one or more elements.\r\n * @returns {T[]} A new array containing all but the last element of the tuple.\r\n *\r\n * @example\r\n * const array = ['apple', 'banana', 'cherry'] as const;\r\n * const result = initial(array);\r\n * // result will be ['apple', 'banana']\r\n */\r\nexport function initial<T, U>(arr: readonly [...T[], U]): T[];\r\n\r\n/**\r\n * Returns a new array containing all elements except the last one from the input array.\r\n * If the input array is empty or has only one element, the function returns an empty array.\r\n *\r\n * @template T The type of elements in the array.\r\n * @param {T[]} arr - The input array.\r\n * @returns {T[]} A new array containing all but the last element of the input array.\r\n *\r\n * @example\r\n * const arr = [1, 2, 3, 4];\r\n * const result = initial(arr);\r\n * // result will be [1, 2, 3]\r\n */\r\nexport function initial<T>(arr: readonly T[]): T[];\r\n\r\n/**\r\n * Returns a new array containing all elements except the last one from the input array.\r\n * If the input array is empty or has only one element, the function returns an empty array.\r\n *\r\n * @template T The type of elements in the array.\r\n * @param {T[]} arr - The input array.\r\n * @returns {T[]} A new array containing all but the last element of the input array.\r\n *\r\n * @example\r\n * const arr = [1, 2, 3, 4];\r\n * const result = initial(arr);\r\n * // result will be [1, 2, 3]\r\n */\r\nexport function initial<T>(arr: readonly T[]): T[] {\r\n  return arr.slice(0, -1);\r\n}\r\n","/**\r\n * Inverts the keys and values of an object. The keys of the input object become the values of the output object and vice versa.\r\n *\r\n * This function takes an object and creates a new object by inverting its keys and values. If the input object has duplicate values,\r\n * the key of the last occurrence will be used as the value for the new key in the output object. It effectively creates a reverse mapping\r\n * of the input object's key-value pairs.\r\n *\r\n * @template K - Type of the keys in the input object (string, number, symbol)\r\n * @template V - Type of the values in the input object (string, number, symbol)\r\n * @param {Record<K, V>} obj - The input object whose keys and values are to be inverted\r\n * @returns {Record<V, K>} - A new object with keys and values inverted\r\n *\r\n * @example\r\n * invert({ a: 1, b: 2, c: 3 }); // { 1: 'a', 2: 'b', 3: 'c' }\r\n * invert({ 1: 'a', 2: 'b', 3: 'c' }); // { a: '1', b: '2', c: '3' }\r\n * invert({ a: 1, 2: 'b', c: 3, 4: 'd' }); // { 1: 'a', b: '2', 3: 'c', d: '4' }\r\n * invert({ a: Symbol('sym1'), b: Symbol('sym2') }); // { [Symbol('sym1')]: 'a', [Symbol('sym2')]: 'b' }\r\n */\r\nexport function invert<K extends PropertyKey, V extends PropertyKey>(obj: Record<K, V>): Record<V, K> {\r\n  const result = {} as Record<V, K>;\r\n\r\n  const keys = Object.keys(obj) as K[];\r\n\r\n  for (let i = 0; i < keys.length; i++) {\r\n    const key = keys[i];\r\n    const value = obj[key];\r\n    result[value] = key;\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Checks if the given value is an array.\r\n *\r\n * This function tests whether the provided value is an array or not.\r\n * It returns `true` if the value is an array, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an array.\r\n *\r\n * @param {unknown} value - The value to test if it is an array.\r\n * @returns {value is any[]} `true` if the value is an array, `false` otherwise.\r\n *\r\n * @example\r\n * const value1 = [1, 2, 3];\r\n * const value2 = 'abc';\r\n * const value3 = () => {};\r\n *\r\n * console.log(isArray(value1)); // true\r\n * console.log(isArray(value2)); // false\r\n * console.log(isArray(value3)); // false\r\n */\r\nexport function isArray(value?: unknown): value is any[] {\r\n  return Array.isArray(value);\r\n}\r\n","import { isArrayLike } from './isArrayLike';\r\nimport { isObjectLike } from './isObjectLike';\r\n\r\n/**\r\n * Checks if the given value is a non-primitive, array-like object.\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {value is ArrayLike<unknown> & object} `true` if the value is a non-primitive, array-like object, `false` otherwise.\r\n *\r\n * @example\r\n * isArrayLikeObject([1, 2, 3]); // true\r\n * isArrayLikeObject({ 0: 'a', length: 1 }); // true\r\n * isArrayLikeObject('abc'); // false\r\n * isArrayLikeObject(()=>{}); // false\r\n */\r\nexport function isArrayLikeObject(value: unknown): value is ArrayLike<unknown> & object {\r\n  return isObjectLike(value) && isArrayLike(value);\r\n}\r\n","import { getTag } from '../_internal/getTag.ts';\r\n\r\n/**\r\n * Checks if the given value is boolean.\r\n *\r\n * This function tests whether the provided value is strictly `boolean`.\r\n * It returns `true` if the value is `boolean`, and `false` otherwise.\r\n *\r\n *  This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `boolean`.\r\n *\r\n * @param {unknown} x - The Value to test if it is boolean.\r\n * @returns {x is boolean} True if the value is boolean, false otherwise.\r\n *\r\n * @example\r\n *\r\n * const value1 = true;\r\n * const value2 = 0;\r\n * const value3 = 'abc';\r\n *\r\n * console.log(isBoolean(value1)); // true\r\n * console.log(isBoolean(value2)); // false\r\n * console.log(isBoolean(value3)); // false\r\n *\r\n */\r\nexport function isBoolean(x: unknown): x is boolean {\r\n  if (x === true || x === false) {\r\n    return true;\r\n  }\r\n\r\n  if (typeof x === 'object' && x != null && getTag(x) === '[object Boolean]') {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n","/**\r\n * Checks if `value` is a Date object.\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {value is Date} Returns `true` if `value` is a Date object, `false` otherwise.\r\n *\r\n * @example\r\n * const value1 = new Date();\r\n * const value2 = '2024-01-01';\r\n *\r\n * console.log(isDate(value1)); // true\r\n * console.log(isDate(value2)); // false\r\n */\r\nexport function isDate(value: unknown): value is Date {\r\n  return value instanceof Date;\r\n}\r\n","/**\r\n * Checks if `value` is a function.\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\r\n *\r\n * @example\r\n * isFunction(Array.prototype.slice); // true\r\n * isFunction(async function () {}); // true\r\n * isFunction(function* () {}); // true\r\n * isFunction(Proxy); // true\r\n * isFunction(Int8Array); // true\r\n */\r\nexport function isFunction(value: unknown): value is (...args: unknown[]) => unknown {\r\n  return typeof value === 'function';\r\n}\r\n","/**\r\n * Checks if `value` is an integer.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `number`.\r\n *\r\n * @param {unknown} value - The value to check\r\n * @returns {boolean} `true` if `value` is integer, otherwise `false`.\r\n *\r\n * @example\r\n * isInteger(3); // Returns: true\r\n * isInteger(Infinity); // Returns: false\r\n * isInteger('3'); // Returns: false\r\n * isInteger([]); // Returns: false\r\n */\r\nexport function isInteger(value?: unknown): value is number {\r\n  return Number.isInteger(value);\r\n}\r\n","/**\r\n * Checks if the value is NaN.\r\n *\r\n * @param {unknown} value - The value to check.\r\n * @returns {value is typeof NaN} `true` if the value is NaN, `false` otherwise.\r\n *\r\n * @example\r\n * isNaN(NaN); // true\r\n * isNaN(0); // false\r\n * isNaN('NaN'); // false\r\n * isNaN(undefined); // false\r\n */\r\nexport function isNaN(value: unknown): value is typeof NaN {\r\n  return Number.isNaN(value);\r\n}\r\n","/**\r\n * Checks if the given value is not null nor undefined.\r\n *\r\n * The main use of this function is to be used with TypeScript as a type predicate.\r\n *\r\n * @template T - The type of value.\r\n * @param {T | null | undefined} x - The value to test if it is not null nor undefined.\r\n * @returns {x is T} True if the value is not null nor undefined, false otherwise.\r\n *\r\n * @example\r\n * // Here the type of `arr` is (number | undefined)[]\r\n * const arr = [1, undefined, 3];\r\n * // Here the type of `result` is number[]\r\n * const result = arr.filter(isNotNil);\r\n * // result will be [1, 3]\r\n */\r\nexport function isNotNil<T>(x: T | null | undefined): x is T {\r\n  return x != null;\r\n}\r\n","/**\r\n * Checks if the given value is null.\r\n *\r\n * This function tests whether the provided value is strictly equal to `null`.\r\n * It returns `true` if the value is `null`, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null`.\r\n *\r\n * @param {unknown} x - The value to test if it is null.\r\n * @returns {x is null} True if the value is null, false otherwise.\r\n *\r\n * @example\r\n * const value1 = null;\r\n * const value2 = undefined;\r\n * const value3 = 42;\r\n *\r\n * console.log(isNull(value1)); // true\r\n * console.log(isNull(value2)); // false\r\n * console.log(isNull(value3)); // false\r\n */\r\nexport function isNull(x: unknown): x is null {\r\n  return x === null;\r\n}\r\n","import { getTag } from '../_internal/getTag';\r\n\r\n/**\r\n * Checks if a given value is a number.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `number`.\r\n *\r\n * @param {unknown} value The value to check if it is a number.\r\n * @returns {value is number} Returns `true` if `value` is a number, else `false`.\r\n *\r\n * @example\r\n * const value1 = 123;\r\n * const value2 = 'abc';\r\n * const value3 = true;\r\n *\r\n * console.log(isNumber(value1)); // true\r\n * console.log(isNumber(value2)); // false\r\n * console.log(isNumber(value3)); // false\r\n */\r\nexport function isNumber(value?: unknown): value is number {\r\n  if (typeof value === 'object' && value != null && getTag(value) === '[object Number]') {\r\n    return true;\r\n  }\r\n\r\n  return typeof value === 'number';\r\n}\r\n","/**\r\n * Checks if the given value is an object. An object is a value that is\r\n * not a primitive type (string, number, boolean, symbol, null, or undefined).\r\n *\r\n * This function tests whether the provided value is an object or not.\r\n * It returns `true` if the value is an object, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an object value.\r\n *\r\n * @param {unknown} value - The value to check if it is an object.\r\n * @returns {value is object} `true` if the value is an object, `false` otherwise.\r\n *\r\n * @example\r\n * const value1 = {};\r\n * const value2 = [1, 2, 3];\r\n * const value3 = () => {};\r\n * const value4 = null;\r\n *\r\n * console.log(isObject(value1)); // true\r\n * console.log(isObject(value2)); // true\r\n * console.log(isObject(value3)); // true\r\n * console.log(isObject(value4)); // false\r\n */\r\n\r\nexport function isObject(value: unknown): value is object {\r\n  return value !== null && (typeof value === 'object' || typeof value === 'function');\r\n}\r\n","import { getTag } from '../_internal/getTag.ts';\r\n\r\n/**\r\n * Checks if `value` is a RegExp.\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a RegExp, `false` otherwise.\r\n *\r\n * @example\r\n * const value1 = /abc/;\r\n * const value2 = '/abc/';\r\n *\r\n * console.log(isRegExp(value1)); // true\r\n * console.log(isRegExp(value2)); // false\r\n */\r\nexport function isRegExp(value?: unknown): value is RegExp {\r\n  return getTag(value) === '[object RegExp]';\r\n}\r\n","/**\r\n * Checks if `value` is a safe integer (between -(2^53  1) and (2^53  1), inclusive).\r\n *\r\n * A safe integer is an integer that can be precisely represented as a `number` in JavaScript,\r\n * without any other integer being rounded to it.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `number`.\r\n *\r\n * @param {unknown} value - The value to check\r\n * @returns {boolean} `true` if `value` is an integer and between the safe values, otherwise `false`\r\n *\r\n * @example\r\n * isSafeInteger(3); // Returns: true\r\n * isSafeInteger(Number.MIN_SAFE_INTEGER - 1); // Returns: false\r\n * isSafeInteger(1n); // Returns: false\r\n * isSafeInteger('1'); // Returns: false\r\n */\r\nexport function isSafeInteger(value?: unknown): value is number {\r\n  return Number.isSafeInteger(value);\r\n}\r\n","import { getTag } from '../_internal/getTag.ts';\r\n\r\n/**\r\n * Checks if a given value is string.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `string`.\r\n *\r\n * @param {unknown} value The value to check if it is string.\r\n * @returns {value is string} Returns `true` if `value` is a string, else `false`.\r\n *\r\n * @example\r\n * const value1 = 'abc';\r\n * const value2 = 123;\r\n * const value3 = true;\r\n *\r\n * console.log(isString(value1)); // true\r\n * console.log(isString(value2)); // false\r\n * console.log(isString(value3)); // false\r\n */\r\n\r\nexport function isString(value: unknown): value is string {\r\n  if (typeof value === 'string') {\r\n    return true;\r\n  }\r\n\r\n  if (typeof value === 'object' && value != null && getTag(value) === '[object String]') {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n","import { difference } from '../array/difference.ts';\r\n\r\n/**\r\n * Checks if the `subset` array is entirely contained within the `superset` array.\r\n *\r\n *\r\n * @template T - The type of elements contained in the arrays.\r\n * @param {T[]} superset - The array that may contain all elements of the subset.\r\n * @param {T[]} subset - The array to check against the superset.\r\n * @returns {boolean} - Returns `true` if all elements of the `subset` are present in the `superset`, otherwise returns `false`.\r\n *\r\n * @example\r\n * ```typescript\r\n * const superset = [1, 2, 3, 4, 5];\r\n * const subset = [2, 3, 4];\r\n * isSubset(superset, subset); // true\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * const superset = ['a', 'b', 'c'];\r\n * const subset = ['a', 'd'];\r\n * isSubset(superset, subset); // false\r\n * ```\r\n */\r\n\r\nexport function isSubset<T>(superset: readonly T[], subset: readonly T[]): boolean {\r\n  return difference(subset, superset).length === 0;\r\n}\r\n","/**\r\n * Checks if the given value is undefined.\r\n *\r\n * This function tests whether the provided value is strictly equal to `undefined`.\r\n * It returns `true` if the value is `undefined`, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `undefined`.\r\n *\r\n * @param {unknown} x - The value to test if it is undefined.\r\n * @returns {x is undefined} true if the value is undefined, false otherwise.\r\n *\r\n * @example\r\n * const value1 = undefined;\r\n * const value2 = null;\r\n * const value3 = 42;\r\n *\r\n * console.log(isUndefined(value1)); // true\r\n * console.log(isUndefined(value2)); // false\r\n * console.log(isUndefined(value3)); // false\r\n */\r\nexport function isUndefined(x: unknown): x is undefined {\r\n  return x === undefined;\r\n}\r\n","import { isWeakMap as isWeakMapToolkit } from '../../predicate/isWeakMap.ts';\r\n\r\n/**\r\n * Checks if the given value is a `WeakMap`.\r\n *\r\n * This function tests whether the provided value is an instance of `WeakMap`.\r\n * It returns `true` if the value is a `WeakMap`, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `WeakMap`.\r\n *\r\n * @param {unknown} value - The value to test if it is a `WeakMap`.\r\n * @returns {value is WeakMap<WeakKey, any>} true if the value is a `WeakMap`, false otherwise.\r\n *\r\n * @example\r\n * const value1 = new WeakMap();\r\n * const value2 = new Map();\r\n * const value3 = new Set();\r\n *\r\n * console.log(isWeakMap(value1)); // true\r\n * console.log(isWeakMap(value2)); // false\r\n * console.log(isWeakMap(value3)); // false\r\n */\r\nexport function isWeakMap(value?: unknown): value is WeakMap<WeakKey, any> {\r\n  return isWeakMapToolkit(value);\r\n}\r\n","/**\r\n * Checks if the given value is a `WeakMap`.\r\n *\r\n * This function tests whether the provided value is an instance of `WeakMap`.\r\n * It returns `true` if the value is a `WeakMap`, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `WeakMap`.\r\n *\r\n * @param {unknown} value - The value to test if it is a `WeakMap`.\r\n * @returns {value is WeakMap<WeakKey, any>} true if the value is a `WeakMap`, false otherwise.\r\n *\r\n * @example\r\n * const value1 = new WeakMap();\r\n * const value2 = new Map();\r\n * const value3 = new Set();\r\n *\r\n * console.log(isWeakMap(value1)); // true\r\n * console.log(isWeakMap(value2)); // false\r\n * console.log(isWeakMap(value3)); // false\r\n */\r\nexport function isWeakMap(value: unknown): value is WeakMap<WeakKey, any> {\r\n  return value instanceof WeakMap;\r\n}\r\n","import { isWeakSet as isWeakSetToolkit } from '../../predicate/isWeakSet.ts';\r\n\r\n/**\r\n * Checks if the given value is a `WeakSet`.\r\n *\r\n * This function tests whether the provided value is an instance of `WeakSet`.\r\n * It returns `true` if the value is a `WeakSet`, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `WeakSet`.\r\n *\r\n * @param {unknown} value - The value to test if it is a `WeakSet`.\r\n * @returns {value is WeakSet<WeakKey>} true if the value is a `WeakSet`, false otherwise.\r\n *\r\n * @example\r\n * const value1 = new WeakSet();\r\n * const value2 = new Map();\r\n * const value3 = new Set();\r\n *\r\n * console.log(isWeakSet(value1)); // true\r\n * console.log(isWeakSet(value2)); // false\r\n * console.log(isWeakSet(value3)); // false\r\n */\r\nexport function isWeakSet(value?: unknown): value is WeakSet<WeakKey> {\r\n  return isWeakSetToolkit(value);\r\n}\r\n","/**\r\n * Checks if the given value is a `WeakSet`.\r\n *\r\n * This function tests whether the provided value is an instance of `WeakSet`.\r\n * It returns `true` if the value is a `WeakSet`, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `WeakSet`.\r\n *\r\n * @param {unknown} value - The value to test if it is a `WeakSet`.\r\n * @returns {value is WeakSet<WeakKey>} true if the value is a `WeakSet`, false otherwise.\r\n *\r\n * @example\r\n * const value1 = new WeakSet();\r\n * const value2 = new Map();\r\n * const value3 = new Set();\r\n *\r\n * console.log(isWeakSet(value1)); // true\r\n * console.log(isWeakSet(value2)); // false\r\n * console.log(isWeakSet(value3)); // false\r\n */\r\nexport function isWeakSet(value: unknown): value is WeakSet<WeakKey> {\r\n  return value instanceof WeakSet;\r\n}\r\n","/**\r\n * Joins elements of an array into a string.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} array - The array to join.\r\n * @param {string} separator - The separator used to join the elements, default is common separator `,`.\r\n * @returns {string} - Returns a string containing all elements of the array joined by the specified separator.\r\n *\r\n * @example\r\n * const arr = [\"a\", \"b\", \"c\"];\r\n * const result = join(arr, \"~\");\r\n * console.log(result); // Output: \"a~b~c\"\r\n */\r\nexport function join<T>(array: readonly T[], separator = ','): string {\r\n  return array.join(separator);\r\n}\r\n","import { kebabCase as kebabCaseToolkit } from '../../string/kebabCase.ts';\r\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\r\n\r\n/**\r\n * Converts a string to kebab case.\r\n *\r\n * Kebab case is the naming convention in which each word is written in lowercase and separated by a dash (-) character.\r\n *\r\n * @param {string | object} str - The string that is to be changed to kebab case.\r\n * @returns {string} - The converted string to kebab case.\r\n *\r\n * @example\r\n * const convertedStr1 = kebabCase('camelCase') // returns 'camel-case'\r\n * const convertedStr2 = kebabCase('some whitespace') // returns 'some-whitespace'\r\n * const convertedStr3 = kebabCase('hyphen-text') // returns 'hyphen-text'\r\n * const convertedStr4 = kebabCase('HTTPRequest') // returns 'http-request'\r\n */\r\nexport function kebabCase(str?: string | object): string {\r\n  return kebabCaseToolkit(normalizeForCase(str));\r\n}\r\n","import { getWords } from './_internal/getWords.ts';\r\n\r\n/**\r\n * Converts a string to kebab case.\r\n *\r\n * Kebab case is the naming convention in which each word is written in lowercase and separated by a dash (-) character.\r\n *\r\n * @param {string} str - The string that is to be changed to kebab case.\r\n * @returns {string} - The converted string to kebab case.\r\n *\r\n * @example\r\n * const convertedStr1 = kebabCase('camelCase') // returns 'camel-case'\r\n * const convertedStr2 = kebabCase('some whitespace') // returns 'some-whitespace'\r\n * const convertedStr3 = kebabCase('hyphen-text') // returns 'hyphen-text'\r\n * const convertedStr4 = kebabCase('HTTPRequest') // returns 'http-request'\r\n */\r\n\r\nexport function kebabCase(str: string): string {\r\n  const words = getWords(str);\r\n  return words.map(word => word.toLowerCase()).join('-');\r\n}\r\n","/**\r\n * Maps each element of an array based on a provided key-generating function.\r\n *\r\n * This function takes an array and a function that generates a key from each element. It returns\r\n * an object where the keys are the generated keys and the values are the corresponding elements.\r\n * If there are multiple elements generating the same key, the last element among them is used\r\n * as the value.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @template K - The type of keys.\r\n * @param {T[]} arr - The array of elements to be mapped.\r\n * @param {(item: T) => K} getKeyFromItem - A function that generates a key from an element.\r\n * @returns {Record<K, T>} An object where keys are mapped to each element of an array.\r\n *\r\n * @example\r\n * const array = [\r\n *   { category: 'fruit', name: 'apple' },\r\n *   { category: 'fruit', name: 'banana' },\r\n *   { category: 'vegetable', name: 'carrot' }\r\n * ];\r\n * const result = keyBy(array, item => item.category);\r\n * // result will be:\r\n * // {\r\n * //   fruit: { category: 'fruit', name: 'banana' },\r\n * //   vegetable: { category: 'vegetable', name: 'carrot' }\r\n * // }\r\n */\r\nexport function keyBy<T, K extends PropertyKey>(arr: readonly T[], getKeyFromItem: (item: T) => K): Record<K, T> {\r\n  const result = {} as Record<K, T>;\r\n\r\n  for (const item of arr) {\r\n    const key = getKeyFromItem(item);\r\n    result[key] = item;\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Returns the last element of an array.\r\n *\r\n * This function takes an array and returns the last element of the array.\r\n * If the array is empty, the function returns `undefined`.\r\n *\r\n * Unlike some implementations, this function is optimized for performance\r\n * by directly accessing the last index of the array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {[...T[], T]} arr - The array from which to get the last element.\r\n * @returns {T} The last element of the array, or `undefined` if the array is empty.\r\n *\r\n * @example\r\n * const arr = [1, 2, 3];\r\n * const lastElement = last(arr);\r\n * // lastElement will be 3\r\n *\r\n * const emptyArr: number[] = [];\r\n * const noElement = last(emptyArr);\r\n * // noElement will be undefined\r\n */\r\nexport function last<T>(arr: readonly [...T[], T]): T;\r\n\r\n/**\r\n * Returns the last element of an array.\r\n *\r\n * This function takes an array and returns the last element of the array.\r\n * If the array is empty, the function returns `undefined`.\r\n *\r\n * Unlike some implementations, this function is optimized for performance\r\n * by directly accessing the last index of the array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array from which to get the last element.\r\n * @returns {T | undefined} The last element of the array, or `undefined` if the array is empty.\r\n *\r\n * @example\r\n * const arr = [1, 2, 3];\r\n * const lastElement = last(arr);\r\n * // lastElement will be 3\r\n *\r\n * const emptyArr: number[] = [];\r\n * const noElement = last(emptyArr);\r\n * // noElement will be undefined\r\n */\r\nexport function last<T>(arr: readonly T[]): T | undefined;\r\n\r\n/**\r\n * Returns the last element of an array.\r\n *\r\n * This function takes an array and returns the last element of the array.\r\n * If the array is empty, the function returns `undefined`.\r\n *\r\n * Unlike some implementations, this function is optimized for performance\r\n * by directly accessing the last index of the array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array from which to get the last element.\r\n * @returns {T | undefined} The last element of the array, or `undefined` if the array is empty.\r\n *\r\n * @example\r\n * const arr = [1, 2, 3];\r\n * const lastElement = last(arr);\r\n * // lastElement will be 3\r\n *\r\n * const emptyArr: number[] = [];\r\n * const noElement = last(emptyArr);\r\n * // noElement will be undefined\r\n */\r\nexport function last<T>(arr: readonly T[]): T | undefined {\r\n  return arr[arr.length - 1];\r\n}\r\n","import { lowerCase as lowerCaseToolkit } from '../../string/lowerCase.ts';\r\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\r\n\r\n/**\r\n * Converts a string to lower case.\r\n *\r\n * Lower case is the naming convention in which each word is written in lowercase and separated by an space ( ) character.\r\n *\r\n * @param {string | object} str - The string that is to be changed to lower case.\r\n * @returns {string} - The converted string to lower case.\r\n *\r\n * @example\r\n * const convertedStr1 = lowerCase('camelCase') // returns 'camel case'\r\n * const convertedStr2 = lowerCase('some whitespace') // returns 'some whitespace'\r\n * const convertedStr3 = lowerCase('hyphen-text') // returns 'hyphen text'\r\n * const convertedStr4 = lowerCase('HTTPRequest') // returns 'http request'\r\n */\r\nexport function lowerCase(str?: string | object): string {\r\n  return lowerCaseToolkit(normalizeForCase(str));\r\n}\r\n","import { getWords } from './_internal/getWords.ts';\r\n\r\n/**\r\n * Converts a string to lower case.\r\n *\r\n * Lower case is the naming convention in which each word is written in lowercase and separated by an space ( ) character.\r\n *\r\n * @param {string} str - The string that is to be changed to lower case.\r\n * @returns {string} - The converted string to lower case.\r\n *\r\n * @example\r\n * const convertedStr1 = lowerCase('camelCase') // returns 'camel case'\r\n * const convertedStr2 = lowerCase('some whitespace') // returns 'some whitespace'\r\n * const convertedStr3 = lowerCase('hyphen-text') // returns 'hyphen text'\r\n * const convertedStr4 = lowerCase('HTTPRequest') // returns 'http request'\r\n */\r\nexport function lowerCase(str: string): string {\r\n  const words = getWords(str);\r\n  return words.map(word => word.toLowerCase()).join(' ');\r\n}\r\n","/**\r\n * Converts the first character of string to lower case.\r\n *\r\n * @param {string} str - The string that is to be changed\r\n * @returns {string} - The converted string.\r\n *\r\n * @example\r\n * const convertedStr1 = lowerCase('fred') // returns 'fred'\r\n * const convertedStr2 = lowerCase('Fred') // returns 'fred'\r\n * const convertedStr3 = lowerCase('FRED') // returns 'fRED'\r\n */\r\nexport function lowerFirst(str: string): string {\r\n  return str.substring(0, 1).toLowerCase() + str.substring(1);\r\n}\r\n","import { mapKeys as mapKeysToolkit } from '../../object/mapKeys.ts';\r\nimport { identity } from '../_internal/identity.ts';\r\nimport { property } from './property.ts';\r\n\r\n/**\r\n * Creates a new object with the same values as the given object, but with keys generated\r\n * by running each own enumerable property of the object through the iteratee function.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the keys in the object.\r\n *\r\n * @param {T} object - The object to iterate over.\r\n * @param {PropertyKey | PropertyKey[]} getNewKey - The path of the property to get to generate the new keys.\r\n * @returns {Record<PropertyKey, T[K1]>} - Returns the new mapped object.\r\n *\r\n * @example\r\n * // Example usage:\r\n * const obj = { a: 1, b: 2 };\r\n * const result = mapKeys(obj, (value, key) => key + value);\r\n * console.log(result); // { a1: 1, b2: 2 }\r\n */\r\nexport function mapKeys<T extends object>(\r\n  object: T,\r\n  getNewKey?: PropertyKey | readonly PropertyKey[]\r\n): Record<PropertyKey, T[keyof T]>;\r\n\r\n/**\r\n * Creates a new object with the same values as the given object, but with keys generated\r\n * by running each own enumerable property of the object through the iteratee function.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the keys in the object.\r\n * @template K2 - The type of the new keys generated by the iteratee function.\r\n *\r\n * @param {T} object - The object to iterate over.\r\n * @param {(value: T[K1], key: K1, object: T) => K2} getNewKey - The function invoked per own enumerable property.\r\n * @returns {Record<K2, T[K1]>} - Returns the new mapped object.\r\n *\r\n * @example\r\n * // Example usage:\r\n * const obj = { a: 1, b: 2 };\r\n * const result = mapKeys(obj, (value, key) => key + value);\r\n * console.log(result); // { a1: 1, b2: 2 }\r\n */\r\nexport function mapKeys<T extends object, K1 extends keyof T, K2 extends PropertyKey>(\r\n  object: T,\r\n  getNewKey?: (value: T[K1], key: K1, object: T) => K2\r\n): Record<K2, T[K1]>;\r\n\r\n/**\r\n * Creates a new object with the same values as the given object, but with keys generated\r\n * by running each own enumerable property of the object through the iteratee function.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the keys in the object.\r\n * @template K2 - The type of the new keys generated by the iteratee function.\r\n *\r\n * @param {T} object - The object to iterate over.\r\n * @param {(value: T[K1], key: K1, object: T) => K2} [getNewKey] - The function invoked per own enumerable property, or a path to generate new keys.\r\n * @returns {Record<K2, T[K1]>} - Returns the new mapped object.\r\n *\r\n * @example\r\n * // Example usage:\r\n * const obj = { a: 1, b: 2 };\r\n * const result = mapKeys(obj, (value, key) => key + value);\r\n * console.log(result); // { a1: 1, b2: 2 }\r\n */\r\nexport function mapKeys<T extends object, K1 extends keyof T, K2 extends PropertyKey>(\r\n  object: T,\r\n  getNewKey?: PropertyKey | readonly PropertyKey[] | ((value: T[K1], key: K1, object: T) => K2)\r\n): Record<K2, T[K1]> {\r\n  getNewKey = getNewKey ?? (identity as (value: T[K1], key: K1, object: T) => K2);\r\n\r\n  switch (typeof getNewKey) {\r\n    case 'string':\r\n    case 'symbol':\r\n    case 'number':\r\n    case 'object': {\r\n      return mapKeysToolkit(object, property(getNewKey));\r\n    }\r\n    case 'function': {\r\n      return mapKeysToolkit(object, getNewKey);\r\n    }\r\n  }\r\n}\r\n","import { mapValues as mapValuesToolkit } from '../../object/mapValues.ts';\r\nimport { identity } from '../_internal/identity.ts';\r\nimport { property } from './property.ts';\r\n\r\n/**\r\n * Creates a new object with the same keys as the given object, but with values generated\r\n * by running each own enumerable property of the object through the iteratee function.\r\n *\r\n * @template T - The type of the object.\r\n * @template K - The type of the keys in the object.\r\n * @template V - The type of the new values generated by the iteratee function.\r\n *\r\n * @param {T} object - The object to iterate over.\r\n * @param {(value: T[K], key: K, object: T) => V} getNewValue - The function invoked per own enumerable property.\r\n * @returns {Record<K, V>} - Returns the new mapped object.\r\n *\r\n * @example\r\n * // Example usage:\r\n * const obj = { a: 1, b: 2 };\r\n * const result = mapValues(obj, (value) => value * 2);\r\n * console.log(result); // { a: 2, b: 4 }\r\n */\r\nexport function mapValues<T extends object, K extends keyof T, V>(\r\n  object: T,\r\n  getNewValue?: PropertyKey | readonly PropertyKey[] | null | undefined\r\n): Record<K, V>;\r\n\r\n/**\r\n * Creates a new object with the same keys as the given object, but with values generated\r\n * by running each own enumerable property of the object through the iteratee function.\r\n *\r\n * @template T - The type of the object.\r\n * @template K - The type of the keys in the object.\r\n * @template V - The type of the new values generated by the iteratee function.\r\n *\r\n * @param {T} object - The object to iterate over.\r\n * @param {(value: T[K], key: K, object: T) => V} getNewValue - The function invoked per own enumerable property.\r\n * @returns {Record<K, V>} - Returns the new mapped object.\r\n *\r\n * @example\r\n * // Example usage:\r\n * const obj = { a: 1, b: 2 };\r\n * const result = mapValues(obj, (value) => value * 2);\r\n * console.log(result); // { a: 2, b: 4 }\r\n */\r\nexport function mapValues<T extends object, K extends keyof T, V>(\r\n  object: T,\r\n  getNewValue: (value: T[K], key: K, object: T) => V\r\n): Record<K, V>;\r\n\r\n/**\r\n * Creates a new object with the same keys as the given object, but with values generated\r\n * by running each own enumerable property of the object through the iteratee function.\r\n *\r\n * @template T - The type of the object.\r\n * @template K - The type of the keys in the object.\r\n * @template V - The type of the new values generated by the iteratee function.\r\n *\r\n * @param {T} object - The object to iterate over.\r\n * @param {(value: T[K], key: K, object: T) => V | PropertyKey | readonly PropertyKey[] | null | undefined} [getNewValue] -\r\n *        The function invoked per own enumerable property, or a path to generate new values.\r\n * @returns {Record<K, V>} - Returns the new mapped object.\r\n *\r\n * @example\r\n * // Example usage:\r\n * const obj = { a: 1, b: 2 };\r\n * const result = mapValues(obj, (value) => value * 2);\r\n * console.log(result); // { a: 2, b: 4 }\r\n */\r\nexport function mapValues<T extends object, K extends keyof T, V>(\r\n  object: T,\r\n  getNewValue?: PropertyKey | readonly PropertyKey[] | null | undefined | ((value: T[K], key: K, object: T) => V)\r\n): Record<K, V> {\r\n  getNewValue = getNewValue ?? (identity as (value: T[K], key: K, object: T) => V);\r\n\r\n  switch (typeof getNewValue) {\r\n    case 'string':\r\n    case 'symbol':\r\n    case 'number':\r\n    case 'object': {\r\n      return mapValuesToolkit(object, property(getNewValue));\r\n    }\r\n    case 'function': {\r\n      return mapValuesToolkit(object, getNewValue);\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Finds the element in an array that has the maximum value.\r\n *\r\n * @param {[T, ...T[]]} items - The array of elements to search.\r\n * @returns {T | undefined} - The element with the maximum value, or undefined if the array is empty.\r\n * @example\r\n * // Returns 9\r\n * max([3, 1, 4, 1, 5, 9]);\r\n *\r\n * @example\r\n * // Returns 8\r\n * max([0, -3, 2, 8, 7]);\r\n */\r\nexport function max<T>(items: readonly [T, ...T[]]): T;\r\n/**\r\n * Finds the element in an array that has the maximum value.\r\n * Returns undefined when no arguments are provided.\r\n * @returns {undefined}\r\n */\r\nexport function max(): undefined;\r\n/**\r\n * Finds the element in an array that has the maximum value.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} [items] - The array of elements to search. Defaults to an empty array.\r\n * @returns {T | undefined} - The element with the maximum value, or undefined if the array is empty.\r\n */\r\nexport function max<T>(items?: readonly T[]): T | undefined;\r\n/**\r\n * Finds the element in an array that has the maximum value.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} [items] - The array of elements to search. Defaults to an empty array.\r\n * @returns {T | undefined} - The element with the maximum value, or undefined if the array is empty.\r\n */\r\nexport function max<T>(items: readonly T[] = []): T | undefined {\r\n  let maxElement = items[0];\r\n  let max: any = undefined;\r\n\r\n  for (const element of items) {\r\n    if (max == null || element > max) {\r\n      max = element;\r\n      maxElement = element;\r\n    }\r\n  }\r\n\r\n  return maxElement;\r\n}\r\n","/**\r\n * Finds the element in an array that has the maximum value when applying\r\n * the `getValue` function to each element.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {[T, ...T[]]} items The nonempty array of elements to search.\r\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\r\n * @returns {T} The element with the maximum value as determined by the `getValue` function.\r\n * @example\r\n * maxBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 3 }\r\n * maxBy([], x => x.a); // Returns: undefined\r\n */\r\nexport function maxBy<T>(items: readonly [T, ...T[]], getValue: (element: T) => number): T;\r\n/**\r\n * Finds the element in an array that has the maximum value when applying\r\n * the `getValue` function to each element.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} items The array of elements to search.\r\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\r\n * @returns {T | undefined} The element with the maximum value as determined by the `getValue` function.\r\n * @example\r\n * maxBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 3 }\r\n * maxBy([], x => x.a); // Returns: undefined\r\n */\r\nexport function maxBy<T>(items: readonly T[], getValue: (element: T) => number): T | undefined;\r\n/**\r\n * Finds the element in an array that has the maximum value when applying\r\n * the `getValue` function to each element.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} items The array of elements to search.\r\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\r\n * @returns {T | undefined} The element with the maximum value as determined by the `getValue` function.\r\n * @example\r\n * maxBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 3 }\r\n * maxBy([], x => x.a); // Returns: undefined\r\n */\r\nexport function maxBy<T>(items: readonly T[], getValue: (element: T) => number): T {\r\n  let maxElement = items[0];\r\n  let max = -Infinity;\r\n\r\n  for (const element of items) {\r\n    const value = getValue(element);\r\n    if (value > max) {\r\n      max = value;\r\n      maxElement = element;\r\n    }\r\n  }\r\n\r\n  return maxElement;\r\n}\r\n","import { mean } from './mean.ts';\r\n\r\n/**\r\n * Calculates the average of an array of numbers when applying\r\n * the `getValue` function to each element.\r\n *\r\n * If the array is empty, this function returns `NaN`.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} items An array to calculate the average.\r\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\r\n * @returns {number} The average of all the numbers as determined by the `getValue` function.\r\n *\r\n * @example\r\n * meanBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: 2\r\n * meanBy([], x => x.a); // Returns: NaN\r\n */\r\nexport function meanBy<T>(items: readonly T[], getValue: (element: T) => number): number {\r\n  const nums = items.map(x => getValue(x));\r\n\r\n  return mean(nums);\r\n}\r\n","/**\r\n * Creates a memoized version of the provided function. The memoized function caches\r\n * results based on the argument it receives, so if the same argument is passed again,\r\n * it returns the cached result instead of recomputing it.\r\n *\r\n * This function works with functions that take zero or just one argument. If your function\r\n * originally takes multiple arguments, you should refactor it to take a single object or array\r\n * that combines those arguments.\r\n *\r\n * If the argument is not primitive (e.g., arrays or objects), provide a\r\n * `getCacheKey` function to generate a unique cache key for proper caching.\r\n *\r\n * @template F - The type of the function to be memoized.\r\n * @param {F} fn - The function to be memoized. It should accept a single argument and return a value.\r\n * @param {MemoizeOptions<Parameters<F>[0], ReturnType<F>>} [options={}] - Optional configuration for the memoization.\r\n * @param {MemoizeCache<any, V>} [options.cache] - The cache object used to store results. Defaults to a new `Map`.\r\n * @param {(args: A) => unknown} [options.getCacheKey] - An optional function to generate a unique cache key for each argument.\r\n *\r\n * @returns The memoized function with an additional `cache` property that exposes the internal cache.\r\n *\r\n * @example\r\n * // Example using the default cache\r\n * const add = (x: number) => x + 10;\r\n * const memoizedAdd = memoize(add);\r\n *\r\n * console.log(memoizedAdd(5)); // 15\r\n * console.log(memoizedAdd(5)); // 15 (cached result)\r\n * console.log(memoizedAdd.cache.size); // 1\r\n *\r\n * @example\r\n * // Example using a custom resolver\r\n * const sum = (arr: number[]) => arr.reduce((x, y) => x + y, 0);\r\n * const memoizedSum = memoize(sum, { getCacheKey: (arr: number[]) => arr.join(',') });\r\n * console.log(memoizedSum([1, 2])); // 3\r\n * console.log(memoizedSum([1, 2])); // 3 (cached result)\r\n * console.log(memoizedSum.cache.size); // 1\r\n *\r\n * @example\r\n * // Example using a custom cache implementation\r\n * class CustomCache<K, T> implements MemoizeCache<K, T> {\r\n *   private cache = new Map<K, T>();\r\n *\r\n *   set(key: K, value: T): void {\r\n *     this.cache.set(key, value);\r\n *   }\r\n *\r\n *   get(key: K): T | undefined {\r\n *     return this.cache.get(key);\r\n *   }\r\n *\r\n *   has(key: K): boolean {\r\n *     return this.cache.has(key);\r\n *   }\r\n *\r\n *   delete(key: K): boolean {\r\n *     return this.cache.delete(key);\r\n *   }\r\n *\r\n *   clear(): void {\r\n *     this.cache.clear();\r\n *   }\r\n *\r\n *   get size(): number {\r\n *     return this.cache.size;\r\n *   }\r\n * }\r\n * const customCache = new CustomCache<string, number>();\r\n * const memoizedSumWithCustomCache = memoize(sum, { cache: customCache });\r\n * console.log(memoizedSumWithCustomCache([1, 2])); // 3\r\n * console.log(memoizedSumWithCustomCache([1, 2])); // 3 (cached result)\r\n * console.log(memoizedAddWithCustomCache.cache.size); // 1\r\n */\r\nexport function memoize<F extends (...args: any) => any>(\r\n  fn: F,\r\n  options: {\r\n    cache?: MemoizeCache<any, ReturnType<F>>;\r\n    getCacheKey?: (args: Parameters<F>[0]) => unknown;\r\n  } = {}\r\n): F & { cache: MemoizeCache<any, ReturnType<F>> } {\r\n  const { cache = new Map<unknown, ReturnType<F>>(), getCacheKey } = options;\r\n\r\n  const memoizedFn = function (this: unknown, arg: Parameters<F>[0]): ReturnType<F> {\r\n    const key = getCacheKey ? getCacheKey(arg) : arg;\r\n\r\n    if (cache.has(key)) {\r\n      return cache.get(key)!;\r\n    }\r\n\r\n    const result = fn.call(this, arg);\r\n\r\n    cache.set(key, result);\r\n\r\n    return result;\r\n  };\r\n\r\n  memoizedFn.cache = cache;\r\n\r\n  return memoizedFn as F & { cache: MemoizeCache<any, ReturnType<F>> };\r\n}\r\n\r\n/**\r\n * Represents a cache for memoization, allowing storage and retrieval of computed values.\r\n *\r\n * @template K - The type of keys used to store values in the cache.\r\n * @template V - The type of values stored in the cache.\r\n */\r\nexport interface MemoizeCache<K, V> {\r\n  /**\r\n   * Stores a value in the cache with the specified key.\r\n   *\r\n   * @param key - The key to associate with the value.\r\n   * @param value - The value to store in the cache.\r\n   */\r\n  set(key: K, value: V): void;\r\n\r\n  /**\r\n   * Retrieves a value from the cache by its key.\r\n   *\r\n   * @param key - The key of the value to retrieve.\r\n   * @returns The value associated with the key, or undefined if the key does not exist.\r\n   */\r\n  get(key: K): V | undefined;\r\n\r\n  /**\r\n   * Checks if a value exists in the cache for the specified key.\r\n   *\r\n   * @param key - The key to check for existence in the cache.\r\n   * @returns True if the cache contains the key, false otherwise.\r\n   */\r\n  has(key: K): boolean;\r\n\r\n  /**\r\n   * Deletes a value from the cache by its key.\r\n   *\r\n   * @param key - The key of the value to delete.\r\n   * @returns True if the value was successfully deleted, false otherwise.\r\n   */\r\n  delete(key: K): boolean | void;\r\n\r\n  /**\r\n   * Clears all values from the cache.\r\n   */\r\n  clear(): void;\r\n\r\n  /**\r\n   * The number of entries in the cache.\r\n   */\r\n  size: number;\r\n}\r\n","import { noop } from '../../function/noop.ts';\r\nimport { mergeWith } from './mergeWith.ts';\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S} source - The first source object whose properties will be merged into the target object.\r\n * @returns {O & S} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @template O - Type of the target object.\r\n * @template S - Type of the first source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function merge<O, S>(object: O, source: S): O & S;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S1} source1 - The first source object to be merged into the target object.\r\n * @param {S2} source2 - The second source object to be merged into the target object.\r\n * @returns {O & S1 & S2} The updated target object with properties from the source objects merged in.\r\n *\r\n * @template O - Type of the target object.\r\n * @template S1 - Type of the first source object.\r\n * @template S2 - Type of the second source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function merge<O, S1, S2>(object: O, source1: S1, source2: S2): O & S1 & S2;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S1} source1 - The first source object whose properties will be merged into the target object.\r\n * @param {S2} source2 - The second source object whose properties will be merged into the target object.\r\n * @param {S3} source3 - The third source object whose properties will be merged into the target object.\r\n * @returns {O & S1 & S2 & S3} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @template O - Type of the target object.\r\n * @template S1 - Type of the first source object.\r\n * @template S2 - Type of the second source object.\r\n * @template S3 - Type of the third source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function merge<O, S1, S2, S3>(object: O, source1: S1, source2: S2, source3: S3): O & S1 & S2 & S3;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S1} source1 - The first source object whose properties will be merged into the target object.\r\n * @param {S2} source2 - The second source object whose properties will be merged into the target object.\r\n * @param {S3} source3 - The third source object whose properties will be merged into the target object.\r\n * @param {S4} source4 - The fourth source object whose properties will be merged into the target object.\r\n * @returns {O & S1 & S2 & S3 & S4} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @template O - Type of the target object.\r\n * @template S1 - Type of the first source object.\r\n * @template S2 - Type of the second source object.\r\n * @template S3 - Type of the third source object.\r\n * @template S4 - Type of the fourth source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function merge<O, S1, S2, S3, S4>(\r\n  object: O,\r\n  source1: S1,\r\n  source2: S2,\r\n  source3: S3,\r\n  source4: S4\r\n): O & S1 & S2 & S3;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {any} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {any[]} sources - The source objects whose properties will be merged into the target object.\r\n * @returns {any} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function merge(object: any, ...sources: any[]): any;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {any} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {any[]} sources - The source objects whose properties will be merged into the target object.\r\n * @returns {any} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function merge(object: any, ...sources: any[]): any {\r\n  return mergeWith(object, ...sources, noop);\r\n}\r\n","/**\r\n * Finds the element in an array that has the minimum value.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {[T, ...T[]]} items - The array of elements to search.\r\n * @returns {T | undefined} - The element with the minimum value, or undefined if the array is empty.\r\n * @example\r\n * // Returns 1\r\n * min([3, 1, 4, 1, 5, 9]);\r\n *\r\n * @example\r\n * // Returns -3\r\n * min([0, -3, 2, 8, 7]);\r\n */\r\nexport function min<T>(items: readonly [T, ...T[]]): T;\r\n\r\n/**\r\n * Finds the element in an array that has the minimum value.\r\n * Returns undefined when no arguments are provided.\r\n * @returns {undefined}\r\n */\r\nexport function min(): undefined;\r\n\r\n/**\r\n * Finds the element in an array that has the minimum value.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} [items] - The array of elements to search. Defaults to an empty array.\r\n * @returns {T | undefined} - The element with the minimum value, or undefined if the array is empty.\r\n */\r\nexport function min<T>(items?: readonly T[]): T | undefined;\r\n\r\n/**\r\n * Finds the element in an array that has the minimum value.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} [items] - The array of elements to search. Defaults to an empty array.\r\n * @returns {T} - The element with the minimum value.\r\n */\r\nexport function min<T>(items: readonly T[] = []): T {\r\n  let minElement = items[0];\r\n  let min: any = undefined;\r\n\r\n  for (const element of items) {\r\n    if (min == null || element < min) {\r\n      min = element;\r\n      minElement = element;\r\n    }\r\n  }\r\n\r\n  return minElement;\r\n}\r\n","/**\r\n * Finds the element in an array that has the minimum value when applying\r\n * the `getValue` function to each element.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {[T, ...T[]]} items The nonempty array of elements to search.\r\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\r\n * @returns {T} The element with the minimum value as determined by the `getValue` function.\r\n * @example\r\n * minBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 1 }\r\n * minBy([], x => x.a); // Returns: undefined\r\n */\r\nexport function minBy<T>(items: readonly [T, ...T[]], getValue: (element: T) => number): T;\r\n/**\r\n * Finds the element in an array that has the minimum value when applying\r\n * the `getValue` function to each element.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} items The array of elements to search.\r\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\r\n * @returns {T | undefined} The element with the minimum value as determined by the `getValue` function.\r\n * @example\r\n * minBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 1 }\r\n * minBy([], x => x.a); // Returns: undefined\r\n */\r\nexport function minBy<T>(items: readonly T[], getValue: (element: T) => number): T | undefined;\r\n/**\r\n * Finds the element in an array that has the minimum value when applying\r\n * the `getValue` function to each element.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} items The array of elements to search.\r\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\r\n * @returns {T | undefined} The element with the minimum value as determined by the `getValue` function.\r\n * @example\r\n * minBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 1 }\r\n * minBy([], x => x.a); // Returns: undefined\r\n */\r\nexport function minBy<T>(items: readonly T[], getValue: (element: T) => number): T | undefined {\r\n  let minElement = items[0];\r\n  let min = Infinity;\r\n\r\n  for (const element of items) {\r\n    const value = getValue(element);\r\n    if (value < min) {\r\n      min = value;\r\n      minElement = element;\r\n    }\r\n  }\r\n\r\n  return minElement;\r\n}\r\n","/**\r\n * Creates a function that negates the result of the predicate function.\r\n *\r\n * @template F - The type of the function to negate.\r\n * @param {F} func - The function to negate.\r\n * @returns {F} The new negated function, which negates the boolean result of `func`.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5, 6];\r\n * const isEven = (n: number) => n % 2 === 0;\r\n * const result = array.filter(negate(isEven));\r\n * // result will be [1, 3, 5]\r\n */\r\nexport function negate<F extends (...args: any[]) => boolean>(func: F): F {\r\n  return ((...args: any[]) => !func(...args)) as F;\r\n}\r\n","import { cloneDeep } from '../../object/cloneDeep.ts';\r\nimport { unset } from './unset.ts';\r\n\r\n/**\r\n * Creates a new object with specified keys omitted.\r\n *\r\n * This function takes an object and an array of keys, and returns a new object that\r\n * excludes the properties corresponding to the specified keys.\r\n *\r\n * @template T - The type of object.\r\n * @template K - The type of keys in object.\r\n * @param {T} obj - The object to omit keys from.\r\n * @param {K[]} keys - An array of keys to be omitted from the object.\r\n * @returns {Omit<T, K>} A new object with the specified keys omitted.\r\n *\r\n * @example\r\n * const obj = { a: 1, b: 2, c: 3 };\r\n * const result = omit(obj, ['b', 'c']);\r\n * // result will be { a: 1 }\r\n */\r\nexport function omit<T extends Record<string, any>, K extends keyof T>(obj: T, keys: readonly K[]): Omit<T, K>;\r\n\r\n/**\r\n * Creates a new object with specified keys omitted.\r\n *\r\n * This function takes an object and a variable number of keys, and returns a new object that\r\n * excludes the properties corresponding to the specified keys.\r\n *\r\n * Deep keys can be specified for keys.\r\n *\r\n * @template T - The type of object.\r\n * @param {T} obj - The object to omit keys from.\r\n * @param {...(PropertyKey | PropertyKey[] | PropertyKey[][]} keys - A variable number of keys to be omitted from the object.\r\n * @returns {Partial<T>} A new object with the specified keys omitted.\r\n */\r\nexport function omit<\r\n  // eslint-disable-next-line\r\n  T extends {},\r\n>(\r\n  obj: T | null | undefined,\r\n  ...keys: Array<PropertyKey | readonly PropertyKey[] | ReadonlyArray<readonly PropertyKey[]>>\r\n): Partial<T>;\r\n\r\n/**\r\n * Creates a new object with specified keys omitted.\r\n *\r\n * This function takes an object and a variable number of keys, and returns a new object that\r\n * excludes the properties corresponding to the specified keys. Note that keys can be deep.\r\n *\r\n * Deep keys can be specified for keys.\r\n *\r\n * @template T - The type of object.\r\n * @param {T} obj - The object to omit keys from.\r\n * @param {...(PropertyKey | PropertyKey[] | PropertyKey[][])} keysArr - A variable number of keys to be omitted from the object.\r\n * @returns {Partial<T>} A new object with the specified keys omitted.\r\n */\r\nexport function omit<\r\n  // eslint-disable-next-line\r\n  T extends {},\r\n>(\r\n  obj: T | null | undefined,\r\n  ...keysArr: Array<PropertyKey | readonly PropertyKey[] | ReadonlyArray<readonly PropertyKey[]>>\r\n): Partial<T> {\r\n  if (obj == null) {\r\n    return {};\r\n  }\r\n\r\n  const result = cloneDeep(obj);\r\n\r\n  for (let i = 0; i < keysArr.length; i++) {\r\n    let keys = keysArr[i];\r\n\r\n    switch (typeof keys) {\r\n      case 'object': {\r\n        if (!Array.isArray(keys)) {\r\n          // eslint-disable-next-line\r\n          // @ts-ignore\r\n          keys = Array.from(keys) as PropertyKey[];\r\n        }\r\n\r\n        for (let j = 0; j < keys.length; j++) {\r\n          const key = keys[j];\r\n\r\n          unset(result, key);\r\n        }\r\n\r\n        break;\r\n      }\r\n      case 'string':\r\n      case 'symbol':\r\n      case 'number': {\r\n        unset(result, keys);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Creates a new object composed of the properties that do not satisfy the predicate function.\r\n *\r\n * This function takes an object and a predicate function, and returns a new object that\r\n * includes only the properties for which the predicate function returns false.\r\n *\r\n * @template T - The type of object.\r\n * @param {T} obj - The object to omit properties from.\r\n * @param {(value: T[string], key: keyof T) => boolean} shouldOmit - A predicate function that determines\r\n * whether a property should be omitted. It takes the property's key and value as arguments and returns `true`\r\n * if the property should be omitted, and `false` otherwise.\r\n * @returns {Partial<T>} A new object with the properties that do not satisfy the predicate function.\r\n *\r\n * @example\r\n * const obj = { a: 1, b: 'omit', c: 3 };\r\n * const shouldOmit = (key, value) => typeof value === 'string';\r\n * const result = omitBy(obj, shouldOmit);\r\n * // result will be { a: 1, c: 3 }\r\n */\r\nexport function omitBy<T extends Record<string, any>>(\r\n  obj: T,\r\n  shouldOmit: (value: T[keyof T], key: keyof T) => boolean\r\n): Partial<T> {\r\n  const result: Partial<T> = {};\r\n\r\n  for (const [key, value] of Object.entries(obj)) {\r\n    if (shouldOmit(value, key)) {\r\n      continue;\r\n    }\r\n\r\n    (result as any)[key] = value;\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Creates a function that is restricted to invoking the provided function `func` once.\r\n * Repeated calls to the function will return the value from the first invocation.\r\n *\r\n * @template F - The type of function.\r\n * @param {F} func - The function to restrict.\r\n * @returns {F} A new function that invokes `func` once and caches the result.\r\n *\r\n * @example\r\n * const initialize = once(() => {\r\n *   console.log('Initialized!');\r\n *   return true;\r\n * });\r\n *\r\n * initialize(); // Logs: 'Initialized!' and returns true\r\n * initialize(); // Returns true without logging\r\n */\r\nexport function once<F extends () => any>(func: F): F {\r\n  let called = false;\r\n  let cache: ReturnType<F> | undefined;\r\n\r\n  return function () {\r\n    if (called) {\r\n      return cache;\r\n    }\r\n\r\n    const result = func();\r\n\r\n    called = true;\r\n    cache = result;\r\n\r\n    return result;\r\n  } as F;\r\n}\r\n","/**\r\n * Pads string on the left and right sides if it's shorter than length. Padding characters are truncated if they can't be evenly divided by length.\r\n * If the length is less than or equal to the original string's length, or if the padding character is an empty string, the original string is returned unchanged.\r\n *\r\n * @param {string} str - The string to pad.\r\n * @param {number} [length] - The length of the resulting string once padded.\r\n * @param {string} [chars] - The character(s) to use for padding.\r\n * @returns {string} - The padded string, or the original string if padding is not required.\r\n *\r\n * @example\r\n * const result1 = pad('abc', 8);         // result will be '  abc   '\r\n * const result2 = pad('abc', 8, '_-');   // result will be '_-abc_-_'\r\n * const result3 = pad('abc', 3);         // result will be 'abc'\r\n * const result4 = pad('abc', 2);         // result will be 'abc'\r\n *\r\n */\r\nexport function pad(str: string, length: number, chars = ' '): string {\r\n  return str.padStart(Math.floor((length - str.length) / 2) + str.length, chars).padEnd(length, chars);\r\n}\r\n","/**\r\n * Pads the end of a string with a given character until it reaches the specified length.\r\n *\r\n * If the length is less than or equal to the original string's length, or if the padding character is an empty string,\r\n * the original string is returned unchanged.\r\n *\r\n * @param {string} str - The string to pad.\r\n * @param {number} [length] - The length of the resulting string once padded.\r\n * @param {string} [chars] - The character(s) to use for padding.\r\n * @returns {string} - The padded string, or the original string if padding is not required.\r\n *\r\n * @example\r\n * const result1 = padEnd('abc', 6);          // result will be 'abc   '\r\n * const result2 = padEnd('abc', 6, '_-');    // result will be 'abc_-_'\r\n * const result3 = padEnd('abc', 3);          // result will be 'abc'\r\n * const result4 = padEnd('abc', 2);          // result will be 'abc'\r\n */\r\n\r\nexport function padEnd(str: string, length = 0, chars = ' '): string {\r\n  return str.padEnd(length, chars);\r\n}\r\n","/**\r\n * Pads the start of a string with a given character until it reaches the specified length.\r\n *\r\n * If the length is less than or equal to the original string's length, or if the padding character is an empty string,\r\n * the original string is returned unchanged.\r\n *\r\n * @param {string} str - The string to pad.\r\n * @param {number} [length] - The length of the resulting string once padded.\r\n * @param {string} [chars] - The character(s) to use for padding.\r\n * @returns {string} - The padded string, or the original string if padding is not required.\r\n *\r\n * @example\r\n * const result1 = padStart('abc', 6);          // result will be '   abc'\r\n * const result2 = padStart('abc', 6, '_-');    // result will be '_-_abc'\r\n * const result3 = padStart('abc', 3);          // result will be 'abc'\r\n * const result4 = padStart('abc', 2);          // result will be 'abc'\r\n */\r\nexport function padStart(str: string, length = 0, chars = ' '): string {\r\n  return str.padStart(length, chars);\r\n}\r\n","/**\r\n * Converts `string` to an integer of the specified radix. If `radix` is undefined or 0, a `radix` of 10 is used unless `string` is a hexadecimal, in which case a `radix` of 16 is used.\r\n *\r\n * @param {string} string The string to convert to an integer.\r\n * @param {number} radix The radix to use when converting the string to an integer. Defaults to `0`.\r\n * @param {unknown} guard Enables use as an iteratee for methods like `Array#map`.\r\n * @returns {number} Returns the converted integer.\r\n *\r\n * @example\r\n * parseInt('08'); // => 8\r\n * parseInt('0x20'); // => 32\r\n *\r\n * parseInt('08', 10); // => 8\r\n * parseInt('0x20', 16); // => 32\r\n *\r\n * ['6', '08', '10'].map(parseInt); // => [6, 8, 10]\r\n */\r\nexport function parseInt(string: string, radix = 0, guard?: unknown): number {\r\n  if (guard) {\r\n    radix = 0;\r\n  }\r\n  return Number.parseInt(string, radix);\r\n}\r\n","/**\r\n * Splits an array into two groups based on a predicate function.\r\n *\r\n * This function takes an array and a predicate function. It returns a tuple of two arrays:\r\n * the first array contains elements for which the predicate function returns true, and\r\n * the second array contains elements for which the predicate function returns false.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to partition.\r\n * @param {(value: T) => boolean} isInTruthy - A predicate function that determines\r\n * whether an element should be placed in the truthy array. The function is called with each\r\n * element of the array.\r\n * @returns {[T[], T[]]} A tuple containing two arrays: the first array contains elements for\r\n * which the predicate returned true, and the second array contains elements for which the\r\n * predicate returned false.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * const isEven = x => x % 2 === 0;\r\n * const [even, odd] = partition(array, isEven);\r\n * // even will be [2, 4], and odd will be [1, 3, 5]\r\n */\r\nexport function partition<T>(arr: readonly T[], isInTruthy: (value: T) => boolean): [truthy: T[], falsy: T[]] {\r\n  const truthy: T[] = [];\r\n  const falsy: T[] = [];\r\n\r\n  for (const item of arr) {\r\n    if (isInTruthy(item)) {\r\n      truthy.push(item);\r\n    } else {\r\n      falsy.push(item);\r\n    }\r\n  }\r\n\r\n  return [truthy, falsy];\r\n}\r\n","import { getWords } from './_internal/getWords.ts';\r\nimport { capitalize } from './capitalize.ts';\r\n\r\n/**\r\n * Converts a string to Pascal case.\r\n *\r\n * Pascal case is the naming convention in which each word is capitalized and concatenated without any separator characters.\r\n *\r\n * @param {string} str - The string that is to be changed to pascal case.\r\n * @returns {string} - The converted string to Pascal case.\r\n *\r\n * @example\r\n * const convertedStr1 = pascalCase('pascalCase') // returns 'PascalCase'\r\n * const convertedStr2 = pascalCase('some whitespace') // returns 'SomeWhitespace'\r\n * const convertedStr3 = pascalCase('hyphen-text') // returns 'HyphenText'\r\n * const convertedStr4 = pascalCase('HTTPRequest') // returns 'HttpRequest'\r\n */\r\nexport function pascalCase(str: string): string {\r\n  const words = getWords(str);\r\n  return words.map(word => capitalize(word)).join('');\r\n}\r\n","import { isNil } from '../predicate/isNil.ts';\r\nimport { get } from './get.ts';\r\nimport { set } from './set.ts';\r\n\r\n/**\r\n * Creates a new object composed of the picked object properties.\r\n *\r\n * This function takes an object and an array of keys, and returns a new object that\r\n * includes only the properties corresponding to the specified keys.\r\n *\r\n * @template T - The type of object.\r\n * @template K - The type of keys in object.\r\n * @param {T} obj - The object to pick keys from.\r\n * @param {K[]} keys - An array of keys to be picked from the object.\r\n * @returns {Pick<T, K>} A new object with the specified keys picked.\r\n *\r\n * @example\r\n * const obj = { a: 1, b: 2, c: 3 };\r\n * const result = pick(obj, ['a', 'c']);\r\n * // result will be { a: 1, c: 3 }\r\n */\r\nexport function pick<T extends Record<string, any>, K extends keyof T>(obj: T, keys: readonly K[]): Pick<T, K>;\r\n\r\n/**\r\n * Creates a new object composed of the picked object properties.\r\n *\r\n * This function takes an object and an array of keys, and returns a new object that\r\n * includes only the properties corresponding to the specified keys.\r\n *\r\n * @template T - The type of object.\r\n * @param {T | null | undefined} obj - The object to pick keys from.\r\n * @param {...any} keys\r\n * @param {PropertyKey | PropertyKey[] | ProperyKey[][]}} keys - An array of keys to be picked from the object. received keysgoes through a flattening process before being used.\r\n * @returns {Partial<T, K>} A new object with the specified keys picked.\r\n *\r\n * @example\r\n * const obj = { a: 1, b: 2, c: 3 };\r\n * const result = pick(obj, ['a', 'c']);\r\n * // result will be { a: 1, c: 3 }\r\n *\r\n * // each path can be passed individually as an argument\r\n * const obj = { a: 1, b: 2, c: 3 };\r\n * const result = pick(obj, 'a', 'c');\r\n *\r\n * // pick a key over a path\r\n * const obj = { 'a.b': 1, a: { b: 2 } };\r\n * const result = pick(obj, 'a.b');\r\n * // result will be { 'a.b': 1 }\r\n */\r\nexport function pick<\r\n  // eslint-disable-next-line\r\n  T extends {},\r\n>(\r\n  obj: T | null | undefined,\r\n  ...keys: Array<PropertyKey | readonly PropertyKey[] | ReadonlyArray<readonly PropertyKey[]>>\r\n): Partial<T>;\r\n\r\n/**\r\n * Creates a new object composed of the picked object properties.\r\n *\r\n * This function takes an object and an array of keys, and returns a new object that\r\n * includes only the properties corresponding to the specified keys.\r\n *\r\n * @template T - The type of object.\r\n * @param {T | null | undefined} obj - The object to pick keys from.\r\n * @param {...any} keysArr - An array of keys to be picked from the object. received keysgoes through a flattening process before being used.\r\n * @param {PropertyKey | PropertyKey[] | ProperyKey[][]}} keys - An array of keys to be picked from the object. received keysgoes through a flattening process before being used.\r\n * @returns {Partial<T, K>} A new object with the specified keys picked.\r\n *\r\n * @example\r\n * const obj = { a: 1, b: 2, c: 3 };\r\n * const result = pick(obj, ['a', 'c']);\r\n * // result will be { a: 1, c: 3 }\r\n *\r\n * // each path can be passed individually as an argument\r\n * const obj = { a: 1, b: 2, c: 3 };\r\n * const result = pick(obj, 'a', 'c');\r\n *\r\n * // pick a key over a path\r\n * const obj = { 'a.b': 1, a: { b: 2 } };\r\n * const result = pick(obj, 'a.b');\r\n * // result will be { 'a.b': 1 }\r\n */\r\nexport function pick<\r\n  // eslint-disable-next-line\r\n  T extends {},\r\n>(\r\n  obj: T | null | undefined,\r\n  ...keysArr: Array<PropertyKey | readonly PropertyKey[] | ReadonlyArray<readonly PropertyKey[]>>\r\n): Partial<T> {\r\n  if (isNil(obj)) {\r\n    return {};\r\n  }\r\n\r\n  const result: any = {};\r\n\r\n  for (let keys of keysArr) {\r\n    switch (typeof keys) {\r\n      case 'object': {\r\n        if (!Array.isArray(keys)) {\r\n          // eslint-disable-next-line\r\n          // @ts-ignore\r\n          keys = Array.from(keys) as PropertyKey[];\r\n        }\r\n        break;\r\n      }\r\n      case 'string':\r\n      case 'symbol':\r\n      case 'number': {\r\n        keys = [keys];\r\n        break;\r\n      }\r\n    }\r\n\r\n    for (const key of keys) {\r\n      const value = get(obj, key);\r\n\r\n      if (typeof key === 'string' && Object.prototype.hasOwnProperty.call(obj, key)) {\r\n        result[key] = value;\r\n      } else {\r\n        set(result, key, value);\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Creates a new object composed of the properties that satisfy the predicate function.\r\n *\r\n * This function takes an object and a predicate function, and returns a new object that\r\n * includes only the properties for which the predicate function returns true.\r\n *\r\n * @template T - The type of object.\r\n * @param {T} obj - The object to pick properties from.\r\n * @param {(value: T[keyof T], key: keyof T) => boolean} shouldPick - A predicate function that determines\r\n * whether a property should be picked. It takes the property's key and value as arguments and returns `true`\r\n * if the property should be picked, and `false` otherwise.\r\n * @returns {Partial<T>} A new object with the properties that satisfy the predicate function.\r\n *\r\n * @example\r\n * const obj = { a: 1, b: 'pick', c: 3 };\r\n * const shouldPick = (value) => typeof value === 'string';\r\n * const result = pickBy(obj, shouldPick);\r\n * // result will be { b: 'pick' }\r\n */\r\nexport function pickBy<T extends Record<string, any>>(\r\n  obj: T,\r\n  shouldPick: (value: T[keyof T], key: keyof T) => boolean\r\n): Partial<T> {\r\n  const result: Partial<T> = {};\r\n\r\n  for (const [key, value] of Object.entries(obj)) {\r\n    if (!shouldPick(value, key)) {\r\n      continue;\r\n    }\r\n\r\n    (result as any)[key] = value;\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { at } from './at.ts';\r\n\r\n/**\r\n * Removes elements from an array at specified indices and returns the removed elements.\r\n *\r\n * This function supports negative indices, which count from the end of the array.\r\n *\r\n * @template T\r\n * @param {T[]} arr - The array from which elements will be removed.\r\n * @param {number[]} indicesToRemove - An array of indices specifying the positions of elements to remove.\r\n * @returns {Array<T | undefined>} An array containing the elements that were removed from the original array.\r\n *\r\n * @example\r\n * import { pullAt } from './pullAt';\r\n *\r\n * const numbers = [10, 20, 30, 40, 50];\r\n * const removed = pullAt(numbers, [1, 3, 4]);\r\n * console.log(removed); // [20, 40, 50]\r\n * console.log(numbers); // [10, 30]\r\n */\r\nexport function pullAt<T>(arr: T[], indicesToRemove: number[]): Array<T | undefined> {\r\n  const removed = at(arr, indicesToRemove);\r\n  const indices = new Set(indicesToRemove.slice().sort((x, y) => y - x));\r\n\r\n  for (const index of indices) {\r\n    arr.splice(index, 1);\r\n  }\r\n\r\n  return removed;\r\n}\r\n","import { random as randomToolkit } from '../../math/random.ts';\r\nimport { randomInt as randomIntToolkit } from '../../math/randomInt.ts';\r\nimport { clamp } from './clamp.ts';\r\n\r\n/**\r\n * Generate a random number within 0 and 1.\r\n *\r\n * @returns {number} A random number between 0 (inclusive) and 1 (exclusive). The number can be an integer or a decimal.\r\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\r\n *\r\n * @example\r\n * const result = random(); // Returns a random number between 0 and 1.\r\n */\r\nexport function random(floating?: boolean): number;\r\n\r\n/**\r\n * Generate a random number within 0 and 1.\r\n *\r\n * @returns {number} A random number between 0 (inclusive) and 1 (exclusive). The number can be an integer or a decimal.\r\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\r\n *\r\n * @example\r\n * const result = random(); // Returns a random number between 0 and 1.\r\n */\r\nexport function random(min: number, index: string | number, guard: object): number;\r\n\r\n/**\r\n * Generate a random number within the given range.\r\n *\r\n * If only one argument is provided, a number between `0` and the given number is returned.\r\n *\r\n * @param {number} maximum - The upper bound (exclusive).\r\n * @returns {number} A random number between 0 (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\r\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\r\n *\r\n * @example\r\n * const result1 = random(5); // Returns a random number between 0 and 5.\r\n * const result2 = random(0); // Returns a random number between 0 and 0 (which is 0).\r\n */\r\nexport function random(maximum: number, floating?: boolean): number;\r\n\r\n/**\r\n * Generate a random number within the given range.\r\n *\r\n * @param {number} minimum - The lower bound (inclusive).\r\n * @param {number} maximum - The upper bound (exclusive).\r\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\r\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\r\n *\r\n * @example\r\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\r\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown.\r\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\r\n */\r\nexport function random(minimum: number, maximum: number, floating?: boolean): number;\r\n\r\n/**\r\n * Generate a random number within the given range.\r\n *\r\n * @param {number} minimum - The lower bound (inclusive).\r\n * @param {number} maximum - The upper bound (exclusive).\r\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\r\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\r\n *\r\n * @example\r\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\r\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown.\r\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\r\n */\r\nexport function random(...args: any[]): number {\r\n  let minimum: number = 0;\r\n  let maximum: number = 1;\r\n  let floating: boolean = false;\r\n\r\n  switch (args.length) {\r\n    case 1: {\r\n      if (typeof args[0] === 'boolean') {\r\n        floating = args[0];\r\n      } else {\r\n        maximum = args[0];\r\n      }\r\n\r\n      break;\r\n    }\r\n    case 2: {\r\n      if (typeof args[1] === 'boolean') {\r\n        maximum = args[0];\r\n        floating = args[1];\r\n      } else {\r\n        minimum = args[0];\r\n        maximum = args[1];\r\n      }\r\n    }\r\n    case 3: {\r\n      if (typeof args[2] === 'object' && args[2] != null && args[2][args[1]] === args[0]) {\r\n        minimum = 0;\r\n        maximum = args[0];\r\n        floating = false;\r\n      } else {\r\n        minimum = args[0];\r\n        maximum = args[1];\r\n        floating = args[2];\r\n      }\r\n    }\r\n  }\r\n\r\n  if (typeof minimum !== 'number') {\r\n    minimum = Number(minimum);\r\n  }\r\n\r\n  if (typeof maximum !== 'number') {\r\n    minimum = Number(maximum);\r\n  }\r\n\r\n  if (!minimum) {\r\n    minimum = 0;\r\n  }\r\n\r\n  if (!maximum) {\r\n    maximum = 0;\r\n  }\r\n\r\n  if (minimum > maximum) {\r\n    [minimum, maximum] = [maximum, minimum];\r\n  }\r\n\r\n  minimum = clamp(minimum, -Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\r\n  maximum = clamp(maximum, -Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\r\n\r\n  if (minimum === maximum) {\r\n    return minimum;\r\n  }\r\n\r\n  if (floating) {\r\n    return randomToolkit(minimum, maximum + 1);\r\n  } else {\r\n    return randomIntToolkit(minimum, maximum + 1);\r\n  }\r\n}\r\n","/**\r\n * Returns an array of numbers from `start` to `end`, incrementing by `step`.\r\n *\r\n * If `step` is not provided, it defaults to `1`.\r\n *\r\n * @param {number} start - The starting number of the range (inclusive).\r\n * @param {number} [end] - The end number of the range (exclusive).\r\n * @param {number} [step] - The step value for the range. (default: 1)\r\n * @returns {number[]} An array of numbers from `start` to `end` with the specified `step`.\r\n *\r\n * @example\r\n * // Returns [0, 1, 2, 3]\r\n * range(4);\r\n *\r\n * @example\r\n * // Returns [0, 5, 10, 15]\r\n * range(0, 20, 5);\r\n *\r\n * @example\r\n * // Returns [0, -1, -2, -3]\r\n * range(0, -4, -1);\r\n *\r\n * @example\r\n * // Throws an error: The step value must be a non-zero integer.\r\n * range(1, 4, 0);\r\n */\r\nexport function range(end: number): number[];\r\n\r\n/**\r\n * Returns an array of numbers from `start` to `end`, incrementing by `step`.\r\n *\r\n * If `step` is not provided, it defaults to `1`.\r\n *\r\n * @param {number} start - The starting number of the range (inclusive).\r\n * @param {number} end - The end number of the range (exclusive).\r\n * @returns {number[]} An array of numbers from `start` to `end` with the specified `step`.\r\n *\r\n * @example\r\n * // Returns [1, 2, 3]\r\n * range(1, 4);\r\n */\r\nexport function range(start: number, end: number): number[];\r\n\r\n/**\r\n * Returns an array of numbers from `start` to `end`, incrementing by `step`.\r\n *\r\n * @param {number} start - The starting number of the range (inclusive).\r\n * @param {number} end - The end number of the range (exclusive).\r\n * @param {number} step - The step value for the range.\r\n * @returns {number[]} An array of numbers from `start` to `end` with the specified `step`.\r\n *\r\n * @example\r\n * // Returns [0, 5, 10, 15]\r\n * range(0, 20, 5);\r\n */\r\nexport function range(start: number, end: number, step: number): number[];\r\n\r\n/**\r\n * Returns an array of numbers from `start` to `end`, incrementing by `step`.\r\n *\r\n * If only one argument is provided, it returns an array from `0` to `start`.\r\n *\r\n * @param {number} start - The starting number of the range (inclusive).\r\n * @param {number} [end] - The end number of the range (exclusive).\r\n * @param {number} [step] - The step value for the range. (default: 1)\r\n * @returns {number[]} An array of numbers from `start` to `end` with the specified `step`.\r\n * @throws {Error} Throws an error if the step value is not a non-zero integer.\r\n *\r\n * @example\r\n * // Returns [0, 1, 2, 3]\r\n * range(4);\r\n *\r\n * @example\r\n * // Returns [0, -1, -2, -3]\r\n * range(0, -4, -1);\r\n */\r\nexport function range(start: number, end?: number, step?: number): number[] {\r\n  if (end == null) {\r\n    end = start;\r\n    start = 0;\r\n  }\r\n\r\n  if (step == null) {\r\n    step = 1;\r\n  }\r\n\r\n  if (!Number.isInteger(step) || step === 0) {\r\n    throw new Error(`The step value must be a non-zero integer.`);\r\n  }\r\n\r\n  const length = Math.max(Math.ceil((end - start) / step), 0);\r\n  const result = new Array(length);\r\n\r\n  for (let i = 0; i < length; i++) {\r\n    result[i] = start + i * step;\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { flatten } from '../array/flatten.ts';\r\n\r\n/**\r\n * Creates a function that invokes `func` with arguments arranged according to the specified `indices`\r\n * where the argument value at the first index is provided as the first argument,\r\n * the argument value at the second index is provided as the second argument, and so on.\r\n *\r\n * @template F The type of the function to re-arrange.\r\n * @param {F} func The function to rearrange arguments for.\r\n * @param {Array<number | number[]>} indices The arranged argument indices.\r\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new function.\r\n *\r\n * @example\r\n * const greet = (greeting: string, name: string) => `${greeting}, ${name}!`;\r\n * const rearrangedGreet = rearg(greet, 1, 0);\r\n * console.log(rearrangedGreet('World', 'Hello')); // Output: \"Hello, World!\"\r\n */\r\nexport function rearg<F extends (...args: any[]) => any>(\r\n  func: F,\r\n  ...indices: Array<number | number[]>\r\n): (...args: any[]) => ReturnType<F> {\r\n  const flattenIndices = flatten(indices);\r\n\r\n  return function (this: any, ...args: any[]) {\r\n    const reorderedArgs: any[] = flattenIndices.map(i => args[i]).slice(0, args.length);\r\n\r\n    for (let i = reorderedArgs.length; i < args.length; i++) {\r\n      reorderedArgs.push(args[i]);\r\n    }\r\n\r\n    return func.apply(this, reorderedArgs);\r\n  };\r\n}\r\n","/**\r\n * Repeats the given string n times.\r\n *\r\n * If n is less than 1, an empty string is returned, or if the string is an empty string,\r\n * the original string is returned unchanged.\r\n *\r\n * @param {string} str - The string to repeat.\r\n * @param {number} n - The number of times to repeat the string.\r\n * @returns {string} - The repeated string, or an empty string if n is less than 1.\r\n *\r\n * @example\r\n * repeat('abc', 0); // ''\r\n * repeat('abc', 2); // 'abcabc'\r\n */\r\nexport function repeat(str: string, n: number): string {\r\n  return str.repeat(n);\r\n}\r\n","import { rest as restToolkit } from '../../function/rest.ts';\r\n\r\n/**\r\n * Creates a function that transforms the arguments of the provided function `func`.\r\n * The transformed arguments are passed to `func` such that the arguments starting from a specified index\r\n * are grouped into an array, while the previous arguments are passed as individual elements.\r\n *\r\n * @template F - The type of the function being transformed.\r\n * @param {F} func - The function whose arguments are to be transformed.\r\n * @param {number} [start=func.length - 1] - The index from which to start grouping the remaining arguments into an array.\r\n *                                            Defaults to `func.length - 1`, grouping all arguments after the last parameter.\r\n * @returns {(...args: any[]) => ReturnType<F>} A new function that, when called, returns the result of calling `func` with the transformed arguments.\r\n *\r\n * The transformed arguments are:\r\n * - The first `start` arguments as individual elements.\r\n * - The remaining arguments from index `start` onward grouped into an array.\r\n * @example\r\n * function fn(a, b, c) {\r\n *   return [a, b, c];\r\n * }\r\n *\r\n * // Using default start index (func.length - 1, which is 2 in this case)\r\n * const transformedFn = rest(fn);\r\n * console.log(transformedFn(1, 2, 3, 4)); // [1, 2, [3, 4]]\r\n *\r\n * // Using start index 1\r\n * const transformedFnWithStart = rest(fn, 1);\r\n * console.log(transformedFnWithStart(1, 2, 3, 4)); // [1, [2, 3, 4]]\r\n *\r\n * // With fewer arguments than the start index\r\n * console.log(transformedFn(1)); // [1, undefined, []]\r\n */\r\nexport function rest<F extends (...args: any[]) => any>(\r\n  func: F,\r\n  start = func.length - 1\r\n): (...args: any[]) => ReturnType<F> {\r\n  start = Number.parseInt(start as any, 10);\r\n\r\n  if (Number.isNaN(start) || start < 0) {\r\n    start = func.length - 1;\r\n  }\r\n\r\n  return restToolkit(func, start);\r\n}\r\n","/**\r\n * Creates a function that transforms the arguments of the provided function `func`.\r\n * The transformed arguments are passed to `func` such that the arguments starting from a specified index\r\n * are grouped into an array, while the previous arguments are passed as individual elements.\r\n *\r\n * @template F - The type of the function being transformed.\r\n * @param {F} func - The function whose arguments are to be transformed.\r\n * @param {number} [startIndex=func.length - 1] - The index from which to start grouping the remaining arguments into an array.\r\n *                                            Defaults to `func.length - 1`, grouping all arguments after the last parameter.\r\n * @returns {(...args: any[]) => ReturnType<F>} A new function that, when called, returns the result of calling `func` with the transformed arguments.\r\n *\r\n * The transformed arguments are:\r\n * - The first `start` arguments as individual elements.\r\n * - The remaining arguments from index `start` onward grouped into an array.\r\n * @example\r\n * function fn(a, b, c) {\r\n *   return [a, b, c];\r\n * }\r\n *\r\n * // Using default start index (func.length - 1, which is 2 in this case)\r\n * const transformedFn = rest(fn);\r\n * console.log(transformedFn(1, 2, 3, 4)); // [1, 2, [3, 4]]\r\n *\r\n * // Using start index 1\r\n * const transformedFnWithStart = rest(fn, 1);\r\n * console.log(transformedFnWithStart(1, 2, 3, 4)); // [1, [2, 3, 4]]\r\n *\r\n * // With fewer arguments than the start index\r\n * console.log(transformedFn(1)); // [1, undefined, []]\r\n */\r\nexport function rest<F extends (...args: any[]) => any>(\r\n  func: F,\r\n  startIndex = func.length - 1\r\n): (...args: any[]) => ReturnType<F> {\r\n  return function (this: any, ...args: any[]) {\r\n    const rest = args.slice(startIndex);\r\n    const params = args.slice(0, startIndex);\r\n    while (params.length < startIndex) {\r\n      params.push(undefined);\r\n    }\r\n    return func.apply(this, [...params, rest]);\r\n  };\r\n}\r\n","import { decimalAdjust } from '../_internal/decimalAdjust.ts';\r\n\r\n/**\r\n * Computes number rounded to precision.\r\n *\r\n * @param {number | string} number  The number to round.\r\n * @param {number | string} precision The precision to round to.\r\n * @returns {number} Returns the rounded number.\r\n *\r\n * @example\r\n * round(4.006); // => 4\r\n * round(4.006, 2); // => 4.01\r\n * round(4060, -2); // => 4100\r\n */\r\nexport function round(number: number | string, precision: number | string = 0): number {\r\n  return decimalAdjust('round', number, precision);\r\n}\r\n","/**\r\n * Returns a random element from an array.\r\n *\r\n * This function takes an array and returns a single element selected randomly from the array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to sample from.\r\n * @returns {T} A random element from the array.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * const randomElement = sample(array);\r\n * // randomElement will be one of the elements from the array, selected randomly.\r\n */\r\nexport function sample<T>(arr: readonly T[]): T {\r\n  const randomIndex = Math.floor(Math.random() * arr.length);\r\n  return arr[randomIndex];\r\n}\r\n","import { randomInt } from '../math/randomInt.ts';\r\n\r\n/**\r\n * Returns a sample element array of a specified `size`.\r\n *\r\n * This function takes an array and a number, and returns an array containing the sampled elements using Floyd's algorithm.\r\n *\r\n * {@link https://www.nowherenearithaca.com/2013/05/robert-floyds-tiny-and-beautiful.html Floyd's algorithm}\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} array - The array to sample from.\r\n * @param {number} size - The size of sample.\r\n * @returns {T[]} A new array with sample size applied.\r\n * @throws {Error} Throws an error if `size` is greater than the length of `array`.\r\n *\r\n * @example\r\n * const result = sampleSize([1, 2, 3], 2)\r\n * // result will be an array containing two of the elements from the array.\r\n * // [1, 2] or [1, 3] or [2, 3]\r\n */\r\nexport function sampleSize<T>(array: readonly T[], size: number): T[] {\r\n  if (size > array.length) {\r\n    throw new Error('Size must be less than or equal to the length of array.');\r\n  }\r\n\r\n  const result = new Array(size);\r\n  const selected = new Set();\r\n\r\n  for (let step = array.length - size, resultIndex = 0; step < array.length; step++, resultIndex++) {\r\n    let index = randomInt(0, step + 1);\r\n\r\n    if (selected.has(index)) {\r\n      index = step;\r\n    }\r\n\r\n    selected.add(index);\r\n\r\n    result[resultIndex] = array[index];\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Randomizes the order of elements in an array using the Fisher-Yates algorithm.\r\n *\r\n * This function takes an array and returns a new array with its elements shuffled in a random order.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to shuffle.\r\n * @returns {T[]} A new array with its elements shuffled in random order.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * const shuffledArray = shuffle(array);\r\n * // shuffledArray will be a new array with elements of array in random order, e.g., [3, 1, 4, 5, 2]\r\n */\r\nexport function shuffle<T>(arr: readonly T[]): T[] {\r\n  const result = arr.slice();\r\n\r\n  /**\r\n   * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\r\n   */\r\n  for (let i = result.length - 1; i >= 1; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [result[i], result[j]] = [result[j], result[i]];\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { isNil } from '../../predicate/isNil.ts';\r\n\r\n/**\r\n * Returns the length of an array, string, or object.\r\n *\r\n * This function takes an array, string, or object and returns its length.\r\n * For arrays and strings, it returns the number of elements or characters, respectively.\r\n * For objects, it returns the number of enumerable properties.\r\n *\r\n * @template T - The type of the input value.\r\n * @param {T[] | object | string | Map<unknown, T> | Set<T> | null | undefined } target - The value whose size is to be determined. It can be an array, string, or object.\r\n * @returns {number} The size of the input value.\r\n *\r\n * @example\r\n * const arr = [1, 2, 3];\r\n * const arrSize = size(arr);\r\n * // arrSize will be 3\r\n *\r\n * const str = 'hello';\r\n * const strSize = size(str);\r\n * // strSize will be 5\r\n *\r\n * const obj = { a: 1, b: 2, c: 3 };\r\n * const objSize = size(obj);\r\n * // objSize will be 3\r\n *\r\n * const emptyArr = [];\r\n * const emptyArrSize = size(emptyArr);\r\n * // emptyArrSize will be 0\r\n *\r\n * const emptyStr = '';\r\n * const emptyStrSize = size(emptyStr);\r\n * // emptyStrSize will be 0\r\n *\r\n * const emptyObj = {};\r\n * const emptyObjSize = size(emptyObj);\r\n * // emptyObjSize will be 0\r\n */\r\nexport function size<T>(target: readonly T[] | object | string | Map<unknown, T> | Set<T> | null | undefined): number {\r\n  if (isNil(target)) {\r\n    return 0;\r\n  }\r\n\r\n  if (target instanceof Map || target instanceof Set) {\r\n    return target.size;\r\n  }\r\n\r\n  return Object.keys(target).length;\r\n}\r\n","/**\r\n * Checks if a given value is null or undefined.\r\n *\r\n * This function tests whether the provided value is either `null` or `undefined`.\r\n * It returns `true` if the value is `null` or `undefined`, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null` or `undefined`.\r\n *\r\n * @param {unknown} x - The value to test for null or undefined.\r\n * @returns {boolean} `true` if the value is null or undefined, `false` otherwise.\r\n *\r\n * @example\r\n * const value1 = null;\r\n * const value2 = undefined;\r\n * const value3 = 42;\r\n * const result1 = isNil(value1); // true\r\n * const result2 = isNil(value2); // true\r\n * const result3 = isNil(value3); // false\r\n */\r\nexport function isNil(x: unknown): x is null | undefined {\r\n  return x == null;\r\n}\r\n","import { snakeCase as snakeCaseToolkit } from '../../string/snakeCase.ts';\r\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\r\n\r\n/**\r\n * Converts a string to snake case.\r\n *\r\n * Snake case is the naming convention in which each word is written in lowercase and separated by an underscore (_) character.\r\n *\r\n * @param {string | object} str - The string that is to be changed to snake case.\r\n * @returns {string} - The converted string to snake case.\r\n *\r\n * @example\r\n * const convertedStr1 = snakeCase('camelCase') // returns 'camel_case'\r\n * const convertedStr2 = snakeCase('some whitespace') // returns 'some_whitespace'\r\n * const convertedStr3 = snakeCase('hyphen-text') // returns 'hyphen_text'\r\n * const convertedStr4 = snakeCase('HTTPRequest') // returns 'http_request'\r\n */\r\nexport function snakeCase(str?: string | object): string {\r\n  return snakeCaseToolkit(normalizeForCase(str));\r\n}\r\n","import { getWords } from './_internal/getWords.ts';\r\n\r\n/**\r\n * Converts a string to snake case.\r\n *\r\n * Snake case is the naming convention in which each word is written in lowercase and separated by an underscore (_) character.\r\n *\r\n * @param {string} str - The string that is to be changed to snake case.\r\n * @returns {string} - The converted string to snake case.\r\n *\r\n * @example\r\n * const convertedStr1 = snakeCase('camelCase') // returns 'camel_case'\r\n * const convertedStr2 = snakeCase('some whitespace') // returns 'some_whitespace'\r\n * const convertedStr3 = snakeCase('hyphen-text') // returns 'hyphen_text'\r\n * const convertedStr4 = snakeCase('HTTPRequest') // returns 'http_request'\r\n */\r\n\r\nexport function snakeCase(str: string): string {\r\n  const words = getWords(str);\r\n  return words.map(word => word.toLowerCase()).join('_');\r\n}\r\n","import { identity } from '../_internal/identity.ts';\r\nimport { property } from '../object/property.ts';\r\nimport { matches } from '../predicate/matches.ts';\r\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\r\n\r\n/**\r\n * Checks if there is an element in an array that is truthy.\r\n *\r\n * @param {T[]} arr The array to iterate over.\r\n * @returns {boolean} Returns `true` if any element is truthy, else `false`.\r\n *\r\n * @example\r\n * some([1, 2, 3, 4]);\r\n * // => true\r\n */\r\nexport function some<T>(arr: readonly T[]): boolean;\r\n\r\n/**\r\n * Checks if there is an element in an array that matches the given predicate function.\r\n *\r\n * @param {T[]} arr The array to iterate over.\r\n * @param {(item: T, index: number, arr: any) => unknown} predicate The function invoked per iteration.\r\n * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\r\n *\r\n * @example\r\n * some([1, 2, 3, 4], n => n % 2 === 0);\r\n * // => true\r\n */\r\nexport function some<T>(arr: readonly T[], predicate: (item: T, index: number, arr: any) => unknown): boolean;\r\n\r\n/**\r\n * Checks if there is an element in an array that matches the given key-value pair.\r\n *\r\n * @param {T[]} arr The array to iterate over.\r\n * @param {[keyof T, unknown]} predicate The key-value pair to match.\r\n * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\r\n *\r\n * @example\r\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], ['a', 2]);\r\n * // => true\r\n */\r\nexport function some<T>(arr: readonly T[], predicate: [keyof T, unknown]): boolean;\r\n\r\n/**\r\n * Checks if there is an element in an array that has a truthy value for the given property name.\r\n *\r\n * @param {T[]} arr The array to iterate over.\r\n * @param {string} propertyToCheck The property name to check.\r\n * @returns {boolean} Returns `true` if any element has a truthy value for the property, else `false`.\r\n *\r\n * @example\r\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], 'a');\r\n * // => true\r\n */\r\nexport function some<T>(arr: readonly T[], propertyToCheck: string): boolean;\r\n\r\n/**\r\n * Checks if there is an element in an array that matches the given partial object.\r\n *\r\n * @param {T[]} arr The array to iterate over.\r\n * @param {Partial<T>} doesMatch The partial object to match.\r\n * @returns {boolean} Returns `true` if any element matches the partial object, else `false`.\r\n *\r\n * @example\r\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], { a: 2 });\r\n * // => true\r\n */\r\nexport function some<T>(arr: readonly T[], doesMatch: Partial<T>): boolean;\r\n\r\n/**\r\n * Checks if there is an element in an array that matches the given predicate.\r\n *\r\n * Iteration is stopped once there is an element that matches `predicate`.\r\n *\r\n * @param {T[]} arr The array to iterate over.\r\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string} [predicate=identity] The function invoked per iteration.\r\n * If a property name or an object is provided it will be used to create a predicate function.\r\n * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\r\n *\r\n * @example\r\n * some([1, 2, 3, 4], n => n % 2 === 0);\r\n * // => true\r\n *\r\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], { a: 2 });\r\n * // => true\r\n *\r\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], ['a', 2]);\r\n * // => true\r\n *\r\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], 'a');\r\n * // => true\r\n */\r\nexport function some<T>(\r\n  arr: readonly T[] | null | undefined,\r\n  predicate?: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string,\r\n  guard?: unknown\r\n): boolean;\r\n\r\n/**\r\n * Checks if there is an element in an array that matches the given predicate.\r\n *\r\n * Iteration is stopped once there is an element that matches `predicate`.\r\n *\r\n * @param {T[]} arr The array to iterate over.\r\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string} [predicate=identity] The function invoked per iteration.\r\n * If a property name or an object is provided it will be used to create a predicate function.\r\n * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\r\n *\r\n * @example\r\n * some([1, 2, 3, 4], n => n % 2 === 0);\r\n * // => true\r\n *\r\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], { a: 2 });\r\n * // => true\r\n *\r\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], ['a', 2]);\r\n * // => true\r\n *\r\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], 'a');\r\n * // => true\r\n */\r\nexport function some<T>(\r\n  arr: readonly T[] | null | undefined,\r\n  predicate?: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string,\r\n  guard?: unknown\r\n): boolean {\r\n  if (guard != null) {\r\n    predicate = undefined;\r\n  }\r\n\r\n  if (!predicate) {\r\n    predicate = identity;\r\n  }\r\n\r\n  if (!Array.isArray(arr)) {\r\n    return false;\r\n  }\r\n\r\n  switch (typeof predicate) {\r\n    case 'function': {\r\n      return arr.some(predicate);\r\n    }\r\n    case 'object': {\r\n      if (Array.isArray(predicate) && predicate.length === 2) {\r\n        const key = predicate[0];\r\n        const value = predicate[1];\r\n\r\n        return arr.some(matchesProperty(key, value));\r\n      } else {\r\n        return arr.some(matches(predicate));\r\n      }\r\n    }\r\n    case 'string': {\r\n      return arr.some(property(predicate));\r\n    }\r\n  }\r\n}\r\n","import { Criterion, orderBy } from './orderBy.ts';\r\n\r\n/**\r\n * Sorts an array of objects based on multiple properties and their corresponding order directions.\r\n *\r\n * This function takes an array of objects, an array of criteria to sort by.\r\n * It returns the ascending sorted array, ordering by each key.\r\n * If values for a key are equal, it moves to the next key to determine the order.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param { T[] | object | null | undefined} collection - The array of objects to be sorted.\r\n * @param {Criterion<T> | Array<Criterion<T>>} criteria - An array of criteria (property names or property paths or custom key functions) to sort by.\r\n * @returns {T[]} - The ascending sorted array.\r\n *\r\n * @example\r\n * // Sort an array of objects by 'user' in ascending order and 'age' in descending order.\r\n * const users = [\r\n *   { user: 'fred', age: 48 },\r\n *   { user: 'barney', age: 34 },\r\n *   { user: 'fred', age: 40 },\r\n *   { user: 'barney', age: 36 },\r\n * ];\r\n * const result = sortBy(users, ['user', (item) => item.age])\r\n * // result will be:\r\n * // [\r\n * //   { user: 'barney', age: 34 },\r\n * //   { user: 'barney', age: 36 },\r\n * //   { user: 'fred', age: 40 },\r\n * //   { user: 'fred', age: 48 },\r\n * // ]\r\n */\r\nexport function sortBy<T>(\r\n  collection: readonly T[] | object | number | null | undefined,\r\n  criteria?: Criterion<T> | Array<Criterion<T>>\r\n): T[] {\r\n  return orderBy(collection, criteria, ['asc']);\r\n}\r\n","/**\r\n * Creates a new function that spreads elements of an array argument into individual arguments\r\n * for the original function. The array argument is positioned based on the `argsIndex` parameter.\r\n *\r\n * @template F - A function type with any number of parameters and any return type.\r\n * @param {F} func - The function to be transformed. It can be any function with any number of arguments.\r\n * @param {number} [argsIndex=0] - The index where the array argument is positioned among the other arguments.\r\n *   If `argsIndex` is negative or `NaN`, it defaults to `0`. If it's a fractional number, it is rounded to the nearest integer.\r\n * @returns {(...args: any[]) => ReturnType<F>} - A new function that takes multiple arguments, including an array of arguments at the specified `argsIndex`,\r\n *   and returns the result of calling the original function with those arguments.\r\n *\r\n * @example\r\n * function add(a, b) {\r\n *   return a + b;\r\n * }\r\n *\r\n * const spreadAdd = spread(add);\r\n * console.log(spreadAdd([1, 2])); // Output: 3\r\n *\r\n * @example\r\n * // Example function to spread arguments over\r\n * function add(a, b) {\r\n *   return a + b;\r\n * }\r\n *\r\n * // Create a new function that uses `spread` to combine arguments\r\n * const spreadAdd = spread(add, 1);\r\n *\r\n * // Calling `spreadAdd` with an array as the second argument\r\n * console.log(spreadAdd(1, [2])); // Output: 3\r\n *\r\n * @example\r\n * // Function with default arguments\r\n * function greet(name, greeting = 'Hello') {\r\n *   return `${greeting}, ${name}!`;\r\n * }\r\n *\r\n * // Create a new function that uses `spread` to position the argument array at index 0\r\n * const spreadGreet = spread(greet, 0);\r\n *\r\n * // Calling `spreadGreet` with an array of arguments\r\n * console.log(spreadGreet(['Alice'])); // Output: Hello, Alice!\r\n * console.log(spreadGreet(['Bob', 'Hi'])); // Output: Hi, Bob!\r\n */\r\nexport function spread<F extends (...args: any[]) => any>(func: F, argsIndex = 0): (...args: any[]) => ReturnType<F> {\r\n  argsIndex = Number.parseInt(argsIndex as any, 10);\r\n\r\n  if (Number.isNaN(argsIndex) || argsIndex < 0) {\r\n    argsIndex = 0;\r\n  }\r\n\r\n  return function (this: any, ...args: any[]) {\r\n    const array = args[argsIndex];\r\n    const params = args.slice(0, argsIndex);\r\n\r\n    if (array) {\r\n      params.push(...array);\r\n    }\r\n\r\n    return func.apply(this, params);\r\n  };\r\n}\r\n","import { startCase as startCaseToolkit } from '../../string/startCase.ts';\r\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\r\n\r\n/**\r\n * Converts the first character of each word in a string to uppercase and the remaining characters to lowercase.\r\n *\r\n * Start case is the naming convention in which each word is written with an initial capital letter.\r\n * @param {string | object} str - The string to convert.\r\n * @returns {string} The converted string.\r\n *\r\n * @example\r\n * const result1 = startCase('hello world');  // result will be 'Hello World'\r\n * const result2 = startCase('HELLO WORLD');  // result will be 'HELLO WORLD'\r\n * const result3 = startCase('hello-world');  // result will be 'Hello World'\r\n * const result4 = startCase('hello_world');  // result will be 'Hello World'\r\n */\r\nexport function startCase(str?: string | object): string {\r\n  return startCaseToolkit(normalizeForCase(str));\r\n}\r\n","import { getWords } from './_internal/getWords.ts';\r\n\r\n/**\r\n * Converts the first character of each word in a string to uppercase and the remaining characters to lowercase.\r\n *\r\n * Start case is the naming convention in which each word is written with an initial capital letter.\r\n * @param {string} str - The string to convert.\r\n * @returns {string} The converted string.\r\n *\r\n * @example\r\n * const result1 = startCase('hello world');  // result will be 'Hello World'\r\n * const result2 = startCase('HELLO WORLD');  // result will be 'HELLO WORLD'\r\n * const result3 = startCase('hello-world');  // result will be 'Hello World'\r\n * const result4 = startCase('hello_world');  // result will be 'Hello World'\r\n */\r\nexport function startCase(str: string): string {\r\n  const words = getWords(str.trim());\r\n  let result = '';\r\n  for (const word of words) {\r\n    if (result) {\r\n      result += ' ';\r\n    }\r\n    if (word === word.toUpperCase()) {\r\n      result += word;\r\n    } else {\r\n      result += word[0].toUpperCase() + word.slice(1).toLowerCase();\r\n    }\r\n  }\r\n  return result;\r\n}\r\n","/**\r\n * Checks if a string contains another string at the beginning of the string.\r\n *\r\n * Checks if one string startsWith another string. Optional position parameter to start searching from a certain index.\r\n *\r\n * @param {string} str - The string that might contain the target string.\r\n * @param {string} target - The string to search for.\r\n * @param {number} position - An optional offset to start searching in the str string\r\n * @returns {boolean} - True if the str string starts with the target string.\r\n *\r\n * @example\r\n * const isPrefix = startsWith('fooBar', 'foo') // returns true\r\n * const isPrefix = startsWith('fooBar', 'bar') // returns false\r\n * const isPrefix = startsWith('fooBar', 'abc') // returns false\r\n * const isPrefix = startsWith('fooBar', 'Bar', 2) // returns true\r\n * const isPrefix = startsWith('fooBar', 'Bar', 5) // returns false\r\n */\r\nexport function startsWith(str: string, target: string, position = 0): boolean {\r\n  return str.startsWith(target, position);\r\n}\r\n","import { sum } from './sum.ts';\r\n\r\n/**\r\n * Calculates the sum of an array of numbers when applying\r\n * the `getValue` function to each element.\r\n *\r\n * If the array is empty, this function returns `0`.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} items An array to calculate the sum.\r\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\r\n * @returns {number} The sum of all the numbers as determined by the `getValue` function.\r\n *\r\n * @example\r\n * sumBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: 6\r\n * sumBy([], x => x.a); // Returns: 0\r\n */\r\nexport function sumBy<T>(items: readonly T[], getValue: (element: T) => number): number {\r\n  const nums = items.map(x => getValue(x));\r\n\r\n  return sum(nums);\r\n}\r\n","/**\r\n * Returns an empty array when the input is a single-element array.\r\n *\r\n * @template T - The type of the single element in the array.\r\n * @param {[T]} arr - The single-element array to process.\r\n * @returns {[]} An empty array.\r\n *\r\n * @example\r\n * const arr = [1];\r\n * const result = tail(arr);\r\n * // result will be []\r\n */\r\nexport function tail<T>(arr: readonly [T]): [];\r\n\r\n/**\r\n * Returns an empty array when the input is an empty array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {[]} arr - The empty array to process.\r\n * @returns {[]} An empty array.\r\n *\r\n * @example\r\n * const arr = [];\r\n * const result = tail(arr);\r\n * // result will be []\r\n */\r\nexport function tail(arr: readonly []): [];\r\n\r\n/**\r\n * Returns a new array with all elements except for the first when the input is a tuple array.\r\n *\r\n * @template T - The type of the first element in the tuple array.\r\n * @template U - The type of the remaining elements in the tuple array.\r\n * @param {[T, ...U[]]} arr - The tuple array to process.\r\n * @returns {U[]} A new array containing all elements of the input array except for the first one.\r\n *\r\n * @example\r\n * const arr = [1, 2, 3];\r\n * const result = tail(arr);\r\n * // result will be [2, 3]\r\n */\r\nexport function tail<T, U>(arr: readonly [T, ...U[]]): U[];\r\n\r\n/**\r\n * Returns a new array with all elements except for the first.\r\n *\r\n * This function takes an array and returns a new array containing all the elements\r\n * except for the first one. If the input array is empty or has only one element,\r\n * an empty array is returned.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to get the tail of.\r\n * @returns {T[]} A new array containing all elements of the input array except for the first one.\r\n *\r\n * @example\r\n * const arr1 = [1, 2, 3];\r\n * const result = tail(arr1);\r\n * // result will be [2, 3]\r\n *\r\n * const arr2 = [1];\r\n * const result2 = tail(arr2);\r\n * // result2 will be []\r\n *\r\n * const arr3 = [];\r\n * const result3 = tail(arr3);\r\n * // result3 will be []\r\n */\r\nexport function tail<T>(arr: readonly T[]): T[];\r\n\r\n/**\r\n * Returns a new array with all elements except for the first.\r\n *\r\n * This function takes an array and returns a new array containing all the elements\r\n * except for the first one. If the input array is empty or has only one element,\r\n * an empty array is returned.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to get the tail of.\r\n * @returns {T[]} A new array containing all elements of the input array except for the first one.\r\n *\r\n * @example\r\n * const arr1 = [1, 2, 3];\r\n * const result = tail(arr1);\r\n * // result will be [2, 3]\r\n *\r\n * const arr2 = [1];\r\n * const result2 = tail(arr2);\r\n * // result2 will be []\r\n *\r\n * const arr3 = [];\r\n * const result3 = tail(arr3);\r\n * // result3 will be []\r\n */\r\nexport function tail<T>(arr: readonly T[]): T[] {\r\n  return arr.slice(1);\r\n}\r\n","/**\r\n * Returns a new array containing the first `count` elements from the input array `arr`.\r\n * If `count` is greater than the length of `arr`, the entire array is returned.\r\n *\r\n * @template T - Type of elements in the input array.\r\n *\r\n * @param {T[]} arr - The array to take elements from.\r\n * @param {number} count - The number of elements to take.\r\n * @returns {T[]} A new array containing the first `count` elements from `arr`.\r\n *\r\n * @example\r\n * // Returns [1, 2, 3]\r\n * take([1, 2, 3, 4, 5], 3);\r\n *\r\n * @example\r\n * // Returns ['a', 'b']\r\n * take(['a', 'b', 'c'], 2);\r\n *\r\n * @example\r\n * // Returns [1, 2, 3]\r\n * take([1, 2, 3], 5);\r\n */\r\nexport function take<T>(arr: readonly T[], count: number): T[] {\r\n  return arr.slice(0, count);\r\n}\r\n","/**\r\n * Returns a new array containing the last `count` elements from the input array `arr`.\r\n * If `count` is greater than the length of `arr`, the entire array is returned.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to take elements from.\r\n * @param {number} [count=1] - The number of elements to take.\r\n * @returns {T[]} A new array containing the last `count` elements from `arr`.\r\n *\r\n * @example\r\n * // Returns [4, 5]\r\n * takeRight([1, 2, 3, 4, 5], 2);\r\n *\r\n * @example\r\n * // Returns ['b', 'c']\r\n * takeRight(['a', 'b', 'c'], 2);\r\n *\r\n * @example\r\n * // Returns [1, 2, 3]\r\n * takeRight([1, 2, 3], 5);\r\n */\r\nexport function takeRight<T>(arr: readonly T[], count = 1): T[] {\r\n  if (count <= 0) {\r\n    return [];\r\n  }\r\n\r\n  return arr.slice(-count);\r\n}\r\n","/**\r\n * Takes elements from the end of the array while the predicate function returns `true`.\r\n *\r\n * @template T - Type of elements in the input array.\r\n *\r\n * @param {T[]} arr - The array to take elements from.\r\n * @param {(item: T) => boolean} shouldContinueTaking - The function invoked per element.\r\n * @returns {T[]} A new array containing the elements taken from the end while the predicate returns `true`.\r\n *\r\n * @example\r\n * // Returns [3, 2, 1]\r\n * takeRightWhile([5, 4, 3, 2, 1], n => n < 4);\r\n *\r\n * @example\r\n * // Returns []\r\n * takeRightWhile([1, 2, 3], n => n > 3);\r\n */\r\nexport function takeRightWhile<T>(arr: readonly T[], shouldContinueTaking: (item: T) => boolean): T[] {\r\n  for (let i = arr.length - 1; i >= 0; i--) {\r\n    if (!shouldContinueTaking(arr[i])) {\r\n      return arr.slice(i + 1);\r\n    }\r\n  }\r\n\r\n  return arr.slice();\r\n}\r\n","/**\r\n * Returns a new array containing the leading elements of the provided array\r\n * that satisfy the provided predicate function. It stops taking elements as soon\r\n * as an element does not satisfy the predicate.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to process.\r\n * @param {(element: T) => boolean} shouldContinueTaking - The predicate function that is called with each element. Elements are included in the result as long as this function returns true.\r\n * @returns {T[]} A new array containing the leading elements that satisfy the predicate.\r\n *\r\n * @example\r\n * // Returns [1, 2]\r\n * takeWhile([1, 2, 3, 4], x => x < 3);\r\n *\r\n * @example\r\n * // Returns []\r\n * takeWhile([1, 2, 3, 4], x => x > 3);\r\n */\r\nexport function takeWhile<T>(arr: readonly T[], shouldContinueTaking: (element: T) => boolean): T[] {\r\n  const result: T[] = [];\r\n\r\n  for (const item of arr) {\r\n    if (!shouldContinueTaking(item)) {\r\n      break;\r\n    }\r\n\r\n    result.push(item);\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { debounce } from './debounce.ts';\r\n\r\ninterface ThrottleOptions {\r\n  /**\r\n   * An optional AbortSignal to cancel the function invocation on the trailing edge.\r\n   */\r\n  signal?: AbortSignal;\r\n\r\n  /**\r\n   * If `true`, the function will be invoked on the leading edge of the timeout.\r\n   * @default true\r\n   */\r\n  leading?: boolean;\r\n\r\n  /**\r\n   * If `true`, the function will be invoked on the trailing edge of the timeout.\r\n   * @default true\r\n   */\r\n  trailing?: boolean;\r\n}\r\n\r\n/**\r\n * Creates a throttled function that only invokes the provided function at most once\r\n * per every `throttleMs` milliseconds. Subsequent calls to the throttled function\r\n * within the wait time will not trigger the execution of the original function.\r\n *\r\n * @template F - The type of function.\r\n * @param {F} func - The function to throttle.\r\n * @param {number} throttleMs - The number of milliseconds to throttle executions to.\r\n * @param {ThrottleOptions} options - The options object\r\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the throttled function.\r\n * @param {boolean} options.leading - If `true`, the function will be invoked on the leading edge of the timeout.\r\n * @param {boolean} options.trailing - If `true`, the function will be invoked on the trailing edge of the timeout.\r\n * @returns {(...args: Parameters<F>) => void} A new throttled function that accepts the same parameters as the original function.\r\n *\r\n * @example\r\n * const throttledFunction = throttle(() => {\r\n *   console.log('Function executed');\r\n * }, 1000);\r\n *\r\n * // Will log 'Function executed' immediately\r\n * throttledFunction();\r\n *\r\n * // Will not log anything as it is within the throttle time\r\n * throttledFunction();\r\n *\r\n * // After 1 second\r\n * setTimeout(() => {\r\n *   throttledFunction(); // Will log 'Function executed'\r\n * }, 1000);\r\n */\r\nexport function throttle<F extends (...args: any[]) => any>(\r\n  func: F,\r\n  throttleMs: number = 0,\r\n  options: ThrottleOptions = {}\r\n): ((...args: Parameters<F>) => ReturnType<F> | undefined) & {\r\n  cancel: () => void;\r\n  flush: () => void;\r\n} {\r\n  if (typeof options !== 'object') {\r\n    options = {};\r\n  }\r\n\r\n  const { leading = true, trailing = true, signal } = options;\r\n\r\n  return debounce(func, throttleMs, { leading, trailing, signal, maxWait: throttleMs });\r\n}\r\n","/**\r\n * Creates a new array filled with the specified value from the start position up to, but not including, the end position.\r\n * This function does not mutate the original array.\r\n *\r\n * @template T - The type of elements in the original array.\r\n * @template U - The type of the value to fill the new array with.\r\n * @param {Array<T>} arr - The array to base the new array on.\r\n * @param {U} value - The value to fill the new array with.\r\n * @returns {Array<T | U>} The new array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * let result = toFilled(array, '*', 2);\r\n * console.log(result); // [1, 2, '*', '*', '*']\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n *\r\n * result = toFilled(array, '*', 1, 4);\r\n * console.log(result); // [1, '*', '*', '*', 5]\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n *\r\n * result = toFilled(array, '*');\r\n * console.log(result); // ['*', '*', '*', '*', '*']\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n *\r\n * result = toFilled(array, '*', -4, -1);\r\n * console.log(result); // [1, '*', '*', '*', 5]\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n */\r\nexport function toFilled<T, U>(arr: readonly T[], value: U): Array<T | U>;\r\n\r\n/**\r\n * Creates a new array filled with the specified value from the start position up to, but not including, the end position.\r\n * This function does not mutate the original array.\r\n *\r\n * @template T - The type of elements in the original array.\r\n * @template U - The type of the value to fill the new array with.\r\n * @param {Array<T>} arr - The array to base the new array on.\r\n * @param {U} value - The value to fill the new array with.\r\n * @param {number} [start=0] - The start position. Defaults to 0.\r\n * @returns {Array<T | U>} The new array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * let result = toFilled(array, '*', 2);\r\n * console.log(result); // [1, 2, '*', '*', '*']\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n *\r\n * result = toFilled(array, '*', 1, 4);\r\n * console.log(result); // [1, '*', '*', '*', 5]\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n *\r\n * result = toFilled(array, '*');\r\n * console.log(result); // ['*', '*', '*', '*', '*']\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n *\r\n * result = toFilled(array, '*', -4, -1);\r\n * console.log(result); // [1, '*', '*', '*', 5]\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n */\r\nexport function toFilled<T, U>(arr: readonly T[], value: U, start: number): Array<T | U>;\r\n\r\n/**\r\n * Creates a new array filled with the specified value from the start position up to, but not including, the end position.\r\n * This function does not mutate the original array.\r\n *\r\n * @template T - The type of elements in the original array.\r\n * @template U - The type of the value to fill the new array with.\r\n * @param {Array<T>} arr - The array to base the new array on.\r\n * @param {U} value - The value to fill the new array with.\r\n * @param {number} [start=0] - The start position. Defaults to 0.\r\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\r\n * @returns {Array<T | U>} The new array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * let result = toFilled(array, '*', 2);\r\n * console.log(result); // [1, 2, '*', '*', '*']\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n *\r\n * result = toFilled(array, '*', 1, 4);\r\n * console.log(result); // [1, '*', '*', '*', 5]\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n *\r\n * result = toFilled(array, '*');\r\n * console.log(result); // ['*', '*', '*', '*', '*']\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n *\r\n * result = toFilled(array, '*', -4, -1);\r\n * console.log(result); // [1, '*', '*', '*', 5]\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n */\r\nexport function toFilled<T, U>(arr: readonly T[], value: U, start: number, end: number): Array<T | U>;\r\n\r\n/**\r\n * Creates a new array filled with the specified value from the start position up to, but not including, the end position.\r\n * This function does not mutate the original array.\r\n *\r\n * @template T - The type of elements in the original array.\r\n * @template U - The type of the value to fill the new array with.\r\n * @param {Array<T>} arr - The array to base the new array on.\r\n * @param {U} value - The value to fill the new array with.\r\n * @param {number} [start=0] - The start position. Defaults to 0.\r\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\r\n * @returns {Array<T | U>} The new array with the filled values.\r\n */\r\nexport function toFilled<T, U>(arr: readonly T[], value: U, start = 0, end = arr.length): Array<T | U> {\r\n  const length = arr.length;\r\n  const finalStart = Math.max(start >= 0 ? start : length + start, 0);\r\n  const finalEnd = Math.min(end >= 0 ? end : length + end, length);\r\n\r\n  const newArr: Array<T | U> = arr.slice();\r\n\r\n  for (let i = finalStart; i < finalEnd; i++) {\r\n    newArr[i] = value;\r\n  }\r\n\r\n  return newArr;\r\n}\r\n","import { cloneDeep } from './cloneDeep.ts';\r\nimport { merge } from './merge.ts';\r\n\r\n/**\r\n * Merges the properties of the source object into a deep clone of the target object.\r\n * Unlike `merge`, This function does not modify the original target object.\r\n *\r\n * This function performs a deep merge, meaning nested objects and arrays are merged recursively.\r\n *\r\n * - If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * - If a property in the source object is undefined, it will not overwrite a defined property in the target object.\r\n *\r\n * Note that this function does not mutate the target object.\r\n *\r\n * @param {T} target - The target object to be cloned and merged into. This object is not modified directly.\r\n * @param {S} source - The source object whose properties will be merged into the cloned target object.\r\n * @returns {T & S} A new object with properties from the source object merged into a deep clone of the target object.\r\n *\r\n * @template T - Type of the target object.\r\n * @template S - Type of the source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = toMerged(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = toMerged(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3, 2], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = toMerged(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function toMerged<T, S>(target: T, source: S): T & S;\r\n/**\r\n * Merges the properties of the source object into a deep clone of the target object.\r\n * Unlike `merge`, This function does not modify the original target object.\r\n *\r\n * This function performs a deep merge, meaning nested objects and arrays are merged recursively.\r\n *\r\n * - If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * - If a property in the source object is undefined, it will not overwrite a defined property in the target object.\r\n *\r\n * Note that this function does not mutate the target object.\r\n *\r\n * @param {T} target - The target object to be cloned and merged into. This object is not modified directly.\r\n * @param {S} source - The source object whose properties will be merged into the cloned target object.\r\n * @returns {T & S} A new object with properties from the source object merged into a deep clone of the target object.\r\n *\r\n * @template T - Type of the target object.\r\n * @template S - Type of the source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = toMerged(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = toMerged(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3, 2], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = toMerged(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function toMerged(target: any, source: any) {\r\n  return merge(cloneDeep(target), source);\r\n}\r\n","import { trim as trimToolkit } from '../../string/trim.ts';\r\n\r\n/**\r\n * Removes leading and trailing whitespace or specified characters from a string.\r\n *\r\n * @param {string} str - The string from which leading and trailing characters will be trimmed.\r\n * @param {string | string[]} chars - The character(s) to remove from the end of the string. Defaults to `\" \"`.\r\n * @returns {string} - The resulting string after the specified leading and trailing characters have been removed.\r\n *\r\n * @example\r\n * trim(\"  hello  \"); // \"hello\"\r\n * trim(\"--hello--\", \"-\"); // \"hello\"\r\n * trim(\"##hello##\", [\"#\", \"o\"]); // \"hell\"\r\n */\r\nexport function trim(str: string, chars?: string | string[], guard?: unknown): string {\r\n  if (str == null) {\r\n    return '';\r\n  }\r\n\r\n  if (guard != null || chars == null) {\r\n    return str.toString().trim();\r\n  }\r\n\r\n  switch (typeof chars) {\r\n    case 'string': {\r\n      return trimToolkit(str, chars.toString().split(''));\r\n    }\r\n    case 'object': {\r\n      if (Array.isArray(chars)) {\r\n        return trimToolkit(\r\n          str,\r\n          chars.map(x => x.toString())\r\n        );\r\n      } else {\r\n        return trimToolkit(str, (chars as any).toString().split(''));\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { trimEnd as trimEndToolkit } from '../../string/trimEnd.ts';\r\n\r\n/**\r\n * Removes trailing whitespace or specified characters from a string.\r\n *\r\n * @param {string} str - The string from which trailing characters will be trimmed.\r\n * @param {string | string[]} chars - The character(s) to remove from the end of the string. Defaults to `\" \"`.\r\n * @returns {string} - The resulting string after the specified trailing character has been removed.\r\n *\r\n * @example\r\n * const trimmedStr1 = trimEnd('hello---', '-') // returns 'hello'\r\n * const trimmedStr2 = trimEnd('123000', '0') // returns '123'\r\n * const trimmedStr3 = trimEnd('abcabcabc', 'c') // returns 'abcabcab'\r\n * const trimmedStr4 = trimEnd('trimmedxxx', 'x') // returns 'trimmed'\r\n */\r\nexport function trimEnd(str: string, chars?: string | string[], guard?: unknown): string {\r\n  if (str == null) {\r\n    return '';\r\n  }\r\n\r\n  if (guard != null || chars == null) {\r\n    return str.toString().trimEnd();\r\n  }\r\n\r\n  switch (typeof chars) {\r\n    case 'string': {\r\n      return trimEndToolkit(str, chars.toString().split(''));\r\n    }\r\n    case 'object': {\r\n      if (Array.isArray(chars)) {\r\n        return trimEndToolkit(\r\n          str,\r\n          chars.map(x => x.toString())\r\n        );\r\n      } else {\r\n        return trimEndToolkit(str, (chars as any).toString().split(''));\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { trimStart as trimStartToolkit } from '../../string/trimStart.ts';\r\n\r\n/**\r\n * Removes leading whitespace or specified characters from a string.\r\n *\r\n * @param {string} str - The string from which leading characters will be trimmed.\r\n * @param {string | string[]} chars - The character(s) to remove from the end of the string. Defaults to `\" \"`.\r\n * @returns {string} - The resulting string after the specified leading character has been removed.\r\n *\r\n * @example\r\n * const trimmedStr1 = ltrim('---hello', '-') // returns 'hello'\r\n * const trimmedStr2 = ltrim('000123', '0') // returns '123'\r\n * const trimmedStr3 = ltrim('abcabcabc', 'a') // returns 'bcabcabc'\r\n * const trimmedStr4 = ltrim('xxxtrimmed', 'x') // returns 'trimmed'\r\n */\r\nexport function trimStart(str: string, chars?: string | string[], guard?: unknown): string {\r\n  if (str == null) {\r\n    return '';\r\n  }\r\n\r\n  if (guard != null || chars == null) {\r\n    return str.toString().trimStart();\r\n  }\r\n\r\n  switch (typeof chars) {\r\n    case 'string': {\r\n      return trimStartToolkit(str, chars.toString().split(''));\r\n    }\r\n    case 'object': {\r\n      if (Array.isArray(chars)) {\r\n        return trimStartToolkit(\r\n          str,\r\n          chars.map(x => x.toString())\r\n        );\r\n      } else {\r\n        return trimStartToolkit(str, (chars as any).toString().split(''));\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { ary } from './ary.ts';\r\n\r\n/**\r\n * Creates a function that accepts up to one argument, ignoring any additional arguments.\r\n *\r\n * @template F - The type of the function.\r\n * @param {F} func - The function to cap arguments for.\r\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new capped function.\r\n *\r\n * @example\r\n * function fn(a, b, c) {\r\n *   console.log(arguments);\r\n * }\r\n *\r\n * unary(fn)(1, 2, 3); // [Arguments] { '0': 1 }\r\n */\r\nexport function unary<F extends (...args: any[]) => any>(func: F): (...args: any[]) => ReturnType<F> {\r\n  return ary(func, 1);\r\n}\r\n","/**\r\n * Returns a new array containing only the unique elements from the original array,\r\n * based on the values returned by the mapper function.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @template U - The type of mapped elements.\r\n * @param {T[]} arr - The array to process.\r\n * @param {(item: T) => U} mapper - The function used to convert the array elements.\r\n * @returns {T[]} A new array containing only the unique elements from the original array, based on the values returned by the mapper function.\r\n *\r\n * @example\r\n * ```ts\r\n * uniqBy([1.2, 1.5, 2.1, 3.2, 5.7, 5.3, 7.19], Math.floor);\r\n * // [1.2, 2.1, 3.2, 5.7, 7.19]\r\n * ```\r\n *\r\n * @example\r\n * const array = [\r\n *   { category: 'fruit', name: 'apple' },\r\n *   { category: 'fruit', name: 'banana' },\r\n *   { category: 'vegetable', name: 'carrot' },\r\n * ];\r\n * uniqBy(array, item => item.category).length\r\n * // 2\r\n * ```\r\n */\r\nexport function uniqBy<T, U>(arr: readonly T[], mapper: (item: T) => U): T[] {\r\n  const map = new Map<U, T>();\r\n\r\n  for (const item of arr) {\r\n    const key = mapper(item);\r\n\r\n    if (!map.has(key)) {\r\n      map.set(key, item);\r\n    }\r\n  }\r\n\r\n  return Array.from(map.values());\r\n}\r\n","/**\r\n * Gathers elements in the same position in an internal array\r\n * from a grouped array of elements and returns them as a new array.\r\n *\r\n * @template T - The type of elements in the nested array.\r\n * @param {Array<[...T]>} zipped - The nested array to unzip.\r\n * @returns {Unzip<T>} A new array of unzipped elements.\r\n *\r\n * @example\r\n * const zipped = [['a', true, 1],['b', false, 2]];\r\n * const result = unzip(zipped);\r\n * // result will be [['a', 'b'], [true, false], [1, 2]]\r\n */\r\nexport function unzip<T extends unknown[]>(zipped: ReadonlyArray<[...T]>): Unzip<T> {\r\n  // For performance reasons, use this implementation instead of\r\n  // const maxLen = Math.max(...zipped.map(arr => arr.length));\r\n  let maxLen = 0;\r\n\r\n  for (let i = 0; i < zipped.length; i++) {\r\n    if (zipped[i].length > maxLen) {\r\n      maxLen = zipped[i].length;\r\n    }\r\n  }\r\n\r\n  const result = new Array(maxLen) as Unzip<T>;\r\n\r\n  for (let i = 0; i < maxLen; i++) {\r\n    result[i] = new Array(zipped.length);\r\n    for (let j = 0; j < zipped.length; j++) {\r\n      result[i][j] = zipped[j][i];\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\ntype Unzip<K extends unknown[]> = { [I in keyof K]: Array<K[I]> };\r\n","/**\r\n * Unzips an array of arrays, applying an `iteratee` function to regrouped elements.\r\n *\r\n * @template T, R\r\n * @param {T[][]} target - The nested array to unzip. This is an array of arrays,\r\n * where each inner array contains elements to be unzipped.\r\n * @param {(...args: T[]) => R} iteratee - A function to transform the unzipped elements.\r\n * @returns {R[]} A new array of unzipped and transformed elements.\r\n *\r\n * @example\r\n * const nestedArray = [[1, 2], [3, 4], [5, 6]];\r\n * const result = unzipWith(nestedArray, (item, item2, item3) => item + item2 + item3);\r\n * // result will be [9, 12]\r\n */\r\nexport function unzipWith<T, R>(target: readonly T[][], iteratee: (...args: T[]) => R): R[] {\r\n  const maxLength = Math.max(...target.map(innerArray => innerArray.length));\r\n  const result: R[] = new Array(maxLength);\r\n\r\n  for (let i = 0; i < maxLength; i++) {\r\n    const group = new Array(target.length);\r\n\r\n    for (let j = 0; j < target.length; j++) {\r\n      group[j] = target[j][i];\r\n    }\r\n\r\n    result[i] = iteratee(...group);\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { upperCase as upperCaseToolkit } from '../../string';\r\nimport { normalizeForCase } from '../_internal/normalizeForCase';\r\n\r\n/**\r\n * Converts a string to upper case.\r\n *\r\n * Upper case is the naming convention in which each word is written in uppercase and separated by an space ( ) character.\r\n *\r\n * @param {string | object} str - The string that is to be changed to upper case.\r\n * @returns {string} - The converted string to upper case.\r\n *\r\n * @example\r\n * const convertedStr1 = upperCase('camelCase') // returns 'CAMEL CASE'\r\n * const convertedStr2 = upperCase('some whitespace') // returns 'SOME WHITESPACE'\r\n * const convertedStr3 = upperCase('hyphen-text') // returns 'HYPHEN TEXT'\r\n * const convertedStr4 = upperCase('HTTPRequest') // returns 'HTTP REQUEST'\r\n */\r\nexport function upperCase(str?: string | object): string {\r\n  return upperCaseToolkit(normalizeForCase(str));\r\n}\r\n","import { getWords } from './_internal/getWords.ts';\r\n\r\n/**\r\n * Converts a string to upper case.\r\n *\r\n * Upper case is the naming convention in which each word is written in uppercase and separated by an space ( ) character.\r\n *\r\n * @param {string} str - The string that is to be changed to upper case.\r\n * @returns {string} - The converted string to upper case.\r\n *\r\n * @example\r\n * const convertedStr1 = upperCase('camelCase') // returns 'CAMEL CASE'\r\n * const convertedStr2 = upperCase('some whitespace') // returns 'SOME WHITESPACE'\r\n * const convertedStr3 = upperCase('hyphen-text') // returns 'HYPHEN TEXT'\r\n * const convertedStr4 = upperCase('HTTPRequest') // returns 'HTTP REQUEST'\r\n */\r\nexport function upperCase(str: string): string {\r\n  const words = getWords(str);\r\n\r\n  let result = '';\r\n\r\n  for (let i = 0; i < words.length; i++) {\r\n    result += words[i].toUpperCase();\r\n    if (i < words.length - 1) {\r\n      result += ' ';\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Converts the first character of string to upper case.\r\n *\r\n * @param {string} str - The string that is to be changed\r\n * @returns {string} - The converted string.\r\n *\r\n * @example\r\n * const convertedStr1 = upperCase('fred') // returns 'fred'\r\n * const convertedStr2 = upperCase('Fred') // returns 'Fred'\r\n * const convertedStr3 = upperCase('FRED') // returns 'FRED'\r\n */\r\nexport function upperFirst(str: string): string {\r\n  return str.substring(0, 1).toUpperCase() + str.substring(1);\r\n}\r\n","import { timeout } from './timeout.ts';\r\n\r\n/**\r\n * Executes an async function and enforces a timeout.\r\n *\r\n * If the promise does not resolve within the specified time,\r\n * the timeout will trigger and the returned promise will be rejected.\r\n *\r\n *\r\n * @template T\r\n * @param {() => Promise<T>} run - A function that returns a promise to be executed.\r\n * @param {number} ms - The timeout duration in milliseconds.\r\n * @returns {Promise<T>} A promise that resolves with the result of the `run` function or rejects if the timeout is reached.\r\n *\r\n * @example\r\n * try {\r\n *   await withTimeout(() => {}, 1000); // Timeout exception after 1 second\r\n * } catch (error) {\r\n *   console.error(error); // Will log 'TimeoutError'\r\n * }\r\n */\r\nexport async function withTimeout<T>(run: () => Promise<T>, ms: number): Promise<T> {\r\n  return Promise.race([run(), timeout(ms) as T]);\r\n}\r\n","/**\r\n * Creates an array that excludes all specified values.\r\n *\r\n * It correctly excludes `NaN`, as it compares values using [SameValueZero](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-samevaluezero).\r\n *\r\n * @template T The type of elements in the array.\r\n * @param {T[]} array - The array to filter.\r\n * @param {...T[]} values - The values to exclude.\r\n * @returns {T[]} A new array without the specified values.\r\n *\r\n * @example\r\n * // Removes the specified values from the array\r\n * without([1, 2, 3, 4, 5], 2, 4);\r\n * // Returns: [1, 3, 5]\r\n *\r\n * @example\r\n * // Removes specified string values from the array\r\n * without(['a', 'b', 'c', 'a'], 'a');\r\n * // Returns: ['b', 'c']\r\n */\r\nexport function without<T>(array: readonly T[], ...values: T[]): T[] {\r\n  const valuesSet = new Set(values);\r\n  return array.filter(item => !valuesSet.has(item));\r\n}\r\n","import { difference } from './difference.ts';\r\nimport { intersection } from './intersection.ts';\r\nimport { union } from './union.ts';\r\n\r\n/**\r\n * Computes the symmetric difference between two arrays. The symmetric difference is the set of elements\r\n * which are in either of the arrays, but not in their intersection.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr1 - The first array.\r\n * @param {T[]} arr2 - The second array.\r\n * @returns {T[]} An array containing the elements that are present in either `arr1` or `arr2` but not in both.\r\n *\r\n * @example\r\n * // Returns [1, 2, 5, 6]\r\n * xor([1, 2, 3, 4], [3, 4, 5, 6]);\r\n *\r\n * @example\r\n * // Returns ['a', 'c']\r\n * xor(['a', 'b'], ['b', 'c']);\r\n */\r\nexport function xor<T>(arr1: readonly T[], arr2: readonly T[]): T[] {\r\n  return difference(union(arr1, arr2), intersection(arr1, arr2));\r\n}\r\n","import { differenceBy } from './differenceBy.ts';\r\nimport { intersectionBy } from './intersectionBy.ts';\r\nimport { unionBy } from './unionBy.ts';\r\n\r\n/**\r\n * Computes the symmetric difference between two arrays using a custom mapping function.\r\n * The symmetric difference is the set of elements which are in either of the arrays,\r\n * but not in their intersection, determined by the result of the mapping function.\r\n *\r\n * @template T - Type of elements in the input arrays.\r\n * @template U - Type of the values returned by the mapping function.\r\n *\r\n * @param {T[]} arr1 - The first array.\r\n * @param {T[]} arr2 - The second array.\r\n * @param {(item: T) => U} mapper - The function to map array elements to comparison values.\r\n * @returns {T[]} An array containing the elements that are present in either `arr1` or `arr2` but not in both, based on the values returned by the mapping function.\r\n *\r\n * @example\r\n * // Custom mapping function for objects with an 'id' property\r\n * const idMapper = obj => obj.id;\r\n * xorBy([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], idMapper);\r\n * // Returns [{ id: 1 }, { id: 3 }]\r\n */\r\nexport function xorBy<T, U>(arr1: readonly T[], arr2: readonly T[], mapper: (item: T) => U): T[] {\r\n  const union = unionBy(arr1, arr2, mapper);\r\n  const intersection = intersectionBy(arr1, arr2, mapper);\r\n\r\n  return differenceBy(union, intersection, mapper);\r\n}\r\n","import { differenceWith } from './differenceWith.ts';\r\nimport { intersectionWith } from './intersectionWith.ts';\r\nimport { unionWith } from './unionWith.ts';\r\n\r\n/**\r\n * Computes the symmetric difference between two arrays using a custom equality function.\r\n * The symmetric difference is the set of elements which are in either of the arrays,\r\n * but not in their intersection.\r\n *\r\n * @template T - Type of elements in the input arrays.\r\n *\r\n * @param {T[]} arr1 - The first array.\r\n * @param {T[]} arr2 - The second array.\r\n * @param {(item1: T, item2: T) => boolean} areElementsEqual - The custom equality function to compare elements.\r\n * @returns {T[]} An array containing the elements that are present in either `arr1` or `arr2` but not in both, based on the custom equality function.\r\n *\r\n * @example\r\n * // Custom equality function for objects with an 'id' property\r\n * const areObjectsEqual = (a, b) => a.id === b.id;\r\n * xorWith([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], areObjectsEqual);\r\n * // Returns [{ id: 1 }, { id: 3 }]\r\n */\r\nexport function xorWith<T>(\r\n  arr1: readonly T[],\r\n  arr2: readonly T[],\r\n  areElementsEqual: (item1: T, item2: T) => boolean\r\n): T[] {\r\n  const union = unionWith(arr1, arr2, areElementsEqual);\r\n  const intersection = intersectionWith(arr1, arr2, areElementsEqual);\r\n\r\n  return differenceWith(union, intersection, areElementsEqual);\r\n}\r\n","/**\r\n * Combines two arrays, one of property names and one of corresponding values, into a single object.\r\n *\r\n * This function takes two arrays: one containing property names and another containing corresponding values.\r\n * It returns a new object where the property names from the first array are keys, and the corresponding elements\r\n * from the second array are values. If the `keys` array is longer than the `values` array, the remaining keys will\r\n * have `undefined` as their values.\r\n *\r\n * @template P - The type of elements in the array.\r\n * @template V - The type of elements in the array.\r\n * @param {P[]} keys - An array of property names.\r\n * @param {V[]} values - An array of values corresponding to the property names.\r\n * @returns {Record<P, V>} - A new object composed of the given property names and values.\r\n *\r\n * @example\r\n * const keys = ['a', 'b', 'c'];\r\n * const values = [1, 2, 3];\r\n * const result = zipObject(keys, values);\r\n * // result will be { a: 1, b: 2, c: 3 }\r\n *\r\n * const keys2 = ['a', 'b', 'c'];\r\n * const values2 = [1, 2];\r\n * const result2 = zipObject(keys2, values2);\r\n * // result2 will be { a: 1, b: 2, c: undefined }\r\n *\r\n * const keys2 = ['a', 'b'];\r\n * const values2 = [1, 2, 3];\r\n * const result2 = zipObject(keys2, values2);\r\n * // result2 will be { a: 1, b: 2 }\r\n */\r\nexport function zipObject<P extends PropertyKey, V>(keys: readonly P[], values: readonly V[]): Record<P, V> {\r\n  const result = {} as Record<P, V>;\r\n\r\n  for (let i = 0; i < keys.length; i++) {\r\n    result[keys[i]] = values[i];\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { zip } from '../../array/zip.ts';\r\nimport { set } from '../object/set.ts';\r\n\r\n/**\r\n * Creates a deeply nested object given arrays of paths and values.\r\n *\r\n * This function takes two arrays: one containing arrays of property paths, and the other containing corresponding values.\r\n * It returns a new object where paths from the first array are used as key paths to set values, with corresponding elements from the second array as values.\r\n * Paths can be dot-separated strings or arrays of property names.\r\n *\r\n * If the `keys` array is longer than the `values` array, the remaining keys will have `undefined` as their values.\r\n *\r\n * @template P - The type of property paths.\r\n * @template V - The type of values corresponding to the property paths.\r\n * @param {P[] | P[][]} keys - An array of property paths, each path can be a dot-separated string or an array of property names.\r\n * @param {V[]} values - An array of values corresponding to the property paths.\r\n * @returns {object} A new object composed of the given property paths and values.\r\n *\r\n * @example\r\n * const paths = ['a.b.c', 'd.e.f'];\r\n * const values = [1, 2];\r\n * const result = zipObjectDeep(paths, values);\r\n * // result will be { a: { b: { c: 1 } }, d: { e: { f: 2 } } }\r\n *\r\n * @example\r\n * const paths = [['a', 'b', 'c'], ['d', 'e', 'f']];\r\n * const values = [1, 2];\r\n * const result = zipObjectDeep(paths, values);\r\n * // result will be { a: { b: { c: 1 } }, d: { e: { f: 2 } } }\r\n *\r\n * @example\r\n * const paths = ['a.b[0].c', 'a.b[1].d'];\r\n * const values = [1, 2];\r\n * const result = zipObjectDeep(paths, values);\r\n * // result will be { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\r\n */\r\nexport function zipObjectDeep<P extends PropertyKey, V>(\r\n  keys: readonly P[] | readonly P[][],\r\n  values: readonly V[]\r\n): { [K in P]: V } {\r\n  const result = {} as { [K in P]: V };\r\n  const zipped = zip<P | P[], V>(keys, values);\r\n\r\n  for (let i = 0; i < zipped.length; i++) {\r\n    const [key, value] = zipped[i];\r\n\r\n    if (key != null) {\r\n      set(result, key, value);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Combines multiple arrays into a single array using a custom combiner function.\r\n *\r\n * This function takes multiple arrays and a combiner function, and returns a new array where each element\r\n * is the result of applying the combiner function to the corresponding elements of the input arrays.\r\n *\r\n * @template T - The type of elements in the first array.\r\n * @template R - The type of elements in the resulting array.\r\n * @param {T[]} arr1 - The first array to zip.\r\n * @param {(...items: T[]) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\r\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\r\n *\r\n * @example\r\n * // Example usage with two arrays:\r\n * const arr1 = [1, 2, 3];\r\n * const arr2 = [4, 5, 6];\r\n * const result = zipWith(arr1, arr2, (a, b) => a + b);\r\n * // result will be [5, 7, 9]\r\n *\r\n * @example\r\n * // Example usage with three arrays:\r\n * const arr1 = [1, 2];\r\n * const arr2 = [3, 4];\r\n * const arr3 = [5, 6];\r\n * const result = zipWith(arr1, arr2, arr3, (a, b, c) => `${a}${b}${c}`);\r\n * // result will be [`135`, `246`]\r\n */\r\nexport function zipWith<T, R>(arr1: readonly T[], combine: (item: T) => R): R[];\r\n/**\r\n * Combines two arrays into a single array using a custom combiner function.\r\n *\r\n * @template T - The type of elements in the first array.\r\n * @template U - The type of elements in the second array.\r\n * @template R - The type of elements in the resulting array.\r\n * @param {T[]} arr1 - The first array to zip.\r\n * @param {U[]} arr2 - The second array to zip.\r\n * @param {(item1: T, item2: U) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\r\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\r\n */\r\nexport function zipWith<T, U, R>(arr1: readonly T[], arr2: readonly U[], combine: (item1: T, item2: U) => R): R[];\r\n/**\r\n * Combines three arrays into a single array using a custom combiner function.\r\n *\r\n * @template T - The type of elements in the first array.\r\n * @template U - The type of elements in the second array.\r\n * @template V - The type of elements in the third array.\r\n * @template R - The type of elements in the resulting array.\r\n * @param {T[]} arr1 - The first array to zip.\r\n * @param {U[]} arr2 - The second array to zip.\r\n * @param {V[]} arr3 - The third array to zip.\r\n * @param {(item1: T, item2: U, item3: V) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\r\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\r\n */\r\nexport function zipWith<T, U, V, R>(\r\n  arr1: readonly T[],\r\n  arr2: readonly U[],\r\n  arr3: readonly V[],\r\n  combine: (item1: T, item2: U, item3: V) => R\r\n): R[];\r\n/**\r\n * Combines four arrays into a single array using a custom combiner function.\r\n *\r\n * @template T - The type of elements in the first array.\r\n * @template U - The type of elements in the second array.\r\n * @template V - The type of elements in the third array.\r\n * @template W - The type of elements in the fourth array.\r\n * @template R - The type of elements in the resulting array.\r\n * @param {T[]} arr1 - The first array to zip.\r\n * @param {U[]} arr2 - The second array to zip.\r\n * @param {V[]} arr3 - The third array to zip.\r\n * @param {W[]} arr4 - The fourth array to zip.\r\n * @param {(item1: T, item2: U, item3: V, item4: W) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\r\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\r\n */\r\nexport function zipWith<T, U, V, W, R>(\r\n  arr1: readonly T[],\r\n  arr2: readonly U[],\r\n  arr3: readonly V[],\r\n  arr4: readonly W[],\r\n  combine: (item1: T, item2: U, item3: V, item4: W) => R\r\n): R[];\r\n\r\n/**\r\n * Combines multiple arrays into a single array using a custom combiner function.\r\n *\r\n * This function takes one array and a variable number of additional arrays,\r\n * applying the provided combiner function to the corresponding elements of each array.\r\n * If the input arrays are of different lengths, the resulting array will have the length\r\n * of the longest input array, with undefined values for missing elements.\r\n *\r\n * @template T - The type of elements in the input arrays.\r\n * @template R - The type of elements in the resulting array.\r\n * @param {T[]} arr1 - The first array to zip.\r\n * @param {...Array<T[]>} rest - The additional arrays to zip together, followed by the combiner function.\r\n * @param {(...items: T[]) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\r\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\r\n *\r\n * @example\r\n * const arr1 = [1, 2, 3];\r\n * const arr2 = ['a', 'b', 'c'];\r\n * const result = zipWith(arr1, arr2, (num, char) => `${num}${char}`);\r\n * // result will be ['1a', '2b', '3c']\r\n */\r\nexport function zipWith<T, R>(arr1: readonly T[], ...rest: any[]): R[] {\r\n  const arrs = [arr1, ...rest.slice(0, -1)];\r\n  const combine = rest[rest.length - 1] as (...items: T[]) => R;\r\n\r\n  const maxIndex = Math.max(...arrs.map(arr => arr.length));\r\n  const result: R[] = Array(maxIndex);\r\n\r\n  for (let i = 0; i < maxIndex; i++) {\r\n    const elements: T[] = arrs.map(arr => arr[i]);\r\n    result[i] = combine(...elements);\r\n  }\r\n\r\n  return result;\r\n}\r\n"],"names":["at","arr","indices","result","i","length","index","difference","firstArr","secondArr","secondSet","Set","filter","item","has","differenceBy","mapper","mappedSecondSet","map","differenceWith","areItemsEqual","firstItem","every","secondItem","flatten","depth","flooredDepth","Math","floor","recursive","currentDepth","Array","isArray","push","head","intersection","intersectionBy","intersectionWith","some","random","minimum","maximum","Error","randomInt","uniq","from","union","arr1","arr2","concat","unionBy","Map","key","set","values","uniqWith","v","unionWith","zip","arrs","rowCount","max","x","columnCount","row","j","AbortError","constructor","message","super","this","name","TimeoutError","debounce","func","debounceMs","signal","edges","pendingThis","pendingArgs","leading","includes","trailing","invoke","apply","undefined","timeoutId","schedule","clearTimeout","setTimeout","cancel","onTimerEnd","cancelTimer","debounced","args","aborted","isFirstCall","flush","addEventListener","once","noop","ary","n","slice","partial","partialArgs","providedArgs","startIndex","arg","placeholder","partialPlaceholder","Symbol","partialRight","placeholderLength","partialRightPlaceholder","rangeLength","providedIndex","sum","nums","mean","isTypedArray","ArrayBuffer","isView","DataView","isPrimitive","value","clone","obj","SharedArrayBuffer","prototype","Object","getPrototypeOf","Constructor","Date","RegExp","newRegExp","lastIndex","buffer","newError","stack","cause","File","type","lastModified","newObject","create","assign","isPlainObject","object","toString","proto","flattenObjectImpl","prefix","keys","prefixedKey","mapKeys","getNewKey","mapValues","getNewValue","cloneDeep","cloneDeepImpl","get","hasOwnProperty","call","input","getTime","source","flags","entries","add","Buffer","isBuffer","subarray","copyProperties","Blob","target","descriptor","getOwnPropertyDescriptor","writable","isObjectLike","merge","sourceKeys","sourceValue","targetValue","stringTag","numberTag","booleanTag","argumentsTag","objectTag","getSymbols","getOwnPropertySymbols","symbol","propertyIsEnumerable","getTag","areObjectsEqual","a","b","is","aTag","bTag","valueOf","y","Number","isNaN","aStack","bStack","size","aValues","bValues","aValue","findIndex","bValue","splice","byteLength","Uint8Array","byteOffset","aKeys","bKeys","propKey","aProp","delete","isLength","isSafeInteger","delay","ms","Promise","resolve","reject","abortError","abortHandler","removeEventListener","async","timeout","capitalize","str","charAt","toUpperCase","toLowerCase","CASE_SPLIT_PATTERN","getWords","match","trimStart","chars","substring","trimEnd","endIndex","trim","deburrMap","htmlEscapes","htmlUnescapes","isDeepKey","toKey","DOTS_KEY","ESCAPE_REGEXP","PROPERTY_REGEXP","toPath","deepKey","test","split","matches","matchAll","expr","quote","substr","replace","path","defaultValue","getWithPath","current","String","property","isMatch","isArrayMatch","isMapMatch","isSetMatch","countedIndex","sourceItem","targetItem","cloneDeepToolkit","iterator","IS_UNSIGNED_INTEGER","isIndex","isInteger","MAX_SAFE_INTEGER","isArguments","resolvedPath","matchesProperty","Boolean","isConcatSpreadable","getPriority","compareValues","order","localeCompare","aPriority","bPriority","isSymbol","regexIsDeepProp","regexIsPlainProp","orderBy","collection","criteria","orders","getValueByNestedPath","preparedCriteria","criterion","isKey","original","hasOwn","getValueByCriterion","sort","comparedResult","identity","nextKey","bind","thisObj","bound","bindPlaceholder","bindKey","bindKeyPlaceholder","curry","arity","guard","parseInt","wrapper","partials","holders","replaceHolders","makeCurry","curryPlaceholder","holdersCount","composeArgs","argsLength","holdersLength","argsIndex","leftIndex","newHolders","options","maxWait","pendingAt","_debounced","debounceToolkit","now","isNil","unset","unsetWithPath","parent","lastKey","tag","toStringTag","isTypedArrayToolkit","mergeWith","otherArgs","sources","mergeWithDeep","cloned","targetKeys","Reflect","ownKeys","targetKey","merged","isArrayLike","conformsTo","predicate","join","normalizeForCase","clamp","bound1","bound2","min","clampToolkit","decimalAdjust","number","precision","magnitude","exponent","adjustedValue","newMagnitude","newExponent","after","counter","aryToolkit","attempt","e","before","camelCase","words","first","rest","word","camelCaseToolkit","castArray","arguments","ceil","chunk","chunkLength","start","end","chunkToolkit","compact","conforms","countBy","deburr","normalize","char","differenceToolkit","drop","itemsCount","dropRight","dropRightWhile","canContinueDropping","dropWhile","dropEndIndex","endsWith","position","escape","escapeRegExp","fill","array","finalStart","finalEnd","fillToolkit","find","doesMatch","entry","findLastIndex","fromIndex","flatMap","iteratee","flatMapDeep","flattenDeep","Infinity","flattenDepth","flattenObject","forEachRight","callback","fromPairs","pairs","groupBy","getKeyFromItem","inRange","inRangeToolkit","indexOf","searchElement","initial","invert","isArrayLikeObject","isBoolean","isDate","isEqual","isFunction","isNotNil","isNull","isNumber","isObject","isRegExp","isString","isSubset","superset","subset","isUndefined","isWeakMap","WeakMap","isWeakMapToolkit","isWeakSet","WeakSet","isWeakSetToolkit","separator","kebabCase","kebabCaseToolkit","keyBy","last","lowerCase","lowerCaseToolkit","lowerFirst","mapKeysToolkit","mapValuesToolkit","items","maxElement","element","maxBy","getValue","meanBy","memoize","fn","cache","getCacheKey","memoizedFn","minElement","minBy","negate","omit","keysArr","omitBy","shouldOmit","called","pad","padStart","padEnd","string","radix","partition","isInTruthy","truthy","falsy","pascalCase","pick","pickBy","shouldPick","pullAt","indicesToRemove","removed","floating","randomToolkit","randomIntToolkit","range","step","rearg","flattenIndices","reorderedArgs","repeat","params","restToolkit","round","sample","sampleSize","selected","resultIndex","shuffle","snakeCase","snakeCaseToolkit","sortBy","spread","startCase","startCaseToolkit","startsWith","sumBy","tail","take","count","takeRight","takeRightWhile","shouldContinueTaking","takeWhile","throttle","throttleMs","toFilled","newArr","toMerged","trimToolkit","trimEndToolkit","trimStartToolkit","unary","unescape","uniqBy","unzip","zipped","maxLen","unzipWith","maxLength","innerArray","group","upperCase","upperCaseToolkit","upperFirst","withTimeout","run","race","without","valuesSet","xor","xorBy","xorWith","areElementsEqual","zipObject","zipObjectDeep","zipWith","combine","maxIndex","elements"],"mappings":"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"}