{"version":3,"file":"browser.global.js","sources":["../src/array/at.ts","../src/array/difference.ts","../src/array/differenceBy.ts","../src/array/differenceWith.ts","../src/array/flatten.ts","../src/array/head.ts","../src/array/intersection.ts","../src/array/intersectionBy.ts","../src/array/intersectionWith.ts","../src/math/random.ts","../src/math/randomInt.ts","../src/array/uniq.ts","../src/array/union.ts","../src/array/unionBy.ts","../src/array/uniqWith.ts","../src/array/unionWith.ts","../src/array/zip.ts","../src/error/AbortError.ts","../src/error/TimeoutError.ts","../src/function/debounce.ts","../src/function/noop.ts","../src/function/ary.ts","../src/function/partial.ts","../src/function/partialRight.ts","../src/math/sum.ts","../src/math/mean.ts","../src/predicate/isTypedArray.ts","../src/predicate/isPrimitive.ts","../src/object/clone.ts","../src/predicate/isPlainObject.ts","../src/object/flattenObject.ts","../src/object/mapKeys.ts","../src/object/mapValues.ts","../src/object/cloneDeep.ts","../src/compat/predicate/isObjectLike.ts","../src/object/merge.ts","../src/compat/_internal/tags.ts","../src/compat/_internal/getSymbols.ts","../src/compat/_internal/getTag.ts","../src/predicate/isEqual.ts","../src/predicate/isLength.ts","../src/promise/delay.ts","../src/promise/timeout.ts","../src/string/capitalize.ts","../src/string/_internal/getWords.ts","../src/string/trimStart.ts","../src/string/trimEnd.ts","../src/string/trim.ts","../src/string/deburr.ts","../src/string/escape.ts","../src/string/unescape.ts","../src/compat/_internal/isDeepKey.ts","../src/compat/_internal/toKey.ts","../src/compat/util/toPath.ts","../src/compat/object/get.ts","../src/compat/object/property.ts","../src/compat/predicate/isMatch.ts","../src/compat/predicate/matches.ts","../src/compat/object/cloneDeep.ts","../src/compat/_internal/isIndex.ts","../src/compat/predicate/isArguments.ts","../src/compat/object/has.ts","../src/compat/predicate/matchesProperty.ts","../src/compat/array/flatten.ts","../src/compat/_internal/compareValues.ts","../src/compat/predicate/isSymbol.ts","../src/compat/_internal/isKey.ts","../src/compat/array/orderBy.ts","../src/compat/_internal/identity.ts","../src/compat/object/set.ts","../src/compat/function/bind.ts","../src/compat/function/bindKey.ts","../src/compat/function/curry.ts","../src/compat/function/debounce.ts","../src/compat/predicate/isNil.ts","../src/compat/object/unset.ts","../src/compat/predicate/isPlainObject.ts","../src/compat/predicate/isTypedArray.ts","../src/compat/object/mergeWith.ts","../src/compat/predicate/isArrayLike.ts","../src/compat/predicate/conformsTo.ts","../src/compat/util/toString.ts","../src/compat/_internal/normalizeForCase.ts","../src/compat/math/clamp.ts","../src/math/clamp.ts","../src/compat/_internal/decimalAdjust.ts","../src/compat/util/toNumber.ts","../src/compat/util/toFinite.ts","../src/function/after.ts","../src/compat/function/ary.ts","../src/compat/function/attempt.ts","../src/function/before.ts","../src/compat/string/camelCase.ts","../src/string/camelCase.ts","../src/compat/array/castArray.ts","../src/compat/math/ceil.ts","../src/compat/array/chunk.ts","../src/array/chunk.ts","../src/array/compact.ts","../src/compat/array/concat.ts","../src/compat/predicate/conforms.ts","../src/string/constantCase.ts","../src/array/countBy.ts","../src/compat/function/defer.ts","../src/compat/array/difference.ts","../src/compat/array/drop.ts","../src/array/dropRight.ts","../src/array/dropRightWhile.ts","../src/array/dropWhile.ts","../src/compat/string/endsWith.ts","../src/string/escapeRegExp.ts","../src/compat/array/fill.ts","../src/array/fill.ts","../src/compat/array/find.ts","../src/compat/array/findIndex.ts","../src/compat/array/findLastIndex.ts","../src/array/flatMap.ts","../src/array/flatMapDeep.ts","../src/array/flattenDeep.ts","../src/compat/array/flattenDeep.ts","../src/compat/array/flattenDepth.ts","../src/compat/math/floor.ts","../src/function/flow.ts","../src/array/forEachRight.ts","../src/compat/object/fromPairs.ts","../src/array/groupBy.ts","../src/compat/math/inRange.ts","../src/math/inRange.ts","../src/compat/array/indexOf.ts","../src/array/initial.ts","../src/object/invert.ts","../src/compat/predicate/isArray.ts","../src/compat/predicate/isArrayLikeObject.ts","../src/compat/predicate/isBoolean.ts","../src/predicate/isDate.ts","../src/compat/predicate/isError.ts","../src/compat/predicate/isFinite.ts","../src/predicate/isFunction.ts","../src/compat/predicate/isInteger.ts","../src/predicate/isMap.ts","../src/compat/predicate/isNaN.ts","../src/predicate/isNotNil.ts","../src/predicate/isNull.ts","../src/compat/predicate/isNumber.ts","../src/compat/predicate/isObject.ts","../src/compat/predicate/isRegExp.ts","../src/predicate/isRegExp.ts","../src/compat/predicate/isSafeInteger.ts","../src/predicate/isSet.ts","../src/compat/predicate/isString.ts","../src/array/isSubset.ts","../src/predicate/isUndefined.ts","../src/compat/predicate/isWeakMap.ts","../src/predicate/isWeakMap.ts","../src/compat/predicate/isWeakSet.ts","../src/predicate/isWeakSet.ts","../src/compat/array/join.ts","../src/compat/string/kebabCase.ts","../src/string/kebabCase.ts","../src/array/keyBy.ts","../src/array/last.ts","../src/compat/string/lowerCase.ts","../src/string/lowerCase.ts","../src/string/lowerFirst.ts","../src/compat/object/mapKeys.ts","../src/compat/object/mapValues.ts","../src/compat/math/max.ts","../src/array/maxBy.ts","../src/math/meanBy.ts","../src/function/memoize.ts","../src/compat/object/merge.ts","../src/compat/math/min.ts","../src/array/minBy.ts","../src/function/negate.ts","../src/compat/object/omit.ts","../src/object/omitBy.ts","../src/function/once.ts","../src/compat/string/pad.ts","../src/string/pad.ts","../src/compat/string/padEnd.ts","../src/compat/string/padStart.ts","../src/compat/math/parseInt.ts","../src/array/partition.ts","../src/string/pascalCase.ts","../src/compat/object/pick.ts","../src/object/pickBy.ts","../src/array/pullAt.ts","../src/compat/math/random.ts","../src/math/range.ts","../src/compat/function/rearg.ts","../src/compat/string/repeat.ts","../src/compat/function/rest.ts","../src/function/rest.ts","../src/compat/math/round.ts","../src/array/sample.ts","../src/array/sampleSize.ts","../src/array/shuffle.ts","../src/compat/array/size.ts","../src/predicate/isNil.ts","../src/compat/string/snakeCase.ts","../src/string/snakeCase.ts","../src/compat/array/some.ts","../src/compat/array/sortBy.ts","../src/compat/function/spread.ts","../src/compat/string/startCase.ts","../src/compat/string/startsWith.ts","../src/math/sumBy.ts","../src/array/tail.ts","../src/array/take.ts","../src/array/takeRight.ts","../src/array/takeRightWhile.ts","../src/array/takeWhile.ts","../src/compat/function/throttle.ts","../src/array/toFilled.ts","../src/compat/util/toInteger.ts","../src/object/toMerged.ts","../src/compat/string/trim.ts","../src/compat/string/trimEnd.ts","../src/compat/string/trimStart.ts","../src/function/unary.ts","../src/array/uniqBy.ts","../src/array/unzip.ts","../src/array/unzipWith.ts","../src/compat/string/upperCase.ts","../src/string/upperCase.ts","../src/string/upperFirst.ts","../src/promise/withTimeout.ts","../src/array/without.ts","../src/array/xor.ts","../src/array/xorBy.ts","../src/array/xorWith.ts","../src/array/zipObject.ts","../src/compat/array/zipObjectDeep.ts","../src/array/zipWith.ts"],"sourcesContent":["/**\r\n * Retrieves elements from an array at the specified indices.\r\n *\r\n * This function supports negative indices, which count from the end of the array.\r\n *\r\n * @template T\r\n * @param {readonly T[]} arr - The array to retrieve elements from.\r\n * @param {number[]} indices - An array of indices specifying the positions of elements to retrieve.\r\n * @returns {Array<T | undefined>} A new array containing the elements at the specified indices.\r\n *\r\n * @example\r\n * const numbers = [10, 20, 30, 40, 50];\r\n * const result = at(numbers, [1, 3, 4]);\r\n * console.log(result); // [20, 40, 50]\r\n */\r\nexport function at<T>(arr: readonly T[], indices: number[]): Array<T | undefined> {\r\n  const result: Array<T | undefined> = [];\r\n\r\n  for (let i = 0; i < indices.length; i++) {\r\n    const index = indices[i];\r\n\r\n    result[i] = arr.at(index);\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Computes the difference between two arrays.\r\n *\r\n * This function takes two arrays and returns a new array containing the elements\r\n * that are present in the first array but not in the second array. It effectively\r\n * filters out any elements from the first array that also appear in the second array.\r\n *\r\n * @template T\r\n * @param {T[]} firstArr - The array from which to derive the difference. This is the primary array\r\n * from which elements will be compared and filtered.\r\n * @param {T[]} secondArr - The array containing elements to be excluded from the first array.\r\n * Each element in this array will be checked against the first array, and if a match is found,\r\n * that element will be excluded from the result.\r\n * @returns {T[]} A new array containing the elements that are present in the first array but not\r\n * in the second array.\r\n *\r\n * @example\r\n * const array1 = [1, 2, 3, 4, 5];\r\n * const array2 = [2, 4];\r\n * const result = difference(array1, array2);\r\n * // result will be [1, 3, 5] since 2 and 4 are in both arrays and are excluded from the result.\r\n */\r\nexport function difference<T>(firstArr: readonly T[], secondArr: readonly T[]): T[] {\r\n  const secondSet = new Set(secondArr);\r\n\r\n  return firstArr.filter(item => !secondSet.has(item));\r\n}\r\n","/**\r\n * Computes the difference between two arrays after mapping their elements through a provided function.\r\n *\r\n * This function takes two arrays and a mapper function. It returns a new array containing the elements\r\n * that are present in the first array but not in the second array, based on the identity calculated\r\n * by the mapper function.\r\n *\r\n * Essentially, it filters out any elements from the first array that, when\r\n * mapped, match an element in the mapped version of the second array.\r\n *\r\n * @template T, U\r\n * @param {T[]} firstArr - The primary array from which to derive the difference.\r\n * @param {T[]} secondArr - The array containing elements to be excluded from the first array.\r\n * @param {(value: T) => U} mapper - The function to map the elements of both arrays. This function\r\n * is applied to each element in both arrays, and the comparison is made based on the mapped values.\r\n * @returns {T[]} A new array containing the elements from the first array that do not have a corresponding\r\n * mapped identity in the second array.\r\n *\r\n * @example\r\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\r\n * const array2 = [{ id: 2 }, { id: 4 }];\r\n * const mapper = item => item.id;\r\n * const result = differenceBy(array1, array2, mapper);\r\n * // result will be [{ id: 1 }, { id: 3 }] since the elements with id 2 are in both arrays and are excluded from the result.\r\n */\r\nexport function differenceBy<T, U>(firstArr: readonly T[], secondArr: readonly T[], mapper: (value: T) => U): T[] {\r\n  const mappedSecondSet = new Set(secondArr.map(item => mapper(item)));\r\n\r\n  return firstArr.filter(item => {\r\n    return !mappedSecondSet.has(mapper(item));\r\n  });\r\n}\r\n","/**\r\n * Computes the difference between two arrays based on a custom equality function.\r\n *\r\n * This function takes two arrays and a custom comparison function. It returns a new array containing\r\n * the elements that are present in the first array but not in the second array. The comparison to determine\r\n * if elements are equal is made using the provided custom function.\r\n *\r\n * @template T\r\n * @param {T[]} firstArr - The array from which to get the difference.\r\n * @param {T[]} secondArr - The array containing elements to exclude from the first array.\r\n * @param {(x: T, y: T) => boolean} areItemsEqual - A function to determine if two items are equal.\r\n * @returns {T[]} A new array containing the elements from the first array that do not match any elements in the second array\r\n * according to the custom equality function.\r\n *\r\n * @example\r\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\r\n * const array2 = [{ id: 2 }, { id: 4 }];\r\n * const areItemsEqual = (a, b) => a.id === b.id;\r\n * const result = differenceWith(array1, array2, areItemsEqual);\r\n * // result will be [{ id: 1 }, { id: 3 }] since the elements with id 2 are considered equal and are excluded from the result.\r\n */\r\nexport function differenceWith<T>(\r\n  firstArr: readonly T[],\r\n  secondArr: readonly T[],\r\n  areItemsEqual: (x: T, y: T) => boolean\r\n): T[] {\r\n  return firstArr.filter(firstItem => {\r\n    return secondArr.every(secondItem => {\r\n      return !areItemsEqual(firstItem, secondItem);\r\n    });\r\n  });\r\n}\r\n","/**\r\n * Flattens an array up to the specified depth.\r\n *\r\n * @template T - The type of elements within the array.\r\n * @template D - The depth to which the array should be flattened.\r\n * @param {T[]} arr - The array to flatten.\r\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\r\n * @returns {Array<FlatArray<T[], D>>} A new array that has been flattened.\r\n *\r\n * @example\r\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 1);\r\n * // Returns: [1, 2, 3, 4, [5, 6]]\r\n *\r\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 2);\r\n * // Returns: [1, 2, 3, 4, 5, 6]\r\n */\r\nexport function flatten<T, D extends number = 1>(arr: readonly T[], depth = 1 as D): Array<FlatArray<T[], D>> {\r\n  const result: Array<FlatArray<T[], D>> = [];\r\n  const flooredDepth = Math.floor(depth);\r\n\r\n  const recursive = (arr: readonly T[], currentDepth: number) => {\r\n    for (let i = 0; i < arr.length; i++) {\r\n      const item = arr[i];\r\n      if (Array.isArray(item) && currentDepth < flooredDepth) {\r\n        recursive(item, currentDepth + 1);\r\n      } else {\r\n        result.push(item as FlatArray<T[], D>);\r\n      }\r\n    }\r\n  };\r\n\r\n  recursive(arr, 0);\r\n  return result;\r\n}\r\n","/**\r\n * Returns the first element of an array.\r\n *\r\n * This function takes an array and returns the first element of the array.\r\n * If the array is empty, the function returns `undefined`.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {[T, ...T[]]} arr - A non-empty array from which to get the first element.\r\n * @returns {T} The first element of the array.\r\n *\r\n * @example\r\n * const arr = [1, 2, 3];\r\n * const firstElement = head(arr);\r\n * // firstElement will be 1\r\n */\r\nexport function head<T>(arr: readonly [T, ...T[]]): T;\r\n\r\n/**\r\n * Returns the first element of an array or `undefined` if the array is empty.\r\n *\r\n * This function takes an array and returns the first element of the array.\r\n * If the array is empty, the function returns `undefined`.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array from which to get the first element.\r\n * @returns {T | undefined} The first element of the array, or `undefined` if the array is empty.\r\n *\r\n * @example\r\n * const emptyArr: number[] = [];\r\n * const noElement = head(emptyArr);\r\n * // noElement will be undefined\r\n */\r\nexport function head<T>(arr: readonly T[]): T | undefined;\r\n\r\n/**\r\n * Returns the first element of an array or `undefined` if the array is empty.\r\n *\r\n * This function takes an array and returns the first element of the array.\r\n * If the array is empty, the function returns `undefined`.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array from which to get the first element.\r\n * @returns {T | undefined} The first element of the array, or `undefined` if the array is empty.\r\n *\r\n * @example\r\n * const emptyArr: number[] = [];\r\n * const noElement = head(emptyArr);\r\n * // noElement will be undefined\r\n */\r\nexport function head<T>(arr: readonly T[]): T | undefined {\r\n  return arr[0];\r\n}\r\n","/**\r\n * Returns the intersection of two arrays.\r\n *\r\n * This function takes two arrays and returns a new array containing the elements that are\r\n * present in both arrays. It effectively filters out any elements from the first array that\r\n * are not found in the second array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} firstArr - The first array to compare.\r\n * @param {T[]} secondArr - The second array to compare.\r\n * @returns {T[]} A new array containing the elements that are present in both arrays.\r\n *\r\n * @example\r\n * const array1 = [1, 2, 3, 4, 5];\r\n * const array2 = [3, 4, 5, 6, 7];\r\n * const result = intersection(array1, array2);\r\n * // result will be [3, 4, 5] since these elements are in both arrays.\r\n */\r\nexport function intersection<T>(firstArr: readonly T[], secondArr: readonly T[]): T[] {\r\n  const secondSet = new Set(secondArr);\r\n\r\n  return firstArr.filter(item => {\r\n    return secondSet.has(item);\r\n  });\r\n}\r\n","/**\r\n * Returns the intersection of two arrays based on a mapping function.\r\n *\r\n * This function takes two arrays and a mapping function. It returns a new array containing\r\n * the elements from the first array that, when mapped using the provided function, have matching\r\n * mapped elements in the second array. It effectively filters out any elements from the first array\r\n * that do not have corresponding mapped values in the second array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @template U - The type of mapped elements.\r\n * @param {T[]} firstArr - The first array to compare.\r\n * @param {T[]} secondArr - The second array to compare.\r\n * @param {(item: T) => U} mapper - A function to map the elements of both arrays for comparison.\r\n * @returns {T[]} A new array containing the elements from the first array that have corresponding mapped values in the second array.\r\n *\r\n * @example\r\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\r\n * const array2 = [{ id: 2 }, { id: 4 }];\r\n * const mapper = item => item.id;\r\n * const result = intersectionBy(array1, array2, mapper);\r\n * // result will be [{ id: 2 }] since only this element has a matching id in both arrays.\r\n */\r\nexport function intersectionBy<T, U>(firstArr: readonly T[], secondArr: readonly T[], mapper: (item: T) => U): T[] {\r\n  const mappedSecondSet = new Set(secondArr.map(mapper));\r\n  return firstArr.filter(item => mappedSecondSet.has(mapper(item)));\r\n}\r\n","/**\r\n * Returns the intersection of two arrays based on a custom equality function.\r\n *\r\n * This function takes two arrays and a custom equality function. It returns a new array containing\r\n * the elements from the first array that have matching elements in the second array, as determined\r\n * by the custom equality function. It effectively filters out any elements from the first array that\r\n * do not have corresponding matches in the second array according to the equality function.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} firstArr - The first array to compare.\r\n * @param {T[]} secondArr - The second array to compare.\r\n * @param {(x: T, y: T) => boolean} areItemsEqual - A custom function to determine if two elements are equal.\r\n * This function takes two arguments, one from each array, and returns `true` if the elements are considered equal, and `false` otherwise.\r\n * @returns {T[]} A new array containing the elements from the first array that have corresponding matches in the second array according to the custom equality function.\r\n *\r\n * @example\r\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\r\n * const array2 = [{ id: 2 }, { id: 4 }];\r\n * const areItemsEqual = (a, b) => a.id === b.id;\r\n * const result = intersectionWith(array1, array2, areItemsEqual);\r\n * // result will be [{ id: 2 }] since this element has a matching id in both arrays.\r\n */\r\nexport function intersectionWith<T>(\r\n  firstArr: readonly T[],\r\n  secondArr: readonly T[],\r\n  areItemsEqual: (x: T, y: T) => boolean\r\n): T[] {\r\n  return firstArr.filter(firstItem => {\r\n    return secondArr.some(secondItem => {\r\n      return areItemsEqual(firstItem, secondItem);\r\n    });\r\n  });\r\n}\r\n","/**\r\n * Generate a random number within the given range.\r\n *\r\n * If only one argument is provided, a number between `0` and the given number is returned.\r\n *\r\n * @param {number} maximum - The upper bound (exclusive).\r\n * @returns {number} A random number between 0 (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\r\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\r\n *\r\n * @example\r\n * const result1 = random(5); // Returns a random number between 0 and 5.\r\n * const result2 = random(0); // If the `maximum` is less than or equal to 0, an error is thrown.\r\n */\r\nexport function random(maximum: number): number;\r\n\r\n/**\r\n * Generate a random number within the given range.\r\n *\r\n * @param {number} minimum - The lower bound (inclusive).\r\n * @param {number} maximum - The upper bound (exclusive).\r\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\r\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\r\n *\r\n * @example\r\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\r\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown.\r\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\r\n */\r\nexport function random(minimum: number, maximum: number): number;\r\n\r\n/**\r\n * Generate a random number within the given range.\r\n *\r\n * @param {number} minimum - The lower bound (inclusive).\r\n * @param {number} maximum - The upper bound (exclusive).\r\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\r\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\r\n *\r\n * @example\r\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\r\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown.\r\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\r\n */\r\nexport function random(minimum: number, maximum?: number): number {\r\n  if (maximum == null) {\r\n    maximum = minimum;\r\n    minimum = 0;\r\n  }\r\n\r\n  if (minimum >= maximum) {\r\n    throw new Error('Invalid input: The maximum value must be greater than the minimum value.');\r\n  }\r\n\r\n  return Math.random() * (maximum - minimum) + minimum;\r\n}\r\n","import { random } from './random.ts';\r\n\r\n/**\r\n * Generates a random integer between 0 (inclusive) and the given maximum (exclusive).\r\n *\r\n * @param {number} maximum - The upper bound (exclusive).\r\n * @returns {number} A random integer between 0 (inclusive) and maximum (exclusive).\r\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\r\n *\r\n * @example\r\n * const result = randomInt(5); // result will be a random integer between 0 (inclusive) and 5 (exclusive)\r\n */\r\nexport function randomInt(maximum: number): number;\r\n\r\n/**\r\n * Generates a random integer between minimum (inclusive) and maximum (exclusive).\r\n *\r\n * @param {number} minimum - The lower bound (inclusive).\r\n * @param {number} maximum - The upper bound (exclusive).\r\n * @returns {number} A random integer between minimum (inclusive) and maximum (exclusive).\r\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\r\n *\r\n * @example\r\n * const result = randomInt(0, 5); // result will be a random integer between 0 (inclusive) and 5 (exclusive)\r\n * const result2 = randomInt(5, 0); // This will throw an error\r\n */\r\nexport function randomInt(minimum: number, maximum: number): number;\r\n\r\n/**\r\n * Generates a random integer between minimum (inclusive) and maximum (exclusive).\r\n *\r\n * If only one argument is provided, a number between `0` and the given number is returned.\r\n *\r\n * @param {number} minimum - The lower bound (inclusive).\r\n * @param {number} maximum - The upper bound (exclusive).\r\n * @returns {number} A random integer between minimum (inclusive) and maximum (exclusive).\r\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\r\n *\r\n * @example\r\n * const result = randomInt(0, 5); // result will be a random integer between 0 (inclusive) and 5 (exclusive)\r\n * const result2 = randomInt(5, 0); // This will throw an error\r\n */\r\nexport function randomInt(minimum: number, maximum?: number): number {\r\n  return Math.floor(random(minimum, maximum!));\r\n}\r\n","/**\r\n * Creates a duplicate-free version of an array.\r\n *\r\n * This function takes an array and returns a new array containing only the unique values\r\n * from the original array, preserving the order of first occurrence.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to process.\r\n * @returns {T[]} A new array with only unique values from the original array.\r\n *\r\n * @example\r\n * const array = [1, 2, 2, 3, 4, 4, 5];\r\n * const result = uniq(array);\r\n * // result will be [1, 2, 3, 4, 5]\r\n */\r\nexport function uniq<T>(arr: readonly T[]): T[] {\r\n  return Array.from(new Set(arr));\r\n}\r\n","import { uniq } from './uniq.ts';\r\n\r\n/**\r\n * Creates an array of unique values from all given arrays.\r\n *\r\n * This function takes two arrays, merges them into a single array, and returns a new array\r\n * containing only the unique values from the merged array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr1 - The first array to merge and filter for unique values.\r\n * @param {T[]} arr2 - The second array to merge and filter for unique values.\r\n * @returns {T[]} A new array of unique values.\r\n *\r\n * @example\r\n * const array1 = [1, 2, 3];\r\n * const array2 = [3, 4, 5];\r\n * const result = union(array1, array2);\r\n * // result will be [1, 2, 3, 4, 5]\r\n */\r\nexport function union<T>(arr1: readonly T[], arr2: readonly T[]): T[] {\r\n  return uniq(arr1.concat(arr2));\r\n}\r\n","/**\r\n * Creates an array of unique values, in order, from all given arrays using a provided mapping function to determine equality.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @template U - The type of mapped elements.\r\n * @param {T[]} arr1 - The first array.\r\n * @param {T[]} arr2 - The second array.\r\n * @param {(item: T) => U} mapper - The function to map array elements to comparison values.\r\n * @returns {T[]} A new array containing the union of unique elements from `arr1` and `arr2`, based on the values returned by the mapping function.\r\n *\r\n * @example\r\n * // Custom mapping function for numbers (modulo comparison)\r\n * const moduloMapper = (x) => x % 3;\r\n * unionBy([1, 2, 3], [4, 5, 6], moduloMapper);\r\n * // Returns [1, 2, 3]\r\n *\r\n * @example\r\n * // Custom mapping function for objects with an 'id' property\r\n * const idMapper = (obj) => obj.id;\r\n * unionBy([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], idMapper);\r\n * // Returns [{ id: 1 }, { id: 2 }, { id: 3 }]\r\n */\r\nexport function unionBy<T, U>(arr1: readonly T[], arr2: readonly T[], mapper: (item: T) => U): T[] {\r\n  const map = new Map<U, T>();\r\n\r\n  const items = [...arr1, ...arr2];\r\n  for (let i = 0; i < items.length; i++) {\r\n    const item = items[i];\r\n    const key = mapper(item);\r\n\r\n    if (!map.has(key)) {\r\n      map.set(key, item);\r\n    }\r\n  }\r\n\r\n  return Array.from(map.values());\r\n}\r\n","/**\r\n * Returns a new array containing only the unique elements from the original array,\r\n * based on the values returned by the comparator function.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to process.\r\n * @param {(item1: T, item2: T) => boolean} areItemsEqual - The function used to compare the array elements.\r\n * @returns {T[]} A new array containing only the unique elements from the original array, based on the values returned by the comparator function.\r\n *\r\n * @example\r\n * ```ts\r\n * uniqWith([1.2, 1.5, 2.1, 3.2, 5.7, 5.3, 7.19], (a, b) => Math.abs(a - b) < 1);\r\n * // [1.2, 3.2, 5.7, 7.19]\r\n * ```\r\n */\r\nexport function uniqWith<T>(arr: readonly T[], areItemsEqual: (item1: T, item2: T) => boolean): T[] {\r\n  const result: T[] = [];\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const item = arr[i];\r\n    const isUniq = result.every(v => !areItemsEqual(v, item));\r\n\r\n    if (isUniq) {\r\n      result.push(item);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { uniqWith } from './uniqWith.ts';\r\n\r\n/**\r\n * Creates an array of unique values from two given arrays based on a custom equality function.\r\n *\r\n * This function takes two arrays and a custom equality function, merges the arrays, and returns\r\n * a new array containing only the unique values as determined by the custom equality function.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr1 - The first array to merge and filter for unique values.\r\n * @param {T[]} arr2 - The second array to merge and filter for unique values.\r\n * @param {(item1: T, item2: T) => boolean} areItemsEqual - A custom function to determine if two elements are equal.\r\n * It takes two arguments and returns `true` if the elements are considered equal, and `false` otherwise.\r\n * @returns {T[]} A new array of unique values based on the custom equality function.\r\n *\r\n * @example\r\n * const array1 = [{ id: 1 }, { id: 2 }];\r\n * const array2 = [{ id: 2 }, { id: 3 }];\r\n * const areItemsEqual = (a, b) => a.id === b.id;\r\n * const result = unionWith(array1, array2, areItemsEqual);\r\n * // result will be [{ id: 1 }, { id: 2 }, { id: 3 }] since { id: 2 } is considered equal in both arrays\r\n */\r\nexport function unionWith<T>(\r\n  arr1: readonly T[],\r\n  arr2: readonly T[],\r\n  areItemsEqual: (item1: T, item2: T) => boolean\r\n): T[] {\r\n  return uniqWith(arr1.concat(arr2), areItemsEqual);\r\n}\r\n","/**\r\n * Combines multiple arrays into a single array of tuples.\r\n *\r\n * This function takes multiple arrays and returns a new array where each element is a tuple\r\n * containing the corresponding elements from the input arrays. If the input arrays are of\r\n * different lengths, the resulting array will have the length of the longest input array,\r\n * with undefined values for missing elements.\r\n *\r\n * @template T\r\n * @param {T[]} arr1 - The first array to zip.\r\n * @returns {Array<[T]>} A new array of tuples containing the corresponding elements from the input arrays.\r\n *\r\n * @example\r\n * const arr1 = [1, 2, 3];\r\n * const result = zip(arr1);\r\n * // result will be [[1], [2], [3]]\r\n */\r\nexport function zip<T>(arr1: readonly T[]): Array<[T]>;\r\n\r\n/**\r\n * Combines multiple arrays into a single array of tuples.\r\n *\r\n * This function takes multiple arrays and returns a new array where each element is a tuple\r\n * containing the corresponding elements from the input arrays. If the input arrays are of\r\n * different lengths, the resulting array will have the length of the longest input array,\r\n * with undefined values for missing elements.\r\n *\r\n * @template T, U\r\n * @param {T[]} arr1 - The first array to zip.\r\n * @param {U[]} arr2 - The second array to zip.\r\n * @returns {Array<[T, U]>} A new array of tuples containing the corresponding elements from the input arrays.\r\n *\r\n * @example\r\n * const arr1 = [1, 2, 3];\r\n * const arr2 = ['a', 'b', 'c'];\r\n * const result = zip(arr1, arr2);\r\n * // result will be [[1, 'a'], [2, 'b'], [3, 'c']]\r\n */\r\nexport function zip<T, U>(arr1: readonly T[], arr2: readonly U[]): Array<[T, U]>;\r\n\r\n/**\r\n * Combines multiple arrays into a single array of tuples.\r\n *\r\n * This function takes multiple arrays and returns a new array where each element is a tuple\r\n * containing the corresponding elements from the input arrays. If the input arrays are of\r\n * different lengths, the resulting array will have the length of the longest input array,\r\n * with undefined values for missing elements.\r\n *\r\n * @template T, U, V\r\n * @param {T[]} arr1 - The first array to zip.\r\n * @param {U[]} arr2 - The second array to zip.\r\n * @param {V[]} arr3 - The third array to zip.\r\n * @returns {Array<[T, U, V]>} A new array of tuples containing the corresponding elements from the input arrays.\r\n *\r\n * @example\r\n * const arr1 = [1, 2, 3];\r\n * const arr2 = ['a', 'b', 'c'];\r\n * const arr3 = [true, false];\r\n * const result = zip(arr1, arr2, arr3);\r\n * // result will be [[1, 'a', true], [2, 'b', false], [3, 'c', undefined]]\r\n */\r\nexport function zip<T, U, V>(arr1: readonly T[], arr2: readonly U[], arr3: readonly V[]): Array<[T, U, V]>;\r\n\r\n/**\r\n * Combines multiple arrays into a single array of tuples.\r\n *\r\n * This function takes multiple arrays and returns a new array where each element is a tuple\r\n * containing the corresponding elements from the input arrays. If the input arrays are of\r\n * different lengths, the resulting array will have the length of the longest input array,\r\n * with undefined values for missing elements.\r\n *\r\n * @template T, U, V, W\r\n * @param {T[]} arr1 - The first array to zip.\r\n * @param {U[]} arr2 - The second array to zip.\r\n * @param {V[]} arr3 - The third array to zip.\r\n * @param {W[]} arr4 - The fourth array to zip.\r\n * @returns {Array<[T, U, V, W]>} A new array of tuples containing the corresponding elements from the input arrays.\r\n *\r\n * @example\r\n * const arr1 = [1, 2, 3];\r\n * const arr2 = ['a', 'b', 'c'];\r\n * const arr3 = [true, false];\r\n * const arr4 = [null, null, null];\r\n * const result = zip(arr1, arr2, arr3, arr4);\r\n * // result will be [[1, 'a', true, null], [2, 'b', false, null], [3, 'c', undefined, null]]\r\n */\r\nexport function zip<T, U, V, W>(\r\n  arr1: readonly T[],\r\n  arr2: readonly U[],\r\n  arr3: readonly V[],\r\n  arr4: readonly W[]\r\n): Array<[T, U, V, W]>;\r\n\r\n/**\r\n * Combines multiple arrays into a single array of tuples.\r\n *\r\n * This function takes multiple arrays and returns a new array where each element is a tuple\r\n * containing the corresponding elements from the input arrays. If the input arrays are of\r\n * different lengths, the resulting array will have the length of the longest input array,\r\n * with undefined values for missing elements.\r\n *\r\n * @template T\r\n * @param {...Array<readonly T[]>} arrs - The arrays to zip together.\r\n * @returns {T[][]} A new array of tuples containing the corresponding elements from the input arrays.\r\n *\r\n * @example\r\n * const arr1 = [1, 2, 3];\r\n * const arr2 = ['a', 'b', 'c'];\r\n * const arr3 = [true, false];\r\n * const result = zip(arr1, arr2, arr3);\r\n * // result will be [[1, 'a', true], [2, 'b', false], [3, 'c', undefined]]\r\n */\r\nexport function zip<T>(...arrs: Array<readonly T[]>): T[][] {\r\n  const rowCount = Math.max(...arrs.map(x => x.length));\r\n  const columnCount = arrs.length;\r\n  const result = Array(rowCount);\r\n\r\n  for (let i = 0; i < rowCount; ++i) {\r\n    const row = Array(columnCount);\r\n    for (let j = 0; j < columnCount; ++j) {\r\n      row[j] = arrs[j][i];\r\n    }\r\n    result[i] = row;\r\n  }\r\n  return result;\r\n}\r\n","/**\r\n * An error class representing an aborted operation.\r\n * @augments Error\r\n */\r\nexport class AbortError extends Error {\r\n  constructor(message = 'The operation was aborted') {\r\n    super(message);\r\n    this.name = 'AbortError';\r\n  }\r\n}\r\n","/**\r\n * An error class representing an timeout operation.\r\n * @augments Error\r\n */\r\nexport class TimeoutError extends Error {\r\n  constructor(message = 'The operation was timed out') {\r\n    super(message);\r\n    this.name = 'TimeoutError';\r\n  }\r\n}\r\n","interface DebounceOptions {\r\n  /**\r\n   * An optional AbortSignal to cancel the debounced function.\r\n   */\r\n  signal?: AbortSignal;\r\n\r\n  /**\r\n   * An optional array specifying whether the function should be invoked on the leading edge, trailing edge, or both.\r\n   * If `edges` includes \"leading\", the function will be invoked at the start of the delay period.\r\n   * If `edges` includes \"trailing\", the function will be invoked at the end of the delay period.\r\n   * If both \"leading\" and \"trailing\" are included, the function will be invoked at both the start and end of the delay period.\r\n   * @default [\"trailing\"]\r\n   */\r\n  edges?: Array<'leading' | 'trailing'>;\r\n}\r\n\r\n/**\r\n * Creates a debounced function that delays invoking the provided function until after `debounceMs` milliseconds\r\n * have elapsed since the last time the debounced function was invoked. The debounced function also has a `cancel`\r\n * method to cancel any pending execution.\r\n *\r\n * @template F - The type of function.\r\n * @param {F} func - The function to debounce.\r\n * @param {number} debounceMs - The number of milliseconds to delay.\r\n * @param {DebounceOptions} options - The options object\r\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the debounced function.\r\n * @returns A new debounced function with a `cancel` method.\r\n *\r\n * @example\r\n * const debouncedFunction = debounce(() => {\r\n *   console.log('Function executed');\r\n * }, 1000);\r\n *\r\n * // Will log 'Function executed' after 1 second if not called again in that time\r\n * debouncedFunction();\r\n *\r\n * // Will not log anything as the previous call is canceled\r\n * debouncedFunction.cancel();\r\n *\r\n * // With AbortSignal\r\n * const controller = new AbortController();\r\n * const signal = controller.signal;\r\n * const debouncedWithSignal = debounce(() => {\r\n *  console.log('Function executed');\r\n * }, 1000, { signal });\r\n *\r\n * debouncedWithSignal();\r\n *\r\n * // Will cancel the debounced function call\r\n * controller.abort();\r\n */\r\nexport function debounce<F extends (...args: any[]) => void>(\r\n  func: F,\r\n  debounceMs: number,\r\n  { signal, edges }: DebounceOptions = {}\r\n): ((...args: Parameters<F>) => void) & {\r\n  /**\r\n   * Schedules the execution of the debounced function after the specified debounce delay.\r\n   * This method resets any existing timer, ensuring that the function is only invoked\r\n   * after the delay has elapsed since the last call to the debounced function.\r\n   * It is typically called internally whenever the debounced function is invoked.\r\n   *\r\n   * @returns {void}\r\n   */\r\n  schedule: () => void;\r\n\r\n  /**\r\n   * Cancels any pending execution of the debounced function.\r\n   * This method clears the active timer and resets any stored context or arguments.\r\n   */\r\n  cancel: () => void;\r\n\r\n  /**\r\n   * Immediately invokes the debounced function if there is a pending execution.\r\n   * This method also cancels the current timer, ensuring that the function executes right away.\r\n   */\r\n  flush: () => void;\r\n} {\r\n  let pendingThis: any = undefined;\r\n  let pendingArgs: Parameters<F> | null = null;\r\n\r\n  const leading = edges != null && edges.includes('leading');\r\n  const trailing = edges == null || edges.includes('trailing');\r\n\r\n  const invoke = () => {\r\n    if (pendingArgs !== null) {\r\n      func.apply(pendingThis, pendingArgs);\r\n      pendingThis = undefined;\r\n      pendingArgs = null;\r\n    }\r\n  };\r\n\r\n  const onTimerEnd = () => {\r\n    if (trailing) {\r\n      invoke();\r\n    }\r\n\r\n    cancel();\r\n  };\r\n\r\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\r\n\r\n  const schedule = () => {\r\n    if (timeoutId != null) {\r\n      clearTimeout(timeoutId);\r\n    }\r\n\r\n    timeoutId = setTimeout(() => {\r\n      timeoutId = null;\r\n\r\n      onTimerEnd();\r\n    }, debounceMs);\r\n  };\r\n\r\n  const cancelTimer = () => {\r\n    if (timeoutId !== null) {\r\n      clearTimeout(timeoutId);\r\n      timeoutId = null;\r\n    }\r\n  };\r\n\r\n  const cancel = () => {\r\n    cancelTimer();\r\n    pendingThis = undefined;\r\n    pendingArgs = null;\r\n  };\r\n\r\n  const flush = () => {\r\n    cancelTimer();\r\n    invoke();\r\n  };\r\n\r\n  const debounced = function (this: any, ...args: Parameters<F>) {\r\n    if (signal?.aborted) {\r\n      return;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    pendingThis = this;\r\n    pendingArgs = args;\r\n\r\n    const isFirstCall = timeoutId == null;\r\n\r\n    schedule();\r\n\r\n    if (leading && isFirstCall) {\r\n      invoke();\r\n    }\r\n  };\r\n\r\n  debounced.schedule = schedule;\r\n  debounced.cancel = cancel;\r\n  debounced.flush = flush;\r\n\r\n  signal?.addEventListener('abort', cancel, { once: true });\r\n\r\n  return debounced;\r\n}\r\n","/**\r\n * A no-operation function that does nothing.\r\n * This can be used as a placeholder or default function.\r\n *\r\n * @example\r\n * noop(); // Does nothing\r\n *\r\n * @returns {void} This function does not return anything.\r\n */\r\nexport function noop(): void {}\r\n","/**\r\n * Creates a function that invokes func, with up to n arguments, ignoring any additional arguments.\r\n *\r\n * @template F - The type of the function.\r\n * @param {F} func - The function to cap arguments for.\r\n * @param {number} n - The arity cap.\r\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new capped function.\r\n *\r\n * @example\r\n * function fn(a: number, b: number, c: number) {\r\n *   return Array.from(arguments);\r\n * }\r\n *\r\n * ary(fn, 0)(1, 2, 3) // []\r\n * ary(fn, 1)(1, 2, 3) // [1]\r\n * ary(fn, 2)(1, 2, 3) // [1, 2]\r\n * ary(fn, 3)(1, 2, 3) // [1, 2, 3]\r\n */\r\nexport function ary<F extends (...args: any[]) => any>(func: F, n: number): (...args: any[]) => ReturnType<F> {\r\n  return function (this: any, ...args: Parameters<F>) {\r\n    return func.apply(this, args.slice(0, n));\r\n  };\r\n}\r\n","/**\r\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\r\n *\r\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\r\n *\r\n * Note: This method doesn't set the `length` property of partially applied functions.\r\n *\r\n * @template F The type of the function to partially apply.\r\n * @param {F} func The function to partially apply arguments to.\r\n * @param {any[]} partialArgs The arguments to be partially applied.\r\n * @returns {F} Returns the new partially applied function.\r\n *\r\n * @example\r\n * function greet(greeting, name) {\r\n *   return greeting + ' ' + name;\r\n * }\r\n *\r\n * const sayHelloTo = partial(greet, 'hello');\r\n * sayHelloTo('fred');\r\n * // => 'hello fred'\r\n *\r\n * // Partially applied with placeholders.\r\n * const greetFred = partial(greet, partial.placeholder, 'fred');\r\n * greetFred('hi');\r\n * // => 'hi fred'\r\n */\r\nexport function partial<F extends (...args: any[]) => any>(func: F, ...partialArgs: any[]): F {\r\n  return function (this: any, ...providedArgs: any[]) {\r\n    const args: any[] = [];\r\n\r\n    let startIndex = 0;\r\n    for (let i = 0; i < partialArgs.length; i++) {\r\n      const arg = partialArgs[i];\r\n\r\n      if (arg === partial.placeholder) {\r\n        args.push(providedArgs[startIndex++]);\r\n      } else {\r\n        args.push(arg);\r\n      }\r\n    }\r\n    for (let i = startIndex; i < providedArgs.length; i++) {\r\n      args.push(providedArgs[i]);\r\n    }\r\n\r\n    return func.apply(this, args);\r\n  } as any as F;\r\n}\r\n\r\nconst partialPlaceholder: unique symbol = Symbol('partial.placeholder');\r\npartial.placeholder = partialPlaceholder;\r\n","/**\r\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\r\n *\r\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\r\n *\r\n * Note: This method doesn't set the `length` property of partially applied functions.\r\n *\r\n * @template F The type of the function to partially apply.\r\n * @param {F} func The function to partially apply arguments to.\r\n * @param {any[]} partialArgs The arguments to be partially applied.\r\n * @returns {F} Returns the new partially applied function.\r\n *\r\n * @example\r\n * function greet(greeting, name) {\r\n *   return greeting + ' ' + name;\r\n * }\r\n *\r\n * const greetFred = partialRight(greet, 'fred');\r\n * greetFred('hi');\r\n * // => 'hi fred'\r\n *\r\n * // Partially applied with placeholders.\r\n * const sayHelloTo = partialRight(greet, 'hello', partialRight.placeholder);\r\n * sayHelloTo('fred');\r\n * // => 'hello fred'\r\n */\r\nexport function partialRight<F extends (...args: any[]) => any>(func: F, ...partialArgs: any[]): F {\r\n  return function (this: any, ...providedArgs: any[]) {\r\n    const placeholderLength = partialArgs.filter(arg => arg === partialRightPlaceholder).length;\r\n    const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);\r\n    const args: any[] = [];\r\n\r\n    let providedIndex = 0;\r\n    for (let i = 0; i < rangeLength; i++) {\r\n      args.push(providedArgs[providedIndex++]);\r\n    }\r\n    for (let i = 0; i < partialArgs.length; i++) {\r\n      const arg = partialArgs[i];\r\n\r\n      if (arg === partialRight.placeholder) {\r\n        args.push(providedArgs[providedIndex++]);\r\n      } else {\r\n        args.push(arg);\r\n      }\r\n    }\r\n    return func.apply(this, args);\r\n  } as any as F;\r\n}\r\n\r\nconst partialRightPlaceholder: unique symbol = Symbol('partialRight.placeholder');\r\npartialRight.placeholder = partialRightPlaceholder;\r\n","/**\r\n * Calculates the sum of an array of numbers.\r\n *\r\n * This function takes an array of numbers and returns the sum of all the elements in the array.\r\n *\r\n * @param {number[]} nums - An array of numbers to be summed.\r\n * @returns {number} The sum of all the numbers in the array.\r\n *\r\n * @example\r\n * const numbers = [1, 2, 3, 4, 5];\r\n * const result = sum(numbers);\r\n * // result will be 15\r\n */\r\nexport function sum(nums: readonly number[]): number {\r\n  let result = 0;\r\n\r\n  for (let i = 0; i < nums.length; i++) {\r\n    result += nums[i];\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { sum } from './sum.ts';\r\n\r\n/**\r\n * Calculates the average of an array of numbers.\r\n *\r\n * If the array is empty, this function returns `NaN`.\r\n *\r\n * @param {number[]} nums - An array of numbers to calculate the average.\r\n * @returns {number} The average of all the numbers in the array.\r\n *\r\n * @example\r\n * const numbers = [1, 2, 3, 4, 5];\r\n * const result = mean(numbers);\r\n * // result will be 3\r\n */\r\nexport function mean(nums: readonly number[]): number {\r\n  return sum(nums) / nums.length;\r\n}\r\n","/**\r\n * Checks if a value is a TypedArray.\r\n * @param {unknown} x The value to check.\r\n * @returns {x is\r\n *     Uint8Array\r\n *   | Uint8ClampedArray\r\n *   | Uint16Array\r\n *   | Uint32Array\r\n *   | BigUint64Array\r\n *   | Int8Array\r\n *   | Int16Array\r\n *   | Int32Array\r\n *   | BigInt64Array\r\n *   | Float32Array\r\n *   | Float64Array} Returns true if `x` is a TypedArray, false otherwise.\r\n *\r\n * @example\r\n * const arr = new Uint8Array([1, 2, 3]);\r\n * isTypedArray(arr); // true\r\n *\r\n * const regularArray = [1, 2, 3];\r\n * isTypedArray(regularArray); // false\r\n *\r\n * const buffer = new ArrayBuffer(16);\r\n * isTypedArray(buffer); // false\r\n */\r\nexport function isTypedArray(\r\n  x: unknown\r\n): x is\r\n  | Uint8Array\r\n  | Uint8ClampedArray\r\n  | Uint16Array\r\n  | Uint32Array\r\n  | BigUint64Array\r\n  | Int8Array\r\n  | Int16Array\r\n  | Int32Array\r\n  | BigInt64Array\r\n  | Float32Array\r\n  | Float64Array {\r\n  return ArrayBuffer.isView(x) && !(x instanceof DataView);\r\n}\r\n","/**\r\n * Checks whether a value is a JavaScript primitive.\r\n * JavaScript primitives include null, undefined, strings, numbers, booleans, symbols, and bigints.\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {value is\r\n *     null\r\n *   | undefined\r\n *   | string\r\n *   | number\r\n *   | boolean\r\n *   | symbol\r\n *   | bigint} Returns true if `value` is a primitive, false otherwise.\r\n *\r\n * @example\r\n * isPrimitive(null); // true\r\n * isPrimitive(undefined); // true\r\n * isPrimitive('123'); // true\r\n * isPrimitive(false); // true\r\n * isPrimitive(true); // true\r\n * isPrimitive(Symbol('a')); // true\r\n * isPrimitive(123n); // true\r\n * isPrimitive({}); // false\r\n * isPrimitive(new Date()); // false\r\n * isPrimitive(new Map()); // false\r\n * isPrimitive(new Set()); // false\r\n * isPrimitive([1, 2, 3]); // false\r\n */\r\nexport function isPrimitive(value: unknown): value is null | undefined | string | number | boolean | symbol | bigint {\r\n  return value == null || (typeof value !== 'object' && typeof value !== 'function');\r\n}\r\n","import { isTypedArray } from '../predicate/isTypedArray.ts';\r\nimport { isPrimitive } from '../predicate/isPrimitive.ts';\r\n\r\n/**\r\n * Creates a shallow clone of the given object.\r\n *\r\n * @template T - The type of the object.\r\n * @param {T} obj - The object to clone.\r\n * @returns {T} - A shallow clone of the given object.\r\n *\r\n * @example\r\n * // Clone a primitive values\r\n * const num = 29;\r\n * const clonedNum = clone(num);\r\n * console.log(clonedNum); // 29\r\n * console.log(clonedNum === num) ; // true\r\n *\r\n * @example\r\n * // Clone an array\r\n * const arr = [1, 2, 3];\r\n * const clonedArr = clone(arr);\r\n * console.log(clonedArr); // [1, 2, 3]\r\n * console.log(clonedArr === arr); // false\r\n *\r\n * @example\r\n * // Clone an object\r\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\r\n * const clonedObj = clone(obj);\r\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\r\n * console.log(clonedObj === obj); // false\r\n */\r\nexport function clone<T>(obj: T): T {\r\n  if (isPrimitive(obj)) {\r\n    return obj;\r\n  }\r\n\r\n  if (\r\n    Array.isArray(obj) ||\r\n    isTypedArray(obj) ||\r\n    obj instanceof ArrayBuffer ||\r\n    (typeof SharedArrayBuffer !== 'undefined' && obj instanceof SharedArrayBuffer)\r\n  ) {\r\n    return obj.slice(0) as T;\r\n  }\r\n\r\n  const prototype = Object.getPrototypeOf(obj);\r\n  const Constructor = prototype.constructor;\r\n\r\n  if (obj instanceof Date || obj instanceof Map || obj instanceof Set) {\r\n    return new Constructor(obj);\r\n  }\r\n\r\n  if (obj instanceof RegExp) {\r\n    const newRegExp = new Constructor(obj);\r\n    newRegExp.lastIndex = obj.lastIndex;\r\n\r\n    return newRegExp;\r\n  }\r\n\r\n  if (obj instanceof DataView) {\r\n    return new Constructor(obj.buffer.slice(0));\r\n  }\r\n\r\n  if (obj instanceof Error) {\r\n    const newError = new Constructor(obj.message);\r\n\r\n    newError.stack = obj.stack;\r\n    newError.name = obj.name;\r\n    newError.cause = obj.cause;\r\n\r\n    return newError;\r\n  }\r\n\r\n  if (typeof File !== 'undefined' && obj instanceof File) {\r\n    const newFile = new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });\r\n    return newFile;\r\n  }\r\n\r\n  if (typeof obj === 'object') {\r\n    const newObject = Object.create(prototype);\r\n    return Object.assign(newObject, obj);\r\n  }\r\n\r\n  return obj;\r\n}\r\n","/**\r\n * Checks if a given value is a plain object.\r\n *\r\n * @param {object} object - The value to check.\r\n * @returns {boolean} - True if the value is a plain object, otherwise false.\r\n *\r\n * @example\r\n * console.log(isPlainObject({})); // true\r\n * console.log(isPlainObject([])); // false\r\n * console.log(isPlainObject(null)); // false\r\n * console.log(isPlainObject(Object.create(null))); // true\r\n * console.log(Buffer.from('hello, world')); // false\r\n */\r\nexport function isPlainObject(object: object): boolean {\r\n  if (typeof object !== 'object') {\r\n    return false;\r\n  }\r\n\r\n  if (object == null) {\r\n    return false;\r\n  }\r\n\r\n  if (Object.getPrototypeOf(object) === null) {\r\n    return true;\r\n  }\r\n\r\n  if (object.toString() !== '[object Object]') {\r\n    return false;\r\n  }\r\n\r\n  let proto = object;\r\n\r\n  while (Object.getPrototypeOf(proto) !== null) {\r\n    proto = Object.getPrototypeOf(proto);\r\n  }\r\n\r\n  return Object.getPrototypeOf(object) === proto;\r\n}\r\n","import { isPlainObject } from '../predicate/isPlainObject.ts';\r\n\r\n/**\r\n * Flattens a nested object into a single level object with dot-separated keys.\r\n *\r\n * @param {object} object - The object to flatten.\r\n * @returns {Record<string, any>} - The flattened object.\r\n *\r\n * @example\r\n * const nestedObject = {\r\n *   a: {\r\n *     b: {\r\n *       c: 1\r\n *     }\r\n *   },\r\n *   d: [2, 3]\r\n * };\r\n *\r\n * const flattened = flattenObject(nestedObject);\r\n * console.log(flattened);\r\n * // Output:\r\n * // {\r\n * //   'a.b.c': 1,\r\n * //   'd.0': 2,\r\n * //   'd.1': 3\r\n * // }\r\n */\r\nexport function flattenObject(object: object): Record<string, any> {\r\n  return flattenObjectImpl(object);\r\n}\r\n\r\nfunction flattenObjectImpl(object: object, prefix = ''): Record<string, any> {\r\n  const result: Record<string, any> = {};\r\n  const keys = Object.keys(object);\r\n\r\n  for (let i = 0; i < keys.length; i++) {\r\n    const key = keys[i];\r\n    const value = (object as any)[key];\r\n\r\n    const prefixedKey = prefix ? `${prefix}.${key}` : key;\r\n\r\n    if (isPlainObject(value) && Object.keys(value).length > 0) {\r\n      Object.assign(result, flattenObjectImpl(value, prefixedKey));\r\n      continue;\r\n    }\r\n\r\n    if (Array.isArray(value)) {\r\n      for (let index = 0; index < value.length; index++) {\r\n        result[`${prefixedKey}.${index}`] = value[index];\r\n      }\r\n      continue;\r\n    }\r\n\r\n    result[prefixedKey] = value;\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Creates a new object with the same values as the given object, but with keys generated\r\n * by running each own enumerable property of the object through the iteratee function.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the keys in the object.\r\n * @template K2 - The type of the new keys generated by the iteratee function.\r\n *\r\n * @param {T} object - The object to iterate over.\r\n * @param {(value: T[K1], key: K1, object: T) => K2} getNewKey - The function invoked per own enumerable property.\r\n * @returns {Record<K2, T[K1]>} - Returns the new mapped object.\r\n *\r\n * @example\r\n * // Example usage:\r\n * const obj = { a: 1, b: 2 };\r\n * const result = mapKeys(obj, (value, key) => key + value);\r\n * console.log(result); // { a1: 1, b2: 2 }\r\n */\r\nexport function mapKeys<T extends object, K1 extends keyof T, K2 extends PropertyKey>(\r\n  object: T,\r\n  getNewKey: (value: T[K1], key: K1, object: T) => K2\r\n): Record<K2, T[K1]> {\r\n  const result = {} as Record<K2, T[K1]>;\r\n  const keys = Object.keys(object);\r\n\r\n  for (let i = 0; i < keys.length; i++) {\r\n    const key = keys[i] as K1;\r\n    const value = object[key];\r\n\r\n    result[getNewKey(value, key, object)] = value as any;\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Creates a new object with the same keys as the given object, but with values generated\r\n * by running each own enumerable property of the object through the iteratee function.\r\n *\r\n * @template T - The type of the object.\r\n * @template K - The type of the keys in the object.\r\n * @template V - The type of the new values generated by the iteratee function.\r\n *\r\n * @param {T} object - The object to iterate over.\r\n * @param {(value: T[K], key: K, object: T) => V} getNewValue - The function invoked per own enumerable property.\r\n * @returns {Record<K, V>} - Returns the new mapped object.\r\n *\r\n * @example\r\n * // Example usage:\r\n * const obj = { a: 1, b: 2 };\r\n * const result = mapValues(obj, (value) => value * 2);\r\n * console.log(result); // { a: 2, b: 4 }\r\n */\r\nexport function mapValues<T extends object, K extends keyof T, V>(\r\n  object: T,\r\n  getNewValue: (value: T[K], key: K, object: T) => V\r\n): Record<K, V> {\r\n  const result = {} as Record<K, V>;\r\n  const keys = Object.keys(object);\r\n\r\n  for (let i = 0; i < keys.length; i++) {\r\n    const key = keys[i] as K;\r\n    const value = object[key];\r\n\r\n    result[key] = getNewValue(value, key, object);\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { isPrimitive } from '../predicate/isPrimitive.ts';\r\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\r\n\r\n/**\r\n * Creates a deep clone of the given object.\r\n *\r\n * @template T - The type of the object.\r\n * @param {T} obj - The object to clone.\r\n * @returns {T} - A deep clone of the given object.\r\n *\r\n * @example\r\n * // Clone a primitive values\r\n * const num = 29;\r\n * const clonedNum = clone(num);\r\n * console.log(clonedNum); // 29\r\n * console.log(clonedNum === num) ; // true\r\n *\r\n * @example\r\n * // Clone an array\r\n * const arr = [1, 2, 3];\r\n * const clonedArr = clone(arr);\r\n * console.log(clonedArr); // [1, 2, 3]\r\n * console.log(clonedArr === arr); // false\r\n *\r\n * @example\r\n * // Clone an array with nested objects\r\n * const arr = [1, { a: 1 }, [1, 2, 3]];\r\n * const clonedArr = clone(arr);\r\n * arr[1].a = 2;\r\n * console.log(arr); // [2, { a: 2 }, [1, 2, 3]]\r\n * console.log(clonedArr); // [1, { a: 1 }, [1, 2, 3]]\r\n * console.log(clonedArr === arr); // false\r\n *\r\n * @example\r\n * // Clone an object\r\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\r\n * const clonedObj = clone(obj);\r\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\r\n * console.log(clonedObj === obj); // false\r\n *\r\n * @example\r\n * // Clone an object with nested objects\r\n * const obj = { a: 1, b: { c: 1 } };\r\n * const clonedObj = clone(obj);\r\n * obj.b.c = 2;\r\n * console.log(obj); // { a: 1, b: { c: 2 } }\r\n * console.log(clonedObj); // { a: 1, b: { c: 1 } }\r\n * console.log(clonedObj === obj); // false\r\n */\r\nexport function cloneDeep<T>(obj: T): T {\r\n  return cloneDeepImpl(obj);\r\n}\r\n\r\nfunction cloneDeepImpl<T>(obj: T, stack = new Map<any, any>()): T {\r\n  if (isPrimitive(obj)) {\r\n    return obj as T;\r\n  }\r\n\r\n  if (stack.has(obj)) {\r\n    return stack.get(obj) as T;\r\n  }\r\n\r\n  if (Array.isArray(obj)) {\r\n    const result: any = new Array(obj.length);\r\n    stack.set(obj, result);\r\n\r\n    for (let i = 0; i < obj.length; i++) {\r\n      result[i] = cloneDeepImpl(obj[i], stack);\r\n    }\r\n\r\n    // For RegExpArrays\r\n    if (Object.prototype.hasOwnProperty.call(obj, 'index')) {\r\n      // eslint-disable-next-line\r\n      // @ts-ignore\r\n      result.index = obj.index;\r\n    }\r\n    if (Object.prototype.hasOwnProperty.call(obj, 'input')) {\r\n      // eslint-disable-next-line\r\n      // @ts-ignore\r\n      result.input = obj.input;\r\n    }\r\n\r\n    return result as T;\r\n  }\r\n\r\n  if (obj instanceof Date) {\r\n    return new Date(obj.getTime()) as T;\r\n  }\r\n\r\n  if (obj instanceof RegExp) {\r\n    const result = new RegExp(obj.source, obj.flags);\r\n\r\n    result.lastIndex = obj.lastIndex;\r\n\r\n    return result as T;\r\n  }\r\n\r\n  if (obj instanceof Map) {\r\n    const result = new Map();\r\n    stack.set(obj, result);\r\n\r\n    for (const [key, value] of obj.entries()) {\r\n      result.set(key, cloneDeepImpl(value, stack));\r\n    }\r\n\r\n    return result as T;\r\n  }\r\n\r\n  if (obj instanceof Set) {\r\n    const result = new Set();\r\n    stack.set(obj, result);\r\n\r\n    for (const value of obj.values()) {\r\n      result.add(cloneDeepImpl(value, stack));\r\n    }\r\n\r\n    return result as T;\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n  // @ts-ignore\r\n  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(obj)) {\r\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n    // @ts-ignore\r\n    return obj.subarray() as T;\r\n  }\r\n\r\n  if (isTypedArray(obj)) {\r\n    const result = new (Object.getPrototypeOf(obj).constructor)(obj.length);\r\n    stack.set(obj, result);\r\n\r\n    for (let i = 0; i < obj.length; i++) {\r\n      result[i] = cloneDeepImpl(obj[i], stack);\r\n    }\r\n\r\n    return result as T;\r\n  }\r\n\r\n  if (obj instanceof ArrayBuffer || (typeof SharedArrayBuffer !== 'undefined' && obj instanceof SharedArrayBuffer)) {\r\n    return obj.slice(0) as T;\r\n  }\r\n\r\n  if (obj instanceof DataView) {\r\n    const result = new DataView(obj.buffer.slice(0));\r\n    stack.set(obj, result);\r\n\r\n    copyProperties(result, obj, stack);\r\n\r\n    return result as T;\r\n  }\r\n\r\n  // For legacy NodeJS support\r\n  if (typeof File !== 'undefined' && obj instanceof File) {\r\n    const result = new File([obj], obj.name, { type: obj.type });\r\n    stack.set(obj, result);\r\n\r\n    copyProperties(result, obj, stack);\r\n\r\n    return result as T;\r\n  }\r\n\r\n  if (obj instanceof Blob) {\r\n    const result = new Blob([obj], { type: obj.type });\r\n    stack.set(obj, result);\r\n\r\n    copyProperties(result, obj, stack);\r\n\r\n    return result as T;\r\n  }\r\n\r\n  if (obj instanceof Error) {\r\n    const result = new (obj.constructor as { new (): Error })();\r\n    stack.set(obj, result);\r\n\r\n    result.message = obj.message;\r\n    result.name = obj.name;\r\n    result.stack = obj.stack;\r\n    result.cause = obj.cause;\r\n\r\n    copyProperties(result, obj, stack);\r\n\r\n    return result as T;\r\n  }\r\n\r\n  if (typeof obj === 'object' && obj !== null) {\r\n    const result = {};\r\n    stack.set(obj, result);\r\n\r\n    copyProperties(result, obj, stack);\r\n\r\n    return result as T;\r\n  }\r\n\r\n  return obj;\r\n}\r\n\r\n// eslint-disable-next-line\r\nexport function copyProperties(target: any, source: any, stack?: Map<any, any>): void {\r\n  const keys = Object.keys(source);\r\n\r\n  for (let i = 0; i < keys.length; i++) {\r\n    const key = keys[i];\r\n    const descriptor = Object.getOwnPropertyDescriptor(source, key);\r\n\r\n    if (descriptor?.writable || descriptor?.set) {\r\n      target[key] = cloneDeepImpl(source[key], stack);\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Checks if the given value is object-like.\r\n *\r\n * A value is object-like if its type is object and it is not null.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an object-like value.\r\n *\r\n * @template T - The type of value.\r\n * @param {T} value - The value to test if it is an object-like.\r\n * @returns {value is object} `true` if the value is an object-like, `false` otherwise.\r\n *\r\n * @example\r\n * const value1 = { a: 1 };\r\n * const value2 = [1, 2, 3];\r\n * const value3 = 'abc';\r\n * const value4 = () => {};\r\n * const value5 = null;\r\n *\r\n * console.log(isObjectLike(value1)); // true\r\n * console.log(isObjectLike(value2)); // true\r\n * console.log(isObjectLike(value3)); // false\r\n * console.log(isObjectLike(value4)); // false\r\n * console.log(isObjectLike(value5)); // false\r\n */\r\n\r\nexport function isObjectLike(value: unknown): value is object {\r\n  return typeof value === 'object' && value !== null;\r\n}\r\n","import { isObjectLike } from '../compat/predicate/isObjectLike.ts';\r\n\r\n/**\r\n * Merges the properties of the source object into the target object.\r\n *\r\n * This function performs a deep merge, meaning nested objects and arrays are merged recursively.\r\n * If a property in the source object is an array or an object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is undefined, it will not overwrite a defined property in the target object.\r\n *\r\n * Note that this function mutates the target object.\r\n *\r\n * @param {T} target - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S} source - The source object whose properties will be merged into the target object.\r\n * @returns {T & S} The updated target object with properties from the source object merged in.\r\n *\r\n * @template T - Type of the target object.\r\n * @template S - Type of the source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3, 2], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function merge<T, S>(target: T, source: S): T & S;\r\n/**\r\n * Merges the properties of the source object into the target object.\r\n *\r\n * This function performs a deep merge, meaning nested objects and arrays are merged recursively.\r\n * If a property in the source object is an array or an object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is undefined, it will not overwrite a defined property in the target object.\r\n *\r\n * Note that this function mutates the target object.\r\n *\r\n * @param {T} target - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S} source - The source object whose properties will be merged into the target object.\r\n * @returns {T & S} The updated target object with properties from the source object merged in.\r\n *\r\n * @template T - Type of the target object.\r\n * @template S - Type of the source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3, 2], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function merge(target: any, source: any) {\r\n  const sourceKeys = Object.keys(source);\r\n\r\n  for (let i = 0; i < sourceKeys.length; i++) {\r\n    const key = sourceKeys[i];\r\n\r\n    const sourceValue = source[key];\r\n    const targetValue = target[key];\r\n\r\n    if (Array.isArray(sourceValue)) {\r\n      target[key] = merge(targetValue ?? [], sourceValue);\r\n    } else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {\r\n      target[key] = merge(targetValue ?? {}, sourceValue);\r\n    } else if (targetValue === undefined || sourceValue !== undefined) {\r\n      target[key] = sourceValue;\r\n    }\r\n  }\r\n\r\n  return target;\r\n}\r\n","export const regexpTag = '[object RegExp]';\r\nexport const stringTag = '[object String]';\r\nexport const numberTag = '[object Number]';\r\nexport const booleanTag = '[object Boolean]';\r\nexport const argumentsTag = '[object Arguments]';\r\nexport const symbolTag = '[object Symbol]';\r\nexport const dateTag = '[object Date]';\r\nexport const mapTag = '[object Map]';\r\nexport const setTag = '[object Set]';\r\nexport const arrayTag = '[object Array]';\r\nexport const functionTag = '[object Function]';\r\nexport const arrayBufferTag = '[object ArrayBuffer]';\r\nexport const objectTag = '[object Object]';\r\nexport const errorTag = '[object Error]';\r\nexport const dataViewTag = '[object DataView]';\r\nexport const uint8ArrayTag = '[object Uint8Array]';\r\nexport const uint8ClampedArrayTag = '[object Uint8ClampedArray]';\r\nexport const uint16ArrayTag = '[object Uint16Array]';\r\nexport const uint32ArrayTag = '[object Uint32Array]';\r\nexport const bigUint64ArrayTag = '[object BigUint64Array]';\r\nexport const int8ArrayTag = '[object Int8Array]';\r\nexport const int16ArrayTag = '[object Int16Array]';\r\nexport const int32ArrayTag = '[object Int32Array]';\r\nexport const bigInt64ArrayTag = '[object BigInt64Array]';\r\nexport const float32ArrayTag = '[object Float32Array]';\r\nexport const float64ArrayTag = '[object Float64Array]';\r\n","export function getSymbols(object: any) {\r\n  return Object.getOwnPropertySymbols(object).filter(symbol =>\r\n    Object.prototype.propertyIsEnumerable.call(object, symbol)\r\n  );\r\n}\r\n","/**\r\n * Gets the `toStringTag` of `value`.\r\n *\r\n * @private\r\n * @param {T} value The value to query.\r\n * @returns {string} Returns the `Object.prototype.toString.call` result.\r\n */\r\nexport function getTag<T>(value: T) {\r\n  if (value == null) {\r\n    return value === undefined ? '[object Undefined]' : '[object Null]';\r\n  }\r\n  return Object.prototype.toString.call(value);\r\n}\r\n","import {\r\n  argumentsTag,\r\n  arrayBufferTag,\r\n  arrayTag,\r\n  bigInt64ArrayTag,\r\n  bigUint64ArrayTag,\r\n  booleanTag,\r\n  dataViewTag,\r\n  dateTag,\r\n  errorTag,\r\n  float32ArrayTag,\r\n  float64ArrayTag,\r\n  functionTag,\r\n  int16ArrayTag,\r\n  int32ArrayTag,\r\n  int8ArrayTag,\r\n  mapTag,\r\n  numberTag,\r\n  objectTag,\r\n  regexpTag,\r\n  setTag,\r\n  stringTag,\r\n  symbolTag,\r\n  uint16ArrayTag,\r\n  uint32ArrayTag,\r\n  uint8ArrayTag,\r\n  uint8ClampedArrayTag,\r\n} from '../compat/_internal/tags.ts';\r\nimport { getSymbols } from '../compat/_internal/getSymbols.ts';\r\nimport { getTag } from '../compat/_internal/getTag.ts';\r\nimport { isPlainObject } from './isPlainObject.ts';\r\n\r\ndeclare let Buffer:\r\n  | {\r\n      isBuffer: (a: any) => boolean;\r\n    }\r\n  | undefined;\r\n\r\n/**\r\n * Checks if two values are equal, including support for `Date`, `RegExp`, and deep object comparison.\r\n *\r\n * @param {unknown} a - The first value to compare.\r\n * @param {unknown} b - The second value to compare.\r\n * @returns {boolean} `true` if the values are equal, otherwise `false`.\r\n *\r\n * @example\r\n * isEqual(1, 1); // true\r\n * isEqual({ a: 1 }, { a: 1 }); // true\r\n * isEqual(/abc/g, /abc/g); // true\r\n * isEqual(new Date('2020-01-01'), new Date('2020-01-01')); // true\r\n * isEqual([1, 2, 3], [1, 2, 3]); // true\r\n */\r\nexport function isEqual(a: any, b: any): boolean {\r\n  if (typeof a === typeof b) {\r\n    switch (typeof a) {\r\n      case 'bigint':\r\n      case 'string':\r\n      case 'boolean':\r\n      case 'symbol':\r\n      case 'undefined': {\r\n        return a === b;\r\n      }\r\n      case 'number': {\r\n        return a === b || Object.is(a, b);\r\n      }\r\n      case 'function': {\r\n        return a === b;\r\n      }\r\n      case 'object': {\r\n        return areObjectsEqual(a, b);\r\n      }\r\n    }\r\n  }\r\n\r\n  return areObjectsEqual(a, b);\r\n}\r\n\r\nfunction areObjectsEqual(a: any, b: any, stack?: Map<any, any>) {\r\n  if (Object.is(a, b)) {\r\n    return true;\r\n  }\r\n\r\n  let aTag = getTag(a);\r\n  let bTag = getTag(b);\r\n\r\n  if (aTag === argumentsTag) {\r\n    aTag = objectTag;\r\n  }\r\n\r\n  if (bTag === argumentsTag) {\r\n    bTag = objectTag;\r\n  }\r\n\r\n  if (aTag !== bTag) {\r\n    return false;\r\n  }\r\n\r\n  switch (aTag) {\r\n    case stringTag:\r\n      return a.toString() === b.toString();\r\n\r\n    case numberTag: {\r\n      const x = a.valueOf();\r\n      const y = b.valueOf();\r\n\r\n      return x === y || (Number.isNaN(x) && Number.isNaN(y));\r\n    }\r\n\r\n    case booleanTag:\r\n    case dateTag:\r\n    case symbolTag:\r\n      return Object.is(a.valueOf(), b.valueOf());\r\n\r\n    case regexpTag: {\r\n      return a.source === b.source && a.flags === b.flags;\r\n    }\r\n\r\n    case functionTag: {\r\n      return a === b;\r\n    }\r\n  }\r\n\r\n  stack = stack ?? new Map();\r\n\r\n  const aStack = stack.get(a);\r\n  const bStack = stack.get(b);\r\n\r\n  if (aStack != null && bStack != null) {\r\n    return aStack === b;\r\n  }\r\n\r\n  stack.set(a, b);\r\n  stack.set(b, a);\r\n\r\n  try {\r\n    switch (aTag) {\r\n      case mapTag: {\r\n        if (a.size !== b.size) {\r\n          return false;\r\n        }\r\n\r\n        for (const [key, value] of a.entries()) {\r\n          if (!b.has(key) || !areObjectsEqual(value, b.get(key), stack)) {\r\n            return false;\r\n          }\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      case setTag: {\r\n        if (a.size !== b.size) {\r\n          return false;\r\n        }\r\n\r\n        const aValues = Array.from(a.values());\r\n        const bValues = Array.from(b.values());\r\n\r\n        for (let i = 0; i < aValues.length; i++) {\r\n          const aValue = aValues[i];\r\n          const index = bValues.findIndex(bValue => {\r\n            return areObjectsEqual(aValue, bValue, stack);\r\n          });\r\n\r\n          if (index === -1) {\r\n            return false;\r\n          }\r\n\r\n          bValues.splice(index, 1);\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      case arrayTag:\r\n      case uint8ArrayTag:\r\n      case uint8ClampedArrayTag:\r\n      case uint16ArrayTag:\r\n      case uint32ArrayTag:\r\n      case bigUint64ArrayTag:\r\n      case int8ArrayTag:\r\n      case int16ArrayTag:\r\n      case int32ArrayTag:\r\n      case bigInt64ArrayTag:\r\n      case float32ArrayTag:\r\n      case float64ArrayTag: {\r\n        // Buffers are also treated as [object Uint8Array]s.\r\n        if (typeof Buffer !== 'undefined' && Buffer.isBuffer(a) !== Buffer.isBuffer(b)) {\r\n          return false;\r\n        }\r\n\r\n        if (a.length !== b.length) {\r\n          return false;\r\n        }\r\n\r\n        for (let i = 0; i < a.length; i++) {\r\n          if (!areObjectsEqual(a[i], b[i], stack)) {\r\n            return false;\r\n          }\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      case arrayBufferTag: {\r\n        if (a.byteLength !== b.byteLength) {\r\n          return false;\r\n        }\r\n\r\n        return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack);\r\n      }\r\n\r\n      case dataViewTag: {\r\n        if (a.byteLength !== b.byteLength || a.byteOffset !== b.byteOffset) {\r\n          return false;\r\n        }\r\n\r\n        return areObjectsEqual(a.buffer, b.buffer, stack);\r\n      }\r\n\r\n      case errorTag: {\r\n        return a.name === b.name && a.message === b.message;\r\n      }\r\n\r\n      case objectTag: {\r\n        const areEqualInstances =\r\n          areObjectsEqual(a.constructor, b.constructor, stack) || (isPlainObject(a) && isPlainObject(b));\r\n\r\n        if (!areEqualInstances) {\r\n          return false;\r\n        }\r\n\r\n        const aKeys = [...Object.keys(a), ...getSymbols(a)];\r\n        const bKeys = [...Object.keys(b), ...getSymbols(b)];\r\n\r\n        if (aKeys.length !== bKeys.length) {\r\n          return false;\r\n        }\r\n\r\n        for (let i = 0; i < aKeys.length; i++) {\r\n          const propKey = aKeys[i];\r\n          const aProp = (a as any)[propKey];\r\n\r\n          if (!Object.prototype.hasOwnProperty.call(b, propKey)) {\r\n            return false;\r\n          }\r\n\r\n          const bProp = (b as any)[propKey];\r\n\r\n          if (!areObjectsEqual(aProp, bProp, stack)) {\r\n            return false;\r\n          }\r\n        }\r\n\r\n        return true;\r\n      }\r\n      default: {\r\n        return false;\r\n      }\r\n    }\r\n  } finally {\r\n    stack.delete(a);\r\n    stack.delete(b);\r\n  }\r\n}\r\n","/**\r\n * Checks if a given value is a valid length.\r\n *\r\n * A valid length is of type `number`, is a non-negative integer, and is less than or equal to\r\n * JavaScript's maximum safe integer (`Number.MAX_SAFE_INTEGER`).\r\n * It returns `true` if the value is a valid length, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the\r\n * argument to a valid length (`number`).\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\r\n *\r\n * @example\r\n * isLength(0); // true\r\n * isLength(42); // true\r\n * isLength(-1); // false\r\n * isLength(1.5); // false\r\n * isLength(Number.MAX_SAFE_INTEGER); // true\r\n * isLength(Number.MAX_SAFE_INTEGER + 1); // false\r\n */\r\nexport function isLength(value: unknown): value is number {\r\n  return Number.isSafeInteger(value) && (value as number) >= 0;\r\n}\r\n","import { AbortError } from '../error/AbortError.ts';\r\n\r\ninterface DelayOptions {\r\n  signal?: AbortSignal;\r\n}\r\n\r\n/**\r\n * Delays the execution of code for a specified number of milliseconds.\r\n *\r\n * This function returns a Promise that resolves after the specified delay, allowing you to use it\r\n * with async/await to pause execution.\r\n *\r\n * @param {number} ms - The number of milliseconds to delay.\r\n * @param {DelayOptions} options - The options object.\r\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the delay.\r\n * @returns {Promise<void>} A Promise that resolves after the specified delay.\r\n *\r\n * @example\r\n * async function foo() {\r\n *   console.log('Start');\r\n *   await delay(1000); // Delays execution for 1 second\r\n *   console.log('End');\r\n * }\r\n *\r\n * foo();\r\n *\r\n * // With AbortSignal\r\n * const controller = new AbortController();\r\n * const { signal } = controller;\r\n *\r\n * setTimeout(() => controller.abort(), 50); // Will cancel the delay after 50ms\r\n * try {\r\n *   await delay(100, { signal });\r\n *  } catch (error) {\r\n *   console.error(error); // Will log 'AbortError'\r\n *  }\r\n * }\r\n */\r\nexport function delay(ms: number, { signal }: DelayOptions = {}): Promise<void> {\r\n  return new Promise((resolve, reject) => {\r\n    const abortError = () => {\r\n      reject(new AbortError());\r\n    };\r\n\r\n    const abortHandler = () => {\r\n      clearTimeout(timeoutId);\r\n      abortError();\r\n    };\r\n\r\n    if (signal?.aborted) {\r\n      return abortError();\r\n    }\r\n\r\n    const timeoutId = setTimeout(() => {\r\n      signal?.removeEventListener('abort', abortHandler);\r\n      resolve();\r\n    }, ms);\r\n\r\n    signal?.addEventListener('abort', abortHandler, { once: true });\r\n  });\r\n}\r\n","import { delay } from './delay.ts';\r\nimport { TimeoutError } from '../error/TimeoutError.ts';\r\n\r\n/**\r\n * Returns a promise that rejects with a `TimeoutError` after a specified delay.\r\n *\r\n * @param {number} ms - The delay duration in milliseconds.\r\n * @returns {Promise<never>} A promise that rejects with a `TimeoutError` after the specified delay.\r\n * @throws {TimeoutError} Throws a `TimeoutError` after the specified delay.\r\n *\r\n * @example\r\n * try {\r\n *   await timeout(1000); // Timeout exception after 1 second\r\n * } catch (error) {\r\n *   console.error(error); // Will log 'The operation was timed out'\r\n * }\r\n */\r\nexport async function timeout(ms: number): Promise<never> {\r\n  await delay(ms);\r\n  throw new TimeoutError();\r\n}\r\n","/**\r\n * Converts the first character of string to upper case and the remaining to lower case.\r\n *\r\n * @template T - Literal type of the string.\r\n * @param {T} str - The string to be converted to uppercase.\r\n * @returns {Capitalize<T>} - The capitalized string.\r\n *\r\n * @example\r\n * const result = capitalize('fred') // returns 'Fred'\r\n * const result2 = capitalize('FRED') // returns 'Fred'\r\n */\r\n\r\nexport function capitalize<T extends string>(str: T): Capitalize<T> {\r\n  return (str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()) as Capitalize<T>;\r\n}\r\n\r\ntype Capitalize<T extends string> = T extends `${infer F}${infer R}` ? `${Uppercase<F>}${Lowercase<R>}` : T;\r\n","/**\r\n * Regular expression pattern to split strings into words for various case conversions\r\n *\r\n * This pattern matches sequences of characters in a string, considering the following cases:\r\n * - Sequences of two or more uppercase letters followed by an uppercase letter and lowercase letters or digits (for acronyms)\r\n * - Sequences of one uppercase letter optionally followed by lowercase letters and digits\r\n * - Single uppercase letters\r\n * - Sequences of digits\r\n * - Emojis and other Unicode characters\r\n *\r\n * The resulting match can be used to convert camelCase, snake_case, kebab-case, and other mixed formats into\r\n * a consistent format like snake case. It also supports emojis and other Unicode characters.\r\n *\r\n * @example\r\n * const matches = 'camelCaseHTTPRequest🚀'.match(CASE_SPLIT_PATTERN);\r\n * // matches: ['camel', 'Case', 'HTTP', 'Request', '🚀']\r\n */\r\nconst CASE_SPLIT_PATTERN =\r\n  /[A-Z]?[a-z]+|[0-9]+|[A-Z]+(?![a-z])|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+/gu;\r\n\r\nexport function getWords(str: string): string[] {\r\n  return Array.from(str.match(CASE_SPLIT_PATTERN) ?? []);\r\n}\r\n","/**\r\n * Removes leading whitespace or specified characters from a string.\r\n *\r\n * @param {string} str - The string from which leading characters will be trimmed.\r\n * @param {string | string[]} chars - The character(s) to remove from the start of the string.\r\n * @returns {string} - The resulting string after the specified leading character has been removed.\r\n *\r\n * @example\r\n * const trimmedStr1 = trimStart('---hello', '-') // returns 'hello'\r\n * const trimmedStr2 = trimStart('000123', '0') // returns '123'\r\n * const trimmedStr3 = trimStart('abcabcabc', 'a') // returns 'bcabcabc'\r\n * const trimmedStr4 = trimStart('xxxtrimmed', 'x') // returns 'trimmed'\r\n */\r\nexport function trimStart(str: string, chars?: string | string[]): string {\r\n  if (chars === undefined) {\r\n    return str.trimStart();\r\n  }\r\n  let startIndex = 0;\r\n\r\n  switch (typeof chars) {\r\n    case 'string': {\r\n      while (startIndex < str.length && str[startIndex] === chars) {\r\n        startIndex++;\r\n      }\r\n      break;\r\n    }\r\n    case 'object': {\r\n      while (startIndex < str.length && chars.includes(str[startIndex])) {\r\n        startIndex++;\r\n      }\r\n    }\r\n  }\r\n\r\n  return str.substring(startIndex);\r\n}\r\n","/**\r\n * Removes trailing whitespace or specified characters from a string.\r\n *\r\n * @param {string} str - The string from which trailing characters will be trimmed.\r\n * @param {string | string[]} chars - The character(s) to remove from the end of the string.\r\n * @returns {string} - The resulting string after the specified trailing character has been removed.\r\n *\r\n * @example\r\n * const trimmedStr1 = trimEnd('hello---', '-') // returns 'hello'\r\n * const trimmedStr2 = trimEnd('123000', '0') // returns '123'\r\n * const trimmedStr3 = trimEnd('abcabcabc', 'c') // returns 'abcabcab'\r\n * const trimmedStr4 = trimEnd('trimmedxxx', 'x') // returns 'trimmed'\r\n */\r\nexport function trimEnd(str: string, chars?: string | string[]): string {\r\n  if (chars === undefined) {\r\n    return str.trimEnd();\r\n  }\r\n\r\n  let endIndex = str.length;\r\n\r\n  switch (typeof chars) {\r\n    case 'string': {\r\n      while (endIndex > 0 && str[endIndex - 1] === chars) {\r\n        endIndex--;\r\n      }\r\n      break;\r\n    }\r\n    case 'object': {\r\n      while (endIndex > 0 && chars.includes(str[endIndex - 1])) {\r\n        endIndex--;\r\n      }\r\n    }\r\n  }\r\n\r\n  return str.substring(0, endIndex);\r\n}\r\n","import { trimStart } from './trimStart.ts';\r\nimport { trimEnd } from './trimEnd.ts';\r\n\r\n/**\r\n * Removes leading and trailing whitespace or specified characters from a string.\r\n *\r\n * @param {string} str - The string from which characters will be trimmed.\r\n * @param {string | string[]} chars - The character(s) to remove from the string. Can be a single character or an array of characters.\r\n * @returns {string} - The resulting string after the specified characters have been removed.\r\n *\r\n * @example\r\n * trim(\"  hello  \"); // \"hello\"\r\n * trim(\"--hello--\", \"-\"); // \"hello\"\r\n * trim(\"##hello##\", [\"#\", \"o\"]); // \"hell\"\r\n */\r\nexport function trim(str: string, chars?: string | string[]): string {\r\n  if (chars === undefined) {\r\n    return str.trim();\r\n  }\r\n\r\n  return trimStart(trimEnd(str, chars), chars);\r\n}\r\n","const deburrMap = new Map<string, string>(\r\n  Object.entries({\r\n    Æ: 'Ae',\r\n    Ð: 'D',\r\n    Ø: 'O',\r\n    Þ: 'Th',\r\n    ß: 'ss',\r\n    æ: 'ae',\r\n    ð: 'd',\r\n    ø: 'o',\r\n    þ: 'th',\r\n    Đ: 'D',\r\n    đ: 'd',\r\n    Ħ: 'H',\r\n    ħ: 'h',\r\n    ı: 'i',\r\n    Ĳ: 'IJ',\r\n    ĳ: 'ij',\r\n    ĸ: 'k',\r\n    Ŀ: 'L',\r\n    ŀ: 'l',\r\n    Ł: 'L',\r\n    ł: 'l',\r\n    ŉ: \"'n\",\r\n    Ŋ: 'N',\r\n    ŋ: 'n',\r\n    Œ: 'Oe',\r\n    œ: 'oe',\r\n    Ŧ: 'T',\r\n    ŧ: 't',\r\n    ſ: 's',\r\n  })\r\n);\r\n\r\n/**\r\n * Converts a string by replacing special characters and diacritical marks with their ASCII equivalents.\r\n * For example, \"Crème brûlée\" becomes \"Creme brulee\".\r\n *\r\n * @param {string} str - The input string to be deburred.\r\n * @returns {string} - The deburred string with special characters replaced by their ASCII equivalents.\r\n *\r\n * @example\r\n * // Basic usage:\r\n * deburr('Æthelred') // returns 'Aethelred'\r\n *\r\n * @example\r\n * // Handling diacritical marks:\r\n * deburr('München') // returns 'Munchen'\r\n *\r\n * @example\r\n * // Special characters:\r\n * deburr('Crème brûlée') // returns 'Creme brulee'\r\n */\r\nexport function deburr(str: string): string {\r\n  str = str.normalize('NFD');\r\n\r\n  let result = '';\r\n\r\n  for (let i = 0; i < str.length; i++) {\r\n    const char = str[i];\r\n\r\n    if ((char >= '\\u0300' && char <= '\\u036f') || (char >= '\\ufe20' && char <= '\\ufe23')) {\r\n      continue;\r\n    }\r\n\r\n    result += deburrMap.get(char) ?? char;\r\n  }\r\n\r\n  return result;\r\n}\r\n","const htmlEscapes: Record<string, string> = {\r\n  '&': '&amp;',\r\n  '<': '&lt;',\r\n  '>': '&gt;',\r\n  '\"': '&quot;',\r\n  \"'\": '&#39;',\r\n};\r\n\r\n/**\r\n * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `str` to their corresponding HTML entities.\r\n * For example, \"<\" becomes \"&lt;\".\r\n *\r\n * @param {string} str  The string to escape.\r\n * @returns {string} Returns the escaped string.\r\n *\r\n * @example\r\n * escape('This is a <div> element.'); // returns 'This is a &lt;div&gt; element.'\r\n * escape('This is a \"quote\"'); // returns 'This is a &quot;quote&quot;'\r\n * escape(\"This is a 'quote'\"); // returns 'This is a &#39;quote&#39;'\r\n * escape('This is a & symbol'); // returns 'This is a &amp; symbol'\r\n */\r\nexport function escape(str: string): string {\r\n  return str.replace(/[&<>\"']/g, match => htmlEscapes[match]);\r\n}\r\n","const htmlUnescapes: Record<string, string> = {\r\n  '&amp;': '&',\r\n  '&lt;': '<',\r\n  '&gt;': '>',\r\n  '&quot;': '\"',\r\n  '&#39;': \"'\",\r\n};\r\n\r\n/**\r\n * Converts the HTML entities `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `str` to their corresponding characters.\r\n * It is the inverse of `escape`.\r\n *\r\n * @param {string} str The string to unescape.\r\n * @returns {string} Returns the unescaped string.\r\n *\r\n * @example\r\n * unescape('This is a &lt;div&gt; element.'); // returns 'This is a <div> element.'\r\n * unescape('This is a &quot;quote&quot;'); // returns 'This is a \"quote\"'\r\n * unescape('This is a &#39;quote&#39;'); // returns 'This is a 'quote''\r\n * unescape('This is a &amp; symbol'); // returns 'This is a & symbol'\r\n */\r\nexport function unescape(str: string): string {\r\n  return str.replace(/&(?:amp|lt|gt|quot|#(0+)?39);/g, match => htmlUnescapes[match] || \"'\");\r\n}\r\n","/**\r\n * Checks if a given key is a deep key.\r\n *\r\n * A deep key is a string that contains a dot (.) or square brackets with a property accessor.\r\n *\r\n * @param {PropertyKey} key - The key to check.\r\n * @returns {boolean} - Returns true if the key is a deep key, otherwise false.\r\n *\r\n * Examples:\r\n *\r\n * isDeepKey('a.b') // true\r\n * isDeepKey('a[b]') // true\r\n * isDeepKey('a') // false\r\n * isDeepKey(123) // false\r\n * isDeepKey('a.b.c') // true\r\n * isDeepKey('a[b][c]') // true\r\n */\r\nexport function isDeepKey(key: PropertyKey): boolean {\r\n  switch (typeof key) {\r\n    case 'number':\r\n    case 'symbol': {\r\n      return false;\r\n    }\r\n    case 'string': {\r\n      return key.includes('.') || key.includes('[') || key.includes(']');\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Converts `value` to a string key if it's not a string or symbol.\r\n *\r\n * @private\r\n * @param {*} value The value to inspect.\r\n * @returns {string|symbol} Returns the key.\r\n */\r\nexport function toKey(value: number) {\r\n  if (Object.is(value, -0)) {\r\n    return '-0';\r\n  }\r\n  return value.toString();\r\n}\r\n","const DOTS_KEY = /^[\\w.]+$/g;\r\n\r\nconst ESCAPE_REGEXP = /\\\\(\\\\)?/g;\r\nconst PROPERTY_REGEXP = RegExp(\r\n  // Match anything that isn't a dot or bracket.\r\n  '[^.[\\\\]]+' +\r\n    '|' +\r\n    // Or match property names within brackets.\r\n    '\\\\[(?:' +\r\n    // Match a non-string expression.\r\n    '([^\"\\'][^[]*)' +\r\n    '|' +\r\n    // Or match strings (supports escaping characters).\r\n    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\r\n    ')\\\\]' +\r\n    '|' +\r\n    // Or match \"\" as the space between consecutive dots or empty brackets.\r\n    '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))',\r\n  'g'\r\n);\r\n\r\n/**\r\n * Converts a deep key string into an array of path segments.\r\n *\r\n * This function takes a string representing a deep key (e.g., 'a.b.c' or 'a[b][c]') and breaks it down into an array of strings, each representing a segment of the path.\r\n *\r\n * @param {string} deepKey - The deep key string to convert.\r\n * @returns {string[]} An array of strings, each representing a segment of the path.\r\n *\r\n * Examples:\r\n *\r\n * toPath('a.b.c') // Returns ['a', 'b', 'c']\r\n * toPath('a[b][c]') // Returns ['a', 'b', 'c']\r\n * toPath('.a.b.c') // Returns ['', 'a', 'b', 'c']\r\n * toPath('a[\"b.c\"].d') // Returns ['a', 'b.c', 'd']\r\n * toPath('') // Returns []\r\n * toPath('.a[b].c.d[e][\"f.g\"].h') // Returns ['', 'a', 'b', 'c', 'd', 'e', 'f.g', 'h']\r\n */\r\nexport function toPath(deepKey: string): string[] {\r\n  if (DOTS_KEY.test(deepKey)) {\r\n    return deepKey.split('.');\r\n  }\r\n\r\n  const result: string[] = [];\r\n\r\n  if (deepKey[0] === '.') {\r\n    result.push('');\r\n  }\r\n\r\n  const matches = deepKey.matchAll(PROPERTY_REGEXP);\r\n\r\n  for (const match of matches) {\r\n    let key = match[0];\r\n    const expr = match[1];\r\n    const quote = match[2];\r\n    const substr = match[3];\r\n\r\n    if (quote) {\r\n      key = substr.replace(ESCAPE_REGEXP, '$1');\r\n    } else if (expr) {\r\n      key = expr;\r\n    }\r\n\r\n    result.push(key);\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { isDeepKey } from '../_internal/isDeepKey.ts';\r\nimport { toKey } from '../_internal/toKey.ts';\r\nimport { toPath } from '../util/toPath.ts';\r\nimport type { Get } from './get.types.ts';\r\n\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K - The type of the key in the object.\r\n * @template D - The type of the default value.\r\n *\r\n * @param {T} object - The object to query.\r\n * @param {K | [K]} path - The path of the property to get.\r\n * @returns {T[K]} - Returns the resolved value.\r\n */\r\nexport function get<T extends object, K extends keyof T>(object: T, path: K | readonly [K]): T[K];\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K - The type of the key in the object.\r\n *\r\n * @param {T | null | undefined} object - The object to query.\r\n * @param {K | [K]} path - The path of the property to get.\r\n * @returns {T[K] | undefined} - Returns the resolved value.\r\n */\r\nexport function get<T extends object, K extends keyof T>(\r\n  object: T | null | undefined,\r\n  path: K | readonly [K]\r\n): T[K] | undefined;\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K - The type of the key in the object.\r\n * @template D - The type of the default value.\r\n *\r\n * @param {T | null | undefined} object - The object to query.\r\n * @param {K | [K]} path - The path of the property to get.\r\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\r\n * @returns {Exclude<T[K], undefined> | D} - Returns the resolved value.\r\n */\r\nexport function get<T extends object, K extends keyof T, D>(\r\n  object: T | null | undefined,\r\n  path: K | readonly [K],\r\n  defaultValue: D\r\n): Exclude<T[K], undefined> | D;\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the first key in the object.\r\n * @template K2 - The type of the second key in the object.\r\n *\r\n * @param {T} object - The object to query.\r\n * @param {[K1, K2]} path - The path of the property to get.\r\n * @returns {T[K1][K2]} - Returns the resolved value.\r\n */\r\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1]>(\r\n  object: T,\r\n  path: readonly [K1, K2]\r\n): T[K1][K2];\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the first key in the object.\r\n * @template K2 - The type of the second key in the object.\r\n *\r\n * @param {T | null | undefined} object - The object to query.\r\n * @param {[K1, K2]} path - The path of the property to get.\r\n * @returns {T[K1][K2] | undefined} - Returns the resolved value.\r\n */\r\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1]>(\r\n  object: T | null | undefined,\r\n  path: readonly [K1, K2]\r\n): T[K1][K2] | undefined;\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the first key in the object.\r\n * @template K2 - The type of the second key in the object.\r\n * @template D - The type of the default value.\r\n *\r\n * @param {T | null | undefined} object - The object to query.\r\n * @param {[K1, K2]} path - The path of the property to get.\r\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\r\n * @returns {Exclude<T[K1][K2], undefined> | D} - Returns the resolved value.\r\n */\r\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], D>(\r\n  object: T | null | undefined,\r\n  path: readonly [K1, K2],\r\n  defaultValue: D\r\n): Exclude<T[K1][K2], undefined> | D;\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the first key in the object.\r\n * @template K2 - The type of the second key in the object.\r\n * @template K3 - The type of the third key in the object.\r\n *\r\n * @param {T} object - The object to query.\r\n * @param {[K1, K2, K3]} path - The path of the property to get.\r\n * @returns {T[K1][K2][K3]} - Returns the resolved value.\r\n */\r\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\r\n  object: T,\r\n  path: readonly [K1, K2, K3]\r\n): T[K1][K2][K3];\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the first key in the object.\r\n * @template K2 - The type of the second key in the object.\r\n * @template K3 - The type of the third key in the object.\r\n *\r\n * @param {T | null | undefined} object - The object to query.\r\n * @param {[K1, K2, K3]} path - The path of the property to get.\r\n * @returns {T[K1][K2][K3] | undefined} - Returns the resolved value.\r\n */\r\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\r\n  object: T | null | undefined,\r\n  path: readonly [K1, K2, K3]\r\n): T[K1][K2][K3] | undefined;\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the first key in the object.\r\n * @template K2 - The type of the second key in the object.\r\n * @template K3 - The type of the third key in the object.\r\n * @template D - The type of the default value.\r\n *\r\n * @param {T | null | undefined} object - The object to query.\r\n * @param {[K1, K2, K3]} path - The path of the property to get.\r\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\r\n * @returns {Exclude<T[K1][K2][K3], undefined> | D} - Returns the resolved value.\r\n */\r\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], D>(\r\n  object: T | null | undefined,\r\n  path: readonly [K1, K2, K3],\r\n  defaultValue: D\r\n): Exclude<T[K1][K2][K3], undefined> | D;\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the first key in the object.\r\n * @template K2 - The type of the second key in the object.\r\n * @template K3 - The type of the third key in the object.\r\n * @template K4 - The type of the fourth key in the object.\r\n *\r\n * @param {T} object - The object to query.\r\n * @param {[K1, K2, K3, K4]} path - The path of the property to get.\r\n * @returns {T[K1][K2][K3][K4]} - Returns the resolved value.\r\n */\r\nexport function get<\r\n  T extends object,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n>(object: T, path: readonly [K1, K2, K3, K4]): T[K1][K2][K3][K4];\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the first key in the object.\r\n * @template K2 - The type of the second key in the object.\r\n * @template K3 - The type of the third key in the object.\r\n * @template K4 - The type of the fourth key in the object.\r\n *\r\n * @param {T | null | undefined} object - The object to query.\r\n * @param {[K1, K2, K3, K4]} path - The path of the property to get.\r\n * @returns {T[K1][K2][K3][K4] | undefined} - Returns the resolved value.\r\n */\r\nexport function get<\r\n  T extends object,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n>(object: T | null | undefined, path: readonly [K1, K2, K3, K4]): T[K1][K2][K3][K4] | undefined;\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the first key in the object.\r\n * @template K2 - The type of the second key in the object.\r\n * @template K3 - The type of the third key in the object.\r\n * @template K4 - The type of the fourth key in the object.\r\n * @template D - The type of the default value.\r\n *\r\n * @param {T | null | undefined} object - The object to query.\r\n * @param {[K1, K2, K3, K4]} path - The path of the property to get.\r\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\r\n * @returns {Exclude<T[K1][K2][K3][K4], undefined> | D} - Returns the resolved value.\r\n */\r\nexport function get<\r\n  T extends object,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n  D,\r\n>(\r\n  object: T | null | undefined,\r\n  path: readonly [K1, K2, K3, K4],\r\n  defaultValue: D\r\n): Exclude<T[K1][K2][K3][K4], undefined> | D;\r\n/**\r\n * Retrieves the value at a given path from an object with numeric keys. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the value.\r\n *\r\n * @param {Record<number, T>} object - The object to query.\r\n * @param {number} path - The path of the property to get.\r\n * @returns {T} - Returns the resolved value.\r\n */\r\nexport function get<T>(object: Record<number, T>, path: number): T;\r\n/**\r\n * Retrieves the value at a given path from an object with numeric keys. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the value.\r\n *\r\n * @param {Record<number, T> | null | undefined} object - The object to query.\r\n * @param {number} path - The path of the property to get.\r\n * @returns {T | undefined} - Returns the resolved value.\r\n */\r\nexport function get<T>(object: Record<number, T> | null | undefined, path: number): T | undefined;\r\n/**\r\n * Retrieves the value at a given path from an object with numeric keys. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the value.\r\n * @template D - The type of the default value.\r\n *\r\n * @param {Record<number, T> | null | undefined} object - The object to query.\r\n * @param {number} path - The path of the property to get.\r\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\r\n * @returns {T | D} - Returns the resolved value.\r\n */\r\nexport function get<T, D>(object: Record<number, T> | null | undefined, path: number, defaultValue: D): T | D;\r\n/**\r\n * Retrieves the value at a given path from a null or undefined object, returning the default value.\r\n *\r\n * @template D - The type of the default value.\r\n *\r\n * @param {null | undefined} object - The object to query.\r\n * @param {PropertyKey} path - The path of the property to get.\r\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\r\n * @returns {D} - Returns the default value.\r\n */\r\nexport function get<D>(object: null | undefined, path: PropertyKey, defaultValue: D): D;\r\n/**\r\n * Retrieves the value at a given path from a null or undefined object, returning undefined.\r\n *\r\n * @param {null | undefined} object - The object to query.\r\n * @param {PropertyKey} path - The path of the property to get.\r\n * @returns {undefined} - Returns undefined.\r\n */\r\nexport function get(object: null | undefined, path: PropertyKey): undefined;\r\n/**\r\n * Retrieves the value at a given path from a string-keyed object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template P - The type of the path.\r\n *\r\n * @param {T} data - The object to query.\r\n * @param {P} path - The path of the property to get.\r\n * @returns {string extends P ? any : Get<T, P>} - Returns the resolved value.\r\n */\r\nexport function get<T, P extends string>(data: T, path: P): string extends P ? any : Get<T, P>;\r\n/**\r\n * Retrieves the value at a given path from a string-keyed object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @template T - The type of the object.\r\n * @template P - The type of the path.\r\n * @template D - The type of the default value.\r\n *\r\n * @param {T} data - The object to query.\r\n * @param {P} path - The path of the property to get.\r\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\r\n * @returns {Exclude<Get<T, P>, null | undefined> | D} - Returns the resolved value.\r\n */\r\nexport function get<T, P extends string, D = Get<T, P>>(\r\n  data: T,\r\n  path: P,\r\n  defaultValue: D\r\n): Exclude<Get<T, P>, null | undefined> | D;\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @param {unknown} object - The object to query.\r\n * @param {PropertyKey | readonly PropertyKey[]} path - The path of the property to get.\r\n * @param {unknown} [defaultValue] - The value returned if the resolved value is undefined.\r\n * @returns {any} - Returns the resolved value.\r\n */\r\nexport function get(object: unknown, path: PropertyKey | readonly PropertyKey[], defaultValue?: unknown): any;\r\n/**\r\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\r\n *\r\n * @param {unknown} object - The object to query.\r\n * @param {PropertyKey | readonly PropertyKey[]} path - The path of the property to get.\r\n * @param {unknown} [defaultValue] - The value returned if the resolved value is undefined.\r\n * @returns {any} - Returns the resolved value.\r\n */\r\nexport function get(object: any, path: PropertyKey | readonly PropertyKey[], defaultValue?: any): any {\r\n  if (object == null) {\r\n    return defaultValue;\r\n  }\r\n\r\n  switch (typeof path) {\r\n    case 'string': {\r\n      const result = object[path];\r\n\r\n      if (result === undefined) {\r\n        if (isDeepKey(path)) {\r\n          return get(object, toPath(path), defaultValue);\r\n        } else {\r\n          return defaultValue;\r\n        }\r\n      }\r\n\r\n      return result;\r\n    }\r\n    case 'number':\r\n    case 'symbol': {\r\n      if (typeof path === 'number') {\r\n        path = toKey(path);\r\n      }\r\n\r\n      const result = object[path];\r\n\r\n      if (result === undefined) {\r\n        return defaultValue;\r\n      }\r\n\r\n      return result;\r\n    }\r\n    default: {\r\n      if (Array.isArray(path)) {\r\n        return getWithPath(object, path, defaultValue);\r\n      }\r\n\r\n      if (Object.is(path?.valueOf(), -0)) {\r\n        path = '-0';\r\n      } else {\r\n        path = String(path);\r\n      }\r\n\r\n      const result = object[path];\r\n\r\n      if (result === undefined) {\r\n        return defaultValue;\r\n      }\r\n\r\n      return result;\r\n    }\r\n  }\r\n}\r\n\r\nfunction getWithPath(object: any, path: readonly PropertyKey[], defaultValue?: any): any {\r\n  if (path.length === 0) {\r\n    return defaultValue;\r\n  }\r\n\r\n  let current = object;\r\n\r\n  for (let index = 0; index < path.length; index++) {\r\n    if (current == null) {\r\n      return defaultValue;\r\n    }\r\n\r\n    current = current[path[index]];\r\n  }\r\n\r\n  if (current === undefined) {\r\n    return defaultValue;\r\n  }\r\n\r\n  return current;\r\n}\r\n","import { get } from './get.ts';\r\n\r\n/**\r\n * Creates a function that returns the value at a given path of an object.\r\n *\r\n * @param {PropertyKey | PropertyKey[]} path - The path of the property to get.\r\n * @returns {(object: unknown) => any} - Returns a new function that takes an object and returns the value at the specified path.\r\n *\r\n * @example\r\n * const getObjectValue = property('a.b.c');\r\n * const result = getObjectValue({ a: { b: { c: 3 } } });\r\n * console.log(result); // => 3\r\n *\r\n * @example\r\n * const getObjectValue = property(['a', 'b', 'c']);\r\n * const result = getObjectValue({ a: { b: { c: 3 } } });\r\n * console.log(result); // => 3\r\n */\r\nexport function property(path: PropertyKey | readonly PropertyKey[]): (object: unknown) => any {\r\n  return function (object: unknown) {\r\n    return get(object, path);\r\n  };\r\n}\r\n","import { isPrimitive } from '../../predicate/isPrimitive.ts';\r\n\r\n/**\r\n * Checks if the target matches the source by comparing their structures and values.\r\n * This function supports deep comparison for objects, arrays, maps, and sets.\r\n *\r\n * @param {unknown} target - The target value to match against.\r\n * @param {unknown} source - The source value to match with.\r\n * @returns {boolean} - Returns `true` if the target matches the source, otherwise `false`.\r\n *\r\n * @example\r\n * // Basic usage\r\n * isMatch({ a: 1, b: 2 }, { a: 1 }); // true\r\n *\r\n * @example\r\n * // Matching arrays\r\n * isMatch([1, 2, 3], [1, 2, 3]); // true\r\n *\r\n * @example\r\n * // Matching maps\r\n * const targetMap = new Map([['key1', 'value1'], ['key2', 'value2']]);\r\n * const sourceMap = new Map([['key1', 'value1']]);\r\n * isMatch(targetMap, sourceMap); // true\r\n *\r\n * @example\r\n * // Matching sets\r\n * const targetSet = new Set([1, 2, 3]);\r\n * const sourceSet = new Set([1, 2]);\r\n * isMatch(targetSet, sourceSet); // true\r\n */\r\nexport function isMatch(target: unknown, source: unknown): boolean;\r\n/**\r\n * Checks if the target matches the source by comparing their structures and values.\r\n * This function supports deep comparison for objects, arrays, maps, and sets.\r\n *\r\n * @param {unknown} target - The target value to match against.\r\n * @param {unknown} source - The source value to match with.\r\n * @returns {boolean} - Returns `true` if the target matches the source, otherwise `false`.\r\n *\r\n * @example\r\n * // Basic usage\r\n * isMatch({ a: 1, b: 2 }, { a: 1 }); // true\r\n *\r\n * @example\r\n * // Matching arrays\r\n * isMatch([1, 2, 3], [1, 2, 3]); // true\r\n *\r\n * @example\r\n * // Matching maps\r\n * const targetMap = new Map([['key1', 'value1'], ['key2', 'value2']]);\r\n * const sourceMap = new Map([['key1', 'value1']]);\r\n * isMatch(targetMap, sourceMap); // true\r\n *\r\n * @example\r\n * // Matching sets\r\n * const targetSet = new Set([1, 2, 3]);\r\n * const sourceSet = new Set([1, 2]);\r\n * isMatch(targetSet, sourceSet); // true\r\n */\r\nexport function isMatch(target: any, source: any): boolean {\r\n  if (source === target) {\r\n    return true;\r\n  }\r\n\r\n  switch (typeof source) {\r\n    case 'object': {\r\n      if (source == null) {\r\n        return true;\r\n      }\r\n\r\n      const keys = Object.keys(source as any);\r\n\r\n      if (target == null) {\r\n        if (keys.length === 0) {\r\n          return true;\r\n        }\r\n\r\n        return false;\r\n      }\r\n\r\n      if (Array.isArray(source)) {\r\n        return isArrayMatch(target, source);\r\n      }\r\n\r\n      if (source instanceof Map) {\r\n        return isMapMatch(target, source);\r\n      }\r\n\r\n      if (source instanceof Set) {\r\n        return isSetMatch(target, source);\r\n      }\r\n\r\n      for (let i = 0; i < keys.length; i++) {\r\n        const key = keys[i];\r\n\r\n        if (!isPrimitive(target) && !(key in target)) {\r\n          return false;\r\n        }\r\n\r\n        if (source[key] === undefined && target[key] !== undefined) {\r\n          return false;\r\n        }\r\n\r\n        if (!isMatch(target[key], source[key])) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    }\r\n    case 'function': {\r\n      if (Object.keys(source).length > 0) {\r\n        return isMatch(target, { ...source });\r\n      }\r\n\r\n      return false;\r\n    }\r\n    default: {\r\n      return !source;\r\n    }\r\n  }\r\n}\r\n\r\nexport function isMapMatch(target: unknown, source: Map<any, any>) {\r\n  if (source.size === 0) {\r\n    return true;\r\n  }\r\n\r\n  if (!(target instanceof Map)) {\r\n    return false;\r\n  }\r\n\r\n  for (const [key, value] of source.entries()) {\r\n    if (!isMatch(target.get(key), value)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isArrayMatch(target: unknown, source: readonly unknown[]) {\r\n  if (source.length === 0) {\r\n    return true;\r\n  }\r\n\r\n  if (!Array.isArray(target)) {\r\n    return false;\r\n  }\r\n\r\n  const countedIndex = new Set<number>();\r\n\r\n  for (let i = 0; i < source.length; i++) {\r\n    const sourceItem = source[i];\r\n    const index = target.findIndex((targetItem, index) => {\r\n      return isMatch(targetItem, sourceItem) && !countedIndex.has(index);\r\n    });\r\n\r\n    if (index === -1) {\r\n      return false;\r\n    }\r\n\r\n    countedIndex.add(index);\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isSetMatch(target: unknown, source: Set<any>) {\r\n  if (source.size === 0) {\r\n    return true;\r\n  }\r\n\r\n  if (!(target instanceof Set)) {\r\n    return false;\r\n  }\r\n\r\n  return isArrayMatch([...target], [...source]);\r\n}\r\n","import { cloneDeep } from '../../object/cloneDeep.ts';\r\nimport { isMatch } from './isMatch.ts';\r\n\r\n/**\r\n * Creates a function that performs a deep comparison between a given target and the source object.\r\n *\r\n * @param {unknown} source - The source object to create the matcher from.\r\n * @returns {(target: unknown) => boolean} - Returns a function that takes a target object and returns `true` if the target matches the source, otherwise `false`.\r\n *\r\n * @example\r\n * // Basic usage\r\n * const matcher = matches({ a: 1, b: 2 });\r\n * matcher({ a: 1, b: 2, c: 3 }); // true\r\n * matcher({ a: 1, c: 3 }); // false\r\n *\r\n * @example\r\n * // Matching arrays\r\n * const arrayMatcher = matches([1, 2, 3]);\r\n * arrayMatcher([1, 2, 3, 4]); // true\r\n * arrayMatcher([4, 5, 6]); // false\r\n *\r\n * @example\r\n * // Matching objects with nested structures\r\n * const nestedMatcher = matches({ a: { b: 2 } });\r\n * nestedMatcher({ a: { b: 2, c: 3 } }); // true\r\n * nestedMatcher({ a: { c: 3 } }); // false\r\n */\r\nexport function matches(source: unknown): (target: unknown) => boolean {\r\n  source = cloneDeep(source);\r\n\r\n  return (target?: unknown): boolean => {\r\n    return isMatch(target, source);\r\n  };\r\n}\r\n","import { cloneDeep as cloneDeepToolkit, copyProperties } from '../../object/cloneDeep.ts';\r\nimport { argumentsTag, booleanTag, numberTag, stringTag } from '../_internal/tags.ts';\r\n\r\n/**\r\n * Creates a deep clone of the given object.\r\n *\r\n * @template T - The type of the object.\r\n * @param {T} obj - The object to clone.\r\n * @returns {T} - A deep clone of the given object.\r\n *\r\n * @example\r\n * // Clone a primitive values\r\n * const num = 29;\r\n * const clonedNum = clone(num);\r\n * console.log(clonedNum); // 29\r\n * console.log(clonedNum === num) ; // true\r\n *\r\n * @example\r\n * // Clone an array\r\n * const arr = [1, 2, 3];\r\n * const clonedArr = clone(arr);\r\n * console.log(clonedArr); // [1, 2, 3]\r\n * console.log(clonedArr === arr); // false\r\n *\r\n * @example\r\n * // Clone an array with nested objects\r\n * const arr = [1, { a: 1 }, [1, 2, 3]];\r\n * const clonedArr = clone(arr);\r\n * arr[1].a = 2;\r\n * console.log(arr); // [2, { a: 2 }, [1, 2, 3]]\r\n * console.log(clonedArr); // [1, { a: 1 }, [1, 2, 3]]\r\n * console.log(clonedArr === arr); // false\r\n *\r\n * @example\r\n * // Clone an object\r\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\r\n * const clonedObj = clone(obj);\r\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\r\n * console.log(clonedObj === obj); // false\r\n *\r\n * @example\r\n * // Clone an object with nested objects\r\n * const obj = { a: 1, b: { c: 1 } };\r\n * const clonedObj = clone(obj);\r\n * obj.b.c = 2;\r\n * console.log(obj); // { a: 1, b: { c: 2 } }\r\n * console.log(clonedObj); // { a: 1, b: { c: 1 } }\r\n * console.log(clonedObj === obj); // false\r\n */\r\nexport function cloneDeep<T>(obj: T): T {\r\n  if (typeof obj !== 'object') {\r\n    return cloneDeepToolkit(obj);\r\n  }\r\n\r\n  switch (Object.prototype.toString.call(obj)) {\r\n    case numberTag:\r\n    case stringTag:\r\n    case booleanTag: {\r\n      // eslint-disable-next-line\r\n      // @ts-ignore\r\n      const result = new obj.constructor(obj?.valueOf()) as T;\r\n      copyProperties(result, obj);\r\n      return result;\r\n    }\r\n\r\n    case argumentsTag: {\r\n      const result = {} as any;\r\n\r\n      copyProperties(result, obj);\r\n\r\n      // eslint-disable-next-line\r\n      // @ts-ignore\r\n      result.length = obj.length;\r\n      // eslint-disable-next-line\r\n      // @ts-ignore\r\n      result[Symbol.iterator] = obj[Symbol.iterator];\r\n\r\n      return result as T;\r\n    }\r\n\r\n    default: {\r\n      return cloneDeepToolkit(obj);\r\n    }\r\n  }\r\n}\r\n","const IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\\d*)$/;\r\n\r\nexport function isIndex(value: PropertyKey) {\r\n  switch (typeof value) {\r\n    case 'number': {\r\n      return Number.isInteger(value) && value >= 0 && value < Number.MAX_SAFE_INTEGER;\r\n    }\r\n    case 'symbol': {\r\n      return false;\r\n    }\r\n    case 'string': {\r\n      return IS_UNSIGNED_INTEGER.test(value);\r\n    }\r\n  }\r\n}\r\n","import { getTag } from '../_internal/getTag.ts';\r\n\r\n/**\r\n * Checks if the given value is an arguments object.\r\n *\r\n * This function tests whether the provided value is an arguments object or not.\r\n * It returns `true` if the value is an arguments object, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an arguments object.\r\n *\r\n * @param {unknown} value - The value to test if it is an arguments object.\r\n * @returns {value is IArguments} `true` if the value is an arguments, `false` otherwise.\r\n *\r\n * @example\r\n * const args = (function() { return arguments; })();\r\n * const strictArgs = (function() { 'use strict'; return arguments; })();\r\n * const value = [1, 2, 3];\r\n *\r\n * console.log(isArguments(args)); // true\r\n * console.log(isArguments(strictArgs)); // true\r\n * console.log(isArguments(value)); // false\r\n */\r\nexport function isArguments(value?: unknown): value is IArguments {\r\n  return value !== null && typeof value === 'object' && getTag(value) === '[object Arguments]';\r\n}\r\n","import { isDeepKey } from '../_internal/isDeepKey.ts';\r\nimport { isIndex } from '../_internal/isIndex.ts';\r\nimport { toPath } from '../util/toPath.ts';\r\nimport { isArguments } from '../predicate/isArguments.ts';\r\n\r\n/**\r\n * Checks if a given path exists within an object.\r\n *\r\n * You can provide the path as a single property key, an array of property keys,\r\n * or a string representing a deep path.\r\n *\r\n * If the path is an index and the object is an array or an arguments object, the function will verify\r\n * if the index is valid and within the bounds of the array or arguments object, even if the array or\r\n * arguments object is sparse (i.e., not all indexes are defined).\r\n *\r\n * @param {object} object - The object to query.\r\n * @param {PropertyKey | PropertyKey[]} path - The path to check. This can be a single property key,\r\n *        an array of property keys, or a string representing a deep path.\r\n * @returns {boolean} Returns `true` if the path exists in the object, `false` otherwise.\r\n *\r\n * @example\r\n *\r\n * const obj = { a: { b: { c: 3 } } };\r\n *\r\n * has(obj, 'a'); // true\r\n * has(obj, ['a', 'b']); // true\r\n * has(obj, ['a', 'b', 'c']); // true\r\n * has(obj, 'a.b.c'); // true\r\n * has(obj, 'a.b.d'); // false\r\n * has(obj, ['a', 'b', 'c', 'd']); // false\r\n * has([], 0); // false\r\n * has([1, 2, 3], 2); // true\r\n * has([1, 2, 3], 5); // false\r\n */\r\nexport function has(object: unknown, path: PropertyKey | readonly PropertyKey[]): boolean;\r\n\r\n/**\r\n * Checks if a given path exists within an object.\r\n *\r\n * You can provide the path as a single property key, an array of property keys,\r\n * or a string representing a deep path.\r\n *\r\n * If the path is an index and the object is an array or an arguments object, the function will verify\r\n * if the index is valid and within the bounds of the array or arguments object, even if the array or\r\n * arguments object is sparse (i.e., not all indexes are defined).\r\n *\r\n * @param {object} object - The object to query.\r\n * @param {PropertyKey | PropertyKey[]} path - The path to check. This can be a single property key,\r\n *        an array of property keys, or a string representing a deep path.\r\n * @returns {boolean} Returns `true` if the path exists in the object, `false` otherwise.\r\n *\r\n * @example\r\n *\r\n * const obj = { a: { b: { c: 3 } } };\r\n *\r\n * has(obj, 'a'); // true\r\n * has(obj, ['a', 'b']); // true\r\n * has(obj, ['a', 'b', 'c']); // true\r\n * has(obj, 'a.b.c'); // true\r\n * has(obj, 'a.b.d'); // false\r\n * has(obj, ['a', 'b', 'c', 'd']); // false\r\n * has([], 0); // false\r\n * has([1, 2, 3], 2); // true\r\n * has([1, 2, 3], 5); // false\r\n */\r\nexport function has(object: any, path: PropertyKey | readonly PropertyKey[]): boolean {\r\n  let resolvedPath;\r\n\r\n  if (Array.isArray(path)) {\r\n    resolvedPath = path;\r\n  } else if (typeof path === 'string' && isDeepKey(path) && object?.[path] == null) {\r\n    resolvedPath = toPath(path);\r\n  } else {\r\n    resolvedPath = [path];\r\n  }\r\n\r\n  if (resolvedPath.length === 0) {\r\n    return false;\r\n  }\r\n\r\n  let current = object;\r\n\r\n  for (let i = 0; i < resolvedPath.length; i++) {\r\n    const key = resolvedPath[i];\r\n\r\n    // Check if the current key is a direct property of the current object\r\n    if (current == null || !Object.prototype.hasOwnProperty.call(current, key)) {\r\n      const isSparseIndex = (Array.isArray(current) || isArguments(current)) && isIndex(key) && key < current.length;\r\n\r\n      if (!isSparseIndex) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    current = current[key];\r\n  }\r\n\r\n  return true;\r\n}\r\n","import { toKey } from '../_internal/toKey.ts';\r\nimport { cloneDeep } from '../object/cloneDeep.ts';\r\nimport { get } from '../object/get.ts';\r\nimport { has } from '../object/has.ts';\r\nimport { isMatch } from './isMatch.ts';\r\n\r\n/**\r\n * Creates a function that checks if a given target object matches a specific property value.\r\n *\r\n * The returned function takes a target object and determines if the property at the\r\n * specified path within the target object is equal to the given value.\r\n *\r\n * @param {PropertyKey | PropertyKey[]} property - The property path to check within the target object.\r\n *     This can be a single property key or an array of property keys.\r\n * @param {unknown} source - The value to compare against the property value in the target object.\r\n *\r\n * @returns {(target: unknown) => boolean} - A function that takes a target object and returns\r\n *     `true` if the property value at the given path in the target object matches the provided value,\r\n *     otherwise returns `false`.\r\n *\r\n * @example\r\n * // Using a single property key\r\n * const checkName = matchesProperty('name', 'Alice');\r\n * console.log(checkName({ name: 'Alice' })); // true\r\n * console.log(checkName({ name: 'Bob' })); // false\r\n *\r\n * // Using an array of property keys\r\n * const checkNested = matchesProperty(['address', 'city'], 'New York');\r\n * console.log(checkNested({ address: { city: 'New York' } })); // true\r\n * console.log(checkNested({ address: { city: 'Los Angeles' } })); // false\r\n */\r\nexport function matchesProperty(\r\n  property: PropertyKey | readonly PropertyKey[],\r\n  source: unknown\r\n): (target?: unknown) => boolean {\r\n  switch (typeof property) {\r\n    case 'object': {\r\n      if (Object.is(property?.valueOf(), -0)) {\r\n        property = '-0';\r\n      }\r\n      break;\r\n    }\r\n    case 'number': {\r\n      property = toKey(property);\r\n      break;\r\n    }\r\n  }\r\n\r\n  source = cloneDeep(source);\r\n\r\n  return function (target?: unknown) {\r\n    const result = get(target, property as PropertyKey | PropertyKey[]);\r\n\r\n    if (result === undefined) {\r\n      return has(target, property as PropertyKey | PropertyKey[]);\r\n    }\r\n\r\n    if (source === undefined) {\r\n      return result === undefined;\r\n    }\r\n\r\n    return isMatch(result, source);\r\n  };\r\n}\r\n","/**\r\n * Flattens an array up to the specified depth.\r\n *\r\n * @template T - The type of elements within the array.\r\n * @template D - The depth to which the array should be flattened.\r\n * @param {T[] | object} value - The object to flatten.\r\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\r\n * @returns {Array<FlatArray<T[], D>> | []} A new array that has been flattened.\r\n *\r\n * @example\r\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 1);\r\n * // Returns: [1, 2, 3, 4, [5, 6]]\r\n *\r\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 2);\r\n * // Returns: [1, 2, 3, 4, 5, 6]\r\n */\r\nexport function flatten<T, D extends number = 1>(\r\n  value: readonly T[] | object,\r\n  depth = 1 as D\r\n): Array<FlatArray<T[], D>> | [] {\r\n  const result: Array<FlatArray<T[], D>> = [];\r\n  const flooredDepth = Math.floor(depth);\r\n\r\n  if (!Array.isArray(value)) {\r\n    return result;\r\n  }\r\n\r\n  const recursive = (arr: readonly T[], currentDepth: number) => {\r\n    for (let i = 0; i < arr.length; i++) {\r\n      const item = arr[i];\r\n      if (\r\n        currentDepth < flooredDepth &&\r\n        (Array.isArray(item) ||\r\n          Boolean(item?.[Symbol.isConcatSpreadable as keyof object]) ||\r\n          (item !== null && typeof item === 'object' && Object.prototype.toString.call(item) === '[object Arguments]'))\r\n      ) {\r\n        if (Array.isArray(item)) {\r\n          recursive(item, currentDepth + 1);\r\n        } else {\r\n          recursive(Array.from(item as T[]), currentDepth + 1);\r\n        }\r\n      } else {\r\n        result.push(item as FlatArray<T[], D>);\r\n      }\r\n    }\r\n  };\r\n\r\n  recursive(value, 0);\r\n\r\n  return result;\r\n}\r\n","function getPriority(a: unknown): 0 | 1 | 2 | 3 | 4 {\r\n  if (typeof a === 'symbol') {\r\n    return 1;\r\n  }\r\n\r\n  if (a === null) {\r\n    return 2;\r\n  }\r\n\r\n  if (a === undefined) {\r\n    return 3;\r\n  }\r\n\r\n  if (a !== a) {\r\n    return 4;\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nexport const compareValues = <V>(a: V, b: V, order: string) => {\r\n  if (a !== b) {\r\n    // If both values are strings, compare them using localeCompare.\r\n    if (typeof a === 'string' && typeof b === 'string') {\r\n      return order === 'desc' ? b.localeCompare(a) : a.localeCompare(b);\r\n    }\r\n\r\n    const aPriority = getPriority(a);\r\n    const bPriority = getPriority(b);\r\n\r\n    // If both values are of the same priority and are normal values, compare them.\r\n    if (aPriority === bPriority && aPriority === 0) {\r\n      if (a < b) {\r\n        return order === 'desc' ? 1 : -1;\r\n      }\r\n\r\n      if (a > b) {\r\n        return order === 'desc' ? -1 : 1;\r\n      }\r\n    }\r\n\r\n    return order === 'desc' ? bPriority - aPriority : aPriority - bPriority;\r\n  }\r\n\r\n  return 0;\r\n};\r\n","/**\r\n * Check whether a value is a symbol.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `symbol`.\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {value is symbol} Returns `true` if `value` is a symbol, else `false`.\r\n * @example\r\n * isSymbol(Symbol.iterator);\r\n * // => true\r\n *\r\n * isSymbol('abc');\r\n * // => false\r\n */\r\nexport function isSymbol(value?: unknown): value is symbol {\r\n  return typeof value === 'symbol' || value instanceof Symbol;\r\n}\r\n","import { isSymbol } from '../predicate/isSymbol.ts';\r\n\r\n/**  Matches any deep property path. (e.g. `a.b[0].c`)*/\r\nconst regexIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\r\n/**  Matches any word character (alphanumeric & underscore).*/\r\nconst regexIsPlainProp = /^\\w*$/;\r\n\r\n/**\r\n * Checks if `value` is a property name and not a property path. (It's ok that the `value` is not in the keys of the `object`)\r\n * @param {unknown} value The value to check.\r\n * @param {unknown} object The object to query.\r\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\r\n *\r\n * @example\r\n * isKey('a', { a: 1 });\r\n * // => true\r\n *\r\n * isKey('a.b', { a: { b: 2 } });\r\n * // => false\r\n */\r\nexport function isKey(value?: unknown, object?: unknown): boolean {\r\n  if (Array.isArray(value)) {\r\n    return false;\r\n  }\r\n\r\n  if (typeof value === 'number' || typeof value === 'boolean' || value == null || isSymbol(value)) {\r\n    return true;\r\n  }\r\n\r\n  return (\r\n    (typeof value === 'string' && (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value))) ||\r\n    (object != null && Object.hasOwn(object, value as PropertyKey))\r\n  );\r\n}\r\n","import { compareValues } from '../_internal/compareValues.ts';\r\nimport { isKey } from '../_internal/isKey.ts';\r\nimport { toPath } from '../util/toPath.ts';\r\n\r\nexport type Criterion<T> = ((item: T) => unknown) | PropertyKey | PropertyKey[] | null | undefined;\r\n/**\r\n * Sorts an array of objects based on multiple properties and their corresponding order directions.\r\n *\r\n * This function takes an array of objects, an array of criteria to sort by, and an array of order directions.\r\n * It returns the sorted array, ordering by each key according to its corresponding direction ('asc' for ascending or 'desc' for descending).\r\n * If values for a key are equal, it moves to the next key to determine the order.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param { T[] | object | null | undefined} collection - The array of objects to be sorted.\r\n * @param {Criterion<T> | Array<Criterion<T>>} criteria - An array of criteria (property names or property paths or custom key functions) to sort by.\r\n * @param {unknown | unknown[]} orders - An array of order directions ('asc' for ascending or 'desc' for descending).\r\n * @returns {T[]} - The sorted array.\r\n *\r\n * @example\r\n * // Sort an array of objects by 'user' in ascending order and 'age' in descending order.\r\n * const users = [\r\n *   { user: 'fred', age: 48 },\r\n *   { user: 'barney', age: 34 },\r\n *   { user: 'fred', age: 40 },\r\n *   { user: 'barney', age: 36 },\r\n * ];\r\n * const result = orderBy(users, ['user', (item) => item.age], ['asc', 'desc']);\r\n * // result will be:\r\n * // [\r\n * //   { user: 'barney', age: 36 },\r\n * //   { user: 'barney', age: 34 },\r\n * //   { user: 'fred', age: 48 },\r\n * //   { user: 'fred', age: 40 },\r\n * // ]\r\n */\r\nexport function orderBy<T>(\r\n  collection: readonly T[] | object | number | null | undefined,\r\n  criteria?: Criterion<T> | Array<Criterion<T>>,\r\n  orders?: unknown | unknown[]\r\n): T[] {\r\n  if (collection == null || typeof collection === 'number') {\r\n    return [];\r\n  }\r\n\r\n  if (typeof collection === 'object' && !Array.isArray(collection)) {\r\n    collection = Object.values(collection);\r\n  }\r\n\r\n  if (!Array.isArray(criteria)) {\r\n    criteria = criteria == null ? [null] : [criteria];\r\n  }\r\n\r\n  if (!Array.isArray(orders)) {\r\n    orders = orders == null ? [] : [orders];\r\n  }\r\n\r\n  // For Object('desc') case\r\n  orders = (orders as unknown[]).map(order => String(order));\r\n\r\n  const getValueByNestedPath = (object: object, path: PropertyKey[]) => {\r\n    let target: object = object;\r\n\r\n    for (let i = 0; i < path.length && target != null; ++i) {\r\n      target = target[path[i] as keyof typeof target];\r\n    }\r\n\r\n    return target;\r\n  };\r\n\r\n  const getValueByCriterion = (criterion: Criterion<T> | { key: PropertyKey; path: string[] }, object: T) => {\r\n    if (object == null || criterion == null) {\r\n      return object;\r\n    }\r\n\r\n    if (typeof criterion === 'object' && 'key' in criterion) {\r\n      if (Object.hasOwn(object, criterion.key)) {\r\n        return object[criterion.key as keyof typeof object];\r\n      }\r\n\r\n      return getValueByNestedPath(object, criterion.path);\r\n    }\r\n\r\n    if (typeof criterion === 'function') {\r\n      return criterion(object);\r\n    }\r\n\r\n    if (Array.isArray(criterion)) {\r\n      return getValueByNestedPath(object, criterion);\r\n    }\r\n\r\n    if (typeof object === 'object') {\r\n      return object[criterion as keyof typeof object];\r\n    }\r\n\r\n    return object;\r\n  };\r\n\r\n  // Prepare all cases for criteria\r\n  const preparedCriteria = criteria.map(criterion => {\r\n    // lodash handles a array with one element as a single criterion\r\n    if (Array.isArray(criterion) && criterion.length === 1) {\r\n      criterion = criterion[0];\r\n    }\r\n\r\n    if (criterion == null || typeof criterion === 'function' || Array.isArray(criterion) || isKey(criterion)) {\r\n      return criterion;\r\n    }\r\n\r\n    // If criterion is not key, it has possibility to be a deep path. So we have to prepare both cases.\r\n    return { key: criterion, path: toPath(criterion as string) } as const;\r\n  });\r\n\r\n  // Array.prototype.sort() always shifts the `undefined` values to the end of the array. So we have to prevent it by using a wrapper object.\r\n  const preparedCollection = (collection as T[]).map(item => ({\r\n    original: item,\r\n    criteria: preparedCriteria.map(criterion => getValueByCriterion(criterion, item)),\r\n  }));\r\n\r\n  return preparedCollection\r\n    .slice()\r\n    .sort((a, b) => {\r\n      for (let i = 0; i < preparedCriteria.length; i++) {\r\n        const comparedResult = compareValues(a.criteria[i], b.criteria[i], (orders as string[])[i]);\r\n\r\n        if (comparedResult !== 0) {\r\n          return comparedResult;\r\n        }\r\n      }\r\n\r\n      return 0;\r\n    })\r\n    .map(item => item.original);\r\n}\r\n","export function identity<T>(x: T) {\r\n  return x;\r\n}\r\n","import { isIndex } from '../_internal/isIndex.ts';\r\nimport { toPath } from '../util/toPath.ts';\r\n\r\n/**\r\n * Sets the value at the specified path of the given object. If any part of the path does not exist, it will be created.\r\n *\r\n * @template T - The type of the object.\r\n * @param {T} obj - The object to modify.\r\n * @param {PropertyKey | PropertyKey[]} path - The path of the property to set.\r\n * @param {any} value - The value to set.\r\n * @returns {T} - The modified object.\r\n *\r\n * @example\r\n * // Set a value in a nested object\r\n * const obj = { a: { b: { c: 3 } } };\r\n * set(obj, 'a.b.c', 4);\r\n * console.log(obj.a.b.c); // 4\r\n *\r\n * @example\r\n * // Set a value in an array\r\n * const arr = [1, 2, 3];\r\n * set(arr, 1, 4);\r\n * console.log(arr[1]); // 4\r\n *\r\n * @example\r\n * // Create non-existent path and set value\r\n * const obj = {};\r\n * set(obj, 'a.b.c', 4);\r\n * console.log(obj); // { a: { b: { c: 4 } } }\r\n */\r\nexport function set<T>(obj: object, path: PropertyKey | readonly PropertyKey[], value: unknown): T;\r\n/**\r\n * Sets the value at the specified path of the given object. If any part of the path does not exist, it will be created.\r\n *\r\n * @template T - The type of the object.\r\n * @param {T} obj - The object to modify.\r\n * @param {PropertyKey | PropertyKey[]} path - The path of the property to set.\r\n * @param {any} value - The value to set.\r\n * @returns {T} - The modified object.\r\n *\r\n * @example\r\n * // Set a value in a nested object\r\n * const obj = { a: { b: { c: 3 } } };\r\n * set(obj, 'a.b.c', 4);\r\n * console.log(obj.a.b.c); // 4\r\n *\r\n * @example\r\n * // Set a value in an array\r\n * const arr = [1, 2, 3];\r\n * set(arr, 1, 4);\r\n * console.log(arr[1]); // 4\r\n *\r\n * @example\r\n * // Create non-existent path and set value\r\n * const obj = {};\r\n * set(obj, 'a.b.c', 4);\r\n * console.log(obj); // { a: { b: { c: 4 } } }\r\n */\r\nexport function set<T extends object>(obj: T, path: PropertyKey | readonly PropertyKey[], value: unknown): T {\r\n  const resolvedPath = Array.isArray(path) ? path : typeof path === 'string' ? toPath(path) : [path];\r\n\r\n  let current: any = obj;\r\n\r\n  for (let i = 0; i < resolvedPath.length - 1; i++) {\r\n    const key = resolvedPath[i];\r\n    const nextKey = resolvedPath[i + 1];\r\n\r\n    if (current[key] == null) {\r\n      current[key] = isIndex(nextKey) ? [] : {};\r\n    }\r\n\r\n    current = current[key];\r\n  }\r\n\r\n  const lastKey = resolvedPath[resolvedPath.length - 1];\r\n  current[lastKey] = value;\r\n\r\n  return obj;\r\n}\r\n","/**\r\n * Creates a function that invokes `func` with the `this` binding of `thisArg` and `partials` prepended to the arguments it receives.\r\n *\r\n * The `bind.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\r\n *\r\n * Note: Unlike native `Function#bind`, this method doesn't set the `length` property of bound functions.\r\n *\r\n * @template F - The type of the function to bind.\r\n * @param {F} func - The function to bind.\r\n * @param {unknown} thisObj - The `this` binding of `func`.\r\n * @param {...any} partialArgs - The arguments to be partially applied.\r\n * @returns {F} - Returns the new bound function.\r\n *\r\n * @example\r\n * function greet(greeting, punctuation) {\r\n *   return greeting + ' ' + this.user + punctuation;\r\n * }\r\n * const object = { user: 'fred' };\r\n * let bound = bind(greet, object, 'hi');\r\n * bound('!');\r\n * // => 'hi fred!'\r\n *\r\n * bound = bind(greet, object, bind.placeholder, '!');\r\n * bound('hi');\r\n * // => 'hi fred!'\r\n */\r\nexport function bind<F extends (...args: any[]) => any>(func: F, thisObj?: unknown, ...partialArgs: any[]): F {\r\n  const bound = function (this: any, ...providedArgs: any[]) {\r\n    const args: any[] = [];\r\n\r\n    // Populate args by merging partialArgs and providedArgs.\r\n    // e.g.. when we call bind(func, {}, [1, bind.placeholder, 3])(2, 4);\r\n    // we have args with [1, 2, 3, 4].\r\n    let startIndex = 0;\r\n\r\n    for (let i = 0; i < partialArgs.length; i++) {\r\n      const arg = partialArgs[i];\r\n\r\n      if (arg === bind.placeholder) {\r\n        args.push(providedArgs[startIndex++]);\r\n      } else {\r\n        args.push(arg);\r\n      }\r\n    }\r\n\r\n    for (let i = startIndex; i < providedArgs.length; i++) {\r\n      args.push(providedArgs[i]);\r\n    }\r\n\r\n    if (this instanceof bound) {\r\n      // @ts-expect-error - fn is a constructor\r\n      return new func(...args);\r\n    }\r\n\r\n    return func.apply(thisObj, args);\r\n  };\r\n\r\n  return bound as any as F;\r\n}\r\n\r\nconst bindPlaceholder: unique symbol = Symbol('bind.placeholder');\r\nbind.placeholder = bindPlaceholder;\r\n","/**\r\n * Creates a function that invokes the method at `object[key]` with `partialArgs` prepended to the arguments it receives.\r\n *\r\n * This method differs from `bind` by allowing bound functions to reference methods that may be redefined or don't yet exist.\r\n *\r\n * The `bindKey.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\r\n *\r\n * @template T - The type of the object to bind.\r\n * @template K - The type of the key to bind.\r\n * @param {T} object - The object to invoke the method on.\r\n * @param {K} key - The key of the method.\r\n * @param {...any} partialArgs - The arguments to be partially applied.\r\n * @returns {T[K] extends (...args: any[]) => any ? (...args: any[]) => ReturnType<T[K]> : never} - Returns the new bound function.\r\n *\r\n * @example\r\n * const object = {\r\n *   user: 'fred',\r\n *   greet: function (greeting, punctuation) {\r\n *     return greeting + ' ' + this.user + punctuation;\r\n *   },\r\n * };\r\n *\r\n * let bound = bindKey(object, 'greet', 'hi');\r\n * bound('!');\r\n * // => 'hi fred!'\r\n *\r\n * object.greet = function (greeting, punctuation) {\r\n *   return greeting + 'ya ' + this.user + punctuation;\r\n * };\r\n *\r\n * bound('!');\r\n * // => 'hiya fred!'\r\n *\r\n * // Bound with placeholders.\r\n * bound = bindKey(object, 'greet', bindKey.placeholder, '!');\r\n * bound('hi');\r\n * // => 'hiya fred!'\r\n */\r\nexport function bindKey<T extends Record<PropertyKey, any>, K extends keyof T>(\r\n  object: T,\r\n  key: K,\r\n  ...partialArgs: any[]\r\n): T[K] extends (...args: any[]) => any ? (...args: any[]) => ReturnType<T[K]> : never {\r\n  const bound = function (this: any, ...providedArgs: any[]) {\r\n    const args: any[] = [];\r\n\r\n    // Populate args by merging partialArgs and providedArgs.\r\n    // e.g.. when we call bind(func, {}, [1, bind.placeholder, 3])(2, 4);\r\n    // we have args with [1, 2, 3, 4].\r\n    let startIndex = 0;\r\n\r\n    for (let i = 0; i < partialArgs.length; i++) {\r\n      const arg = partialArgs[i];\r\n\r\n      if (arg === bindKey.placeholder) {\r\n        args.push(providedArgs[startIndex++]);\r\n      } else {\r\n        args.push(arg);\r\n      }\r\n    }\r\n\r\n    for (let i = startIndex; i < providedArgs.length; i++) {\r\n      args.push(providedArgs[i]);\r\n    }\r\n\r\n    if (this instanceof bound) {\r\n      return new object[key](...args);\r\n    }\r\n\r\n    // eslint-disable-next-line prefer-spread\r\n    return object[key].apply(object, args);\r\n  };\r\n\r\n  return bound as any;\r\n}\r\n\r\nconst bindKeyPlaceholder: unique symbol = Symbol('bindKey.placeholder');\r\nbindKey.placeholder = bindKeyPlaceholder;\r\n","/**\r\n * Creates a function that accepts arguments of `func` and either invokes `func` returning its result, if at least `arity` number of arguments have been provided, or returns a function that accepts the remaining `func` arguments, and so on.\r\n * The arity of `func` may be specified if `func.length` is not sufficient.\r\n *\r\n * The `curry.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\r\n *\r\n * Note: This method doesn't set the `length` property of curried functions.\r\n *\r\n * @param {(...args: any[]) => any} func - The function to curry.\r\n * @param {number=func.length} arity - The arity of func.\r\n * @param {unknown} guard - Enables use as an iteratee for methods like `Array#map`.\r\n * @returns {((...args: any[]) => any) & { placeholder: typeof curry.placeholder }} - Returns the new curried function.\r\n *\r\n * @example\r\n * const abc = function(a, b, c) {\r\n *   return Array.from(arguments);\r\n * };\r\n *\r\n * let curried = curry(abc);\r\n *\r\n * curried(1)(2)(3);\r\n * // => [1, 2, 3]\r\n *\r\n * curried(1, 2)(3);\r\n * // => [1, 2, 3]\r\n *\r\n * curried(1, 2, 3);\r\n * // => [1, 2, 3]\r\n *\r\n * // Curried with placeholders.\r\n * curried(1)(curry.placeholder, 3)(2);\r\n * // => [1, 2, 3]\r\n *\r\n * // Curried with arity.\r\n * curried = curry(abc, 2);\r\n *\r\n * curried(1)(2);\r\n * // => [1, 2]\r\n */\r\nexport function curry(\r\n  func: (...args: any[]) => any,\r\n  arity: number = func.length,\r\n  guard?: unknown\r\n): ((...args: any[]) => any) & { placeholder: typeof curry.placeholder } {\r\n  arity = guard ? func.length : arity;\r\n  arity = Number.parseInt(arity as any, 10);\r\n  if (Number.isNaN(arity) || arity < 1) {\r\n    arity = 0;\r\n  }\r\n\r\n  const wrapper = function (this: any, ...partialArgs: any[]) {\r\n    const holders = partialArgs.filter(item => item === curry.placeholder);\r\n    const length = partialArgs.length - holders.length;\r\n    if (length < arity) {\r\n      return makeCurry(func, arity - length, partialArgs);\r\n    }\r\n    if (this instanceof wrapper) {\r\n      // @ts-expect-error - fn is a constructor\r\n      return new func(...partialArgs);\r\n    }\r\n    return func.apply(this, partialArgs);\r\n  };\r\n\r\n  wrapper.placeholder = curryPlaceholder;\r\n\r\n  return wrapper;\r\n}\r\n\r\nfunction makeCurry(\r\n  func: (...args: any[]) => any,\r\n  arity: number,\r\n  partialArgs: any[]\r\n): ((...args: any[]) => any) & { placeholder: typeof curry.placeholder } {\r\n  function wrapper(this: any, ...providedArgs: any[]) {\r\n    const holders = providedArgs.filter(item => item === curry.placeholder);\r\n    const length = providedArgs.length - holders.length;\r\n    providedArgs = composeArgs(providedArgs, partialArgs);\r\n    if (length < arity) {\r\n      return makeCurry(func, arity - length, providedArgs);\r\n    }\r\n    if (this instanceof wrapper) {\r\n      // @ts-expect-error - fn is a constructor\r\n      return new func(...providedArgs);\r\n    }\r\n    return func.apply(this, providedArgs);\r\n  }\r\n  wrapper.placeholder = curryPlaceholder;\r\n  return wrapper;\r\n}\r\n\r\nfunction composeArgs(providedArgs: any[], partialArgs: any[]): any[] {\r\n  const args = [];\r\n  let startIndex = 0;\r\n  for (let i = 0; i < partialArgs.length; i++) {\r\n    const arg = partialArgs[i];\r\n\r\n    if (arg === curry.placeholder && startIndex < providedArgs.length) {\r\n      args.push(providedArgs[startIndex++]);\r\n    } else {\r\n      args.push(arg);\r\n    }\r\n  }\r\n  for (let i = startIndex; i < providedArgs.length; i++) {\r\n    args.push(providedArgs[i]);\r\n  }\r\n  return args;\r\n}\r\n\r\nconst curryPlaceholder: unique symbol = Symbol('curry.placeholder');\r\ncurry.placeholder = curryPlaceholder;\r\n","import { debounce as debounceToolkit } from '../../function/debounce.ts';\r\n\r\ninterface DebounceOptions {\r\n  /**\r\n   * An optional AbortSignal to cancel the debounced function.\r\n   */\r\n  signal?: AbortSignal;\r\n\r\n  /**\r\n   * If `true`, the function will be invoked on the leading edge of the timeout.\r\n   * @default false\r\n   */\r\n  leading?: boolean;\r\n\r\n  /**\r\n   * If `true`, the function will be invoked on the trailing edge of the timeout.\r\n   * @default true\r\n   */\r\n  trailing?: boolean;\r\n\r\n  /**\r\n   * The maximum time `func` is allowed to be delayed before it's invoked.\r\n   * @default Infinity\r\n   */\r\n  maxWait?: number;\r\n}\r\n\r\n/**\r\n * Creates a debounced function that delays invoking the provided function until after `debounceMs` milliseconds\r\n * have elapsed since the last time the debounced function was invoked. The debounced function also has a `cancel`\r\n * method to cancel any pending execution.\r\n *\r\n * You can set the debounced function to run at the start (`leading`) or end (`trailing`) of the delay period.\r\n * If `leading` is true, the function runs immediately on the first call.\r\n * If `trailing` is true, the function runs after `debounceMs` milliseconds have passed since the last call.\r\n * If both `leading` and `trailing` are true, the function runs at both the start and end, but it must be called at least twice within `debounceMs` milliseconds for this to happen\r\n * (since one debounced function call cannot trigger the function twice).\r\n *\r\n * You can also set a `maxWait` time, which is the maximum time the function is allowed to be delayed before it is called.\r\n *\r\n * @template F - The type of function.\r\n * @param {F} func - The function to debounce.\r\n * @param {number} debounceMs - The number of milliseconds to delay.\r\n * @param {DebounceOptions} options - The options object\r\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the debounced function.\r\n * @param {boolean} options.leading - If `true`, the function will be invoked on the leading edge of the timeout.\r\n * @param {boolean} options.trailing - If `true`, the function will be invoked on the trailing edge of the timeout.\r\n * @param {number} options.maxWait - The maximum time `func` is allowed to be delayed before it's invoked.\r\n * @returns A new debounced function with a `cancel` method.\r\n *\r\n * @example\r\n * const debouncedFunction = debounce(() => {\r\n *   console.log('Function executed');\r\n * }, 1000);\r\n *\r\n * // Will log 'Function executed' after 1 second if not called again in that time\r\n * debouncedFunction();\r\n *\r\n * // Will not log anything as the previous call is canceled\r\n * debouncedFunction.cancel();\r\n *\r\n * // With AbortSignal\r\n * const controller = new AbortController();\r\n * const signal = controller.signal;\r\n * const debouncedWithSignal = debounce(() => {\r\n *  console.log('Function executed');\r\n * }, 1000, { signal });\r\n *\r\n * debouncedWithSignal();\r\n *\r\n * // Will cancel the debounced function call\r\n * controller.abort();\r\n */\r\nexport function debounce<F extends (...args: any[]) => any>(\r\n  func: F,\r\n  debounceMs: number = 0,\r\n  options: DebounceOptions = {}\r\n): ((...args: Parameters<F>) => ReturnType<F> | undefined) & {\r\n  cancel: () => void;\r\n  flush: () => void;\r\n} {\r\n  if (typeof options !== 'object') {\r\n    options = {};\r\n  }\r\n\r\n  const { signal, leading = false, trailing = true, maxWait } = options;\r\n\r\n  const edges = Array(2);\r\n\r\n  if (leading) {\r\n    edges[0] = 'leading';\r\n  }\r\n\r\n  if (trailing) {\r\n    edges[1] = 'trailing';\r\n  }\r\n\r\n  let result: ReturnType<F> | undefined = undefined;\r\n  let pendingAt: number | null = null;\r\n\r\n  const _debounced = debounceToolkit(\r\n    function (this: any, ...args: Parameters<F>) {\r\n      result = func.apply(this, args);\r\n      pendingAt = null;\r\n    },\r\n    debounceMs,\r\n    { signal, edges }\r\n  );\r\n\r\n  const debounced = function (this: any, ...args: Parameters<F>) {\r\n    if (maxWait != null) {\r\n      if (pendingAt === null) {\r\n        pendingAt = Date.now();\r\n      } else {\r\n        if (Date.now() - pendingAt >= maxWait) {\r\n          result = func.apply(this, args);\r\n          pendingAt = Date.now();\r\n\r\n          _debounced.cancel();\r\n          _debounced.schedule();\r\n\r\n          return result;\r\n        }\r\n      }\r\n    }\r\n\r\n    _debounced.apply(this, args);\r\n    return result;\r\n  };\r\n\r\n  const flush = () => {\r\n    _debounced.flush();\r\n    return result;\r\n  };\r\n\r\n  debounced.cancel = _debounced.cancel;\r\n  debounced.flush = flush;\r\n\r\n  return debounced;\r\n}\r\n","/**\r\n * Checks if a given value is null or undefined.\r\n *\r\n * This function tests whether the provided value is either `null` or `undefined`.\r\n * It returns `true` if the value is `null` or `undefined`, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null` or `undefined`.\r\n *\r\n * @param {unknown} x - The value to test for null or undefined.\r\n * @returns {boolean} `true` if the value is null or undefined, `false` otherwise.\r\n *\r\n * @example\r\n * const value1 = null;\r\n * const value2 = undefined;\r\n * const value3 = 42;\r\n * const result1 = isNil(value1); // true\r\n * const result2 = isNil(value2); // true\r\n * const result3 = isNil(value3); // false\r\n */\r\nexport function isNil(x?: unknown): x is null | undefined {\r\n  return x == null;\r\n}\r\n","import { isDeepKey } from '../_internal/isDeepKey.ts';\r\nimport { toKey } from '../_internal/toKey.ts';\r\nimport { toPath } from '../util/toPath.ts';\r\nimport { get } from './get.ts';\r\n\r\n/**\r\n * Removes the property at the given path of the object.\r\n *\r\n * @param {unknown} obj - The object to modify.\r\n * @param {PropertyKey | readonly PropertyKey[]} path - The path of the property to unset.\r\n * @returns {boolean} - Returns true if the property is deleted, else false.\r\n *\r\n * @example\r\n * const obj = { a: { b: { c: 42 } } };\r\n * unset(obj, 'a.b.c'); // true\r\n * console.log(obj); // { a: { b: {} } }\r\n *\r\n * @example\r\n * const obj = { a: { b: { c: 42 } } };\r\n * unset(obj, ['a', 'b', 'c']); // true\r\n * console.log(obj); // { a: { b: {} } }\r\n */\r\nexport function unset(obj: any, path: PropertyKey | readonly PropertyKey[]): boolean {\r\n  if (obj == null) {\r\n    return true;\r\n  }\r\n\r\n  switch (typeof path) {\r\n    case 'symbol':\r\n    case 'number':\r\n    case 'object': {\r\n      if (Array.isArray(path)) {\r\n        return unsetWithPath(obj, path);\r\n      }\r\n\r\n      if (typeof path === 'number') {\r\n        path = toKey(path);\r\n      } else if (typeof path === 'object') {\r\n        if (Object.is(path?.valueOf(), -0)) {\r\n          path = '-0';\r\n        } else {\r\n          path = String(path);\r\n        }\r\n      }\r\n\r\n      if (obj?.[path] === undefined) {\r\n        return true;\r\n      }\r\n\r\n      try {\r\n        delete obj[path];\r\n        return true;\r\n      } catch {\r\n        return false;\r\n      }\r\n    }\r\n    case 'string': {\r\n      if (obj?.[path] === undefined && isDeepKey(path)) {\r\n        return unsetWithPath(obj, toPath(path));\r\n      }\r\n\r\n      try {\r\n        delete obj[path];\r\n        return true;\r\n      } catch {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction unsetWithPath(obj: unknown, path: readonly PropertyKey[]): boolean {\r\n  const parent = get(obj, path.slice(0, -1), obj);\r\n  const lastKey = path[path.length - 1];\r\n\r\n  if (parent?.[lastKey] === undefined) {\r\n    return true;\r\n  }\r\n\r\n  try {\r\n    delete parent[lastKey];\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n","/**\r\n * Checks if a given value is a plain object.\r\n *\r\n * A plain object is an object created by the `{}` literal, `new Object()`, or\r\n * `Object.create(null)`.\r\n *\r\n * This function also handles objects with custom\r\n * `Symbol.toStringTag` properties.\r\n *\r\n * `Symbol.toStringTag` is a built-in symbol that a constructor can use to customize the\r\n * default string description of objects.\r\n *\r\n * @param {unknown} [object] - The value to check.\r\n * @returns {boolean} - True if the value is a plain object, otherwise false.\r\n *\r\n * @example\r\n * console.log(isPlainObject({})); // true\r\n * console.log(isPlainObject([])); // false\r\n * console.log(isPlainObject(null)); // false\r\n * console.log(isPlainObject(Object.create(null))); // true\r\n * console.log(isPlainObject(new Map())); // false\r\n */\r\nexport function isPlainObject(object?: unknown): boolean {\r\n  if (typeof object !== 'object') {\r\n    return false;\r\n  }\r\n\r\n  if (object == null) {\r\n    return false;\r\n  }\r\n\r\n  if (Object.getPrototypeOf(object) === null) {\r\n    return true;\r\n  }\r\n\r\n  if (Object.prototype.toString.call(object) !== '[object Object]') {\r\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n    // @ts-ignore\r\n    const tag = object[Symbol.toStringTag];\r\n\r\n    if (tag == null) {\r\n      return false;\r\n    }\r\n\r\n    const isTagReadonly = !Object.getOwnPropertyDescriptor(object, Symbol.toStringTag)?.writable;\r\n\r\n    if (isTagReadonly) {\r\n      return false;\r\n    }\r\n\r\n    return object.toString() === `[object ${tag}]`;\r\n  }\r\n\r\n  let proto = object;\r\n\r\n  while (Object.getPrototypeOf(proto) !== null) {\r\n    proto = Object.getPrototypeOf(proto);\r\n  }\r\n\r\n  return Object.getPrototypeOf(object) === proto;\r\n}\r\n","import { isTypedArray as isTypedArrayToolkit } from '../../predicate/isTypedArray.ts';\r\n\r\n/**\r\n * Checks if a value is a TypedArray.\r\n * @param {unknown} x The value to check.\r\n * @returns {x is\r\n *     Uint8Array\r\n *   | Uint8ClampedArray\r\n *   | Uint16Array\r\n *   | Uint32Array\r\n *   | BigUint64Array\r\n *   | Int8Array\r\n *   | Int16Array\r\n *   | Int32Array\r\n *   | BigInt64Array\r\n *   | Float32Array\r\n *   | Float64Array} Returns true if `x` is a TypedArray, false otherwise.\r\n *\r\n * @example\r\n * const arr = new Uint8Array([1, 2, 3]);\r\n * isTypedArray(arr); // true\r\n *\r\n * const regularArray = [1, 2, 3];\r\n * isTypedArray(regularArray); // false\r\n *\r\n * const buffer = new ArrayBuffer(16);\r\n * isTypedArray(buffer); // false\r\n */\r\nexport function isTypedArray(\r\n  x?: unknown\r\n): x is\r\n  | Uint8Array\r\n  | Uint8ClampedArray\r\n  | Uint16Array\r\n  | Uint32Array\r\n  | BigUint64Array\r\n  | Int8Array\r\n  | Int16Array\r\n  | Int32Array\r\n  | BigInt64Array\r\n  | Float32Array\r\n  | Float64Array {\r\n  return isTypedArrayToolkit(x);\r\n}\r\n","import { clone } from '../../object/clone.ts';\r\nimport { getSymbols } from '../_internal/getSymbols.ts';\r\nimport { isArguments } from '../predicate/isArguments.ts';\r\nimport { isObjectLike } from '../predicate/isObjectLike.ts';\r\nimport { isPlainObject } from '../predicate/isPlainObject.ts';\r\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\r\nimport { cloneDeep } from './cloneDeep.ts';\r\n\r\ndeclare let Buffer:\r\n  | {\r\n      isBuffer: (a: any) => boolean;\r\n    }\r\n  | undefined;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\r\n *\r\n * - `targetValue`: The current value of the property in the target object.\r\n * - `sourceValue`: The value of the property in the source object.\r\n * - `key`: The key of the property being merged.\r\n * - `target`: The target object.\r\n * - `source`: The source object.\r\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\r\n *\r\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {T} target - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S} source - The first source object whose properties will be merged into the target object.\r\n * @param {(targetValue: any, sourceValue: any, key: string, target: T, source: S, stack: Map<any, any>) => any} merge - The function to customize merging properties.\r\n * @returns {T & S} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @template T - Type of the target object.\r\n * @template S - Type of the first source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: 2 };\r\n * const source = { b: 3, c: 4 };\r\n *\r\n * mergeWith(target, source, (targetValue, sourceValue) => {\r\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\r\n *     return targetValue + sourceValue;\r\n *   }\r\n * });\r\n * // Returns { a: 1, b: 5, c: 4 }\r\n * @example\r\n * const target = { a: [1], b: [2] };\r\n * const source = { a: [3], b: [4] };\r\n *\r\n * const result = mergeWith(target, source, (objValue, srcValue) => {\r\n *   if (Array.isArray(objValue)) {\r\n *     return objValue.concat(srcValue);\r\n *   }\r\n * });\r\n *\r\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\r\n */\r\nexport function mergeWith<T, S>(\r\n  target: T,\r\n  source: S,\r\n  merge: (targetValue: any, sourceValue: any, key: string, target: T, source: S, stack: Map<any, any>) => any\r\n): T & S;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\r\n *\r\n * - `targetValue`: The current value of the property in the target object.\r\n * - `sourceValue`: The value of the property in the source object.\r\n * - `key`: The key of the property being merged.\r\n * - `target`: The target object.\r\n * - `source`: The source object.\r\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\r\n *\r\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S1} source1 - The first source object to be merged into the target object.\r\n * @param {S2} source2 - The second source object to be merged into the target object.\r\n * @param {(targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any} merge - The function to customize merging properties.\r\n * @returns {O & S1 & S2} The updated target object with properties from the source objects merged in.\r\n *\r\n * @template O - Type of the target object.\r\n * @template S1 - Type of the first source object.\r\n * @template S2 - Type of the second source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: 2 };\r\n * const source = { b: 3, c: 4 };\r\n *\r\n * mergeWith(target, source, (targetValue, sourceValue) => {\r\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\r\n *     return targetValue + sourceValue;\r\n *   }\r\n * });\r\n * // Returns { a: 1, b: 5, c: 4 }\r\n * @example\r\n * const target = { a: [1], b: [2] };\r\n * const source = { a: [3], b: [4] };\r\n *\r\n * const result = mergeWith(target, source, (objValue, srcValue) => {\r\n *   if (Array.isArray(objValue)) {\r\n *     return objValue.concat(srcValue);\r\n *   }\r\n * });\r\n *\r\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\r\n */\r\nexport function mergeWith<O, S1, S2>(\r\n  object: O,\r\n  source1: S1,\r\n  source2: S2,\r\n  merge: (targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any\r\n): O & S1 & S2;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\r\n *\r\n * - `targetValue`: The current value of the property in the target object.\r\n * - `sourceValue`: The value of the property in the source object.\r\n * - `key`: The key of the property being merged.\r\n * - `target`: The target object.\r\n * - `source`: The source object.\r\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\r\n *\r\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S1} source1 - The first source object whose properties will be merged into the target object.\r\n * @param {S2} source2 - The second source object whose properties will be merged into the target object.\r\n * @param {S3} source3 - The third source object whose properties will be merged into the target object.\r\n * @param {(targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any} merge - The function to customize merging properties.\r\n * @returns {O & S1 & S2 & S3} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @template O - Type of the target object.\r\n * @template S1 - Type of the first source object.\r\n * @template S2 - Type of the second source object.\r\n * @template S3 - Type of the third source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: 2 };\r\n * const source = { b: 3, c: 4 };\r\n *\r\n * mergeWith(target, source, (targetValue, sourceValue) => {\r\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\r\n *     return targetValue + sourceValue;\r\n *   }\r\n * });\r\n * // Returns { a: 1, b: 5, c: 4 }\r\n * @example\r\n * const target = { a: [1], b: [2] };\r\n * const source = { a: [3], b: [4] };\r\n *\r\n * const result = mergeWith(target, source, (objValue, srcValue) => {\r\n *   if (Array.isArray(objValue)) {\r\n *     return objValue.concat(srcValue);\r\n *   }\r\n * });\r\n *\r\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\r\n */\r\nexport function mergeWith<O, S1, S2, S3>(\r\n  object: O,\r\n  source1: S1,\r\n  source2: S2,\r\n  source3: S3,\r\n  merge: (targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any\r\n): O & S1 & S2 & S3;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\r\n *\r\n * - `targetValue`: The current value of the property in the target object.\r\n * - `sourceValue`: The value of the property in the source object.\r\n * - `key`: The key of the property being merged.\r\n * - `target`: The target object.\r\n * - `source`: The source object.\r\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\r\n *\r\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S1} source1 - The first source object whose properties will be merged into the target object.\r\n * @param {S2} source2 - The second source object whose properties will be merged into the target object.\r\n * @param {S3} source3 - The third source object whose properties will be merged into the target object.\r\n * @param {S4} source4 - The fourth source object whose properties will be merged into the target object.\r\n * @param {(targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any} merge - The function to customize merging properties.\r\n * @returns {O & S1 & S2 & S3 & S4} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @template O - Type of the target object.\r\n * @template S1 - Type of the first source object.\r\n * @template S2 - Type of the second source object.\r\n * @template S3 - Type of the third source object.\r\n * @template S4 - Type of the fourth source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: 2 };\r\n * const source = { b: 3, c: 4 };\r\n *\r\n * mergeWith(target, source, (targetValue, sourceValue) => {\r\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\r\n *     return targetValue + sourceValue;\r\n *   }\r\n * });\r\n * // Returns { a: 1, b: 5, c: 4 }\r\n * @example\r\n * const target = { a: [1], b: [2] };\r\n * const source = { a: [3], b: [4] };\r\n *\r\n * const result = mergeWith(target, source, (objValue, srcValue) => {\r\n *   if (Array.isArray(objValue)) {\r\n *     return objValue.concat(srcValue);\r\n *   }\r\n * });\r\n *\r\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\r\n */\r\nexport function mergeWith<O, S1, S2, S3, S4>(\r\n  object: O,\r\n  source1: S1,\r\n  source2: S2,\r\n  source3: S3,\r\n  source4: S4,\r\n  merge: (targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any\r\n): O & S1 & S2 & S3;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\r\n *\r\n * - `targetValue`: The current value of the property in the target object.\r\n * - `sourceValue`: The value of the property in the source object.\r\n * - `key`: The key of the property being merged.\r\n * - `target`: The target object.\r\n * - `source`: The source object.\r\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\r\n *\r\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {any} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {any[]} sources - The source objects whose properties will be merged into the target object.\r\n * @param {...any} otherArgs - Additional source objects to merge into the target object, including the custom `merge` function.\r\n * @returns {any} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @example\r\n * const target = { a: 1, b: 2 };\r\n * const source = { b: 3, c: 4 };\r\n *\r\n * mergeWith(target, source, (targetValue, sourceValue) => {\r\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\r\n *     return targetValue + sourceValue;\r\n *   }\r\n * });\r\n * // Returns { a: 1, b: 5, c: 4 }\r\n * @example\r\n * const target = { a: [1], b: [2] };\r\n * const source = { a: [3], b: [4] };\r\n *\r\n * const result = mergeWith(target, source, (objValue, srcValue) => {\r\n *   if (Array.isArray(objValue)) {\r\n *     return objValue.concat(srcValue);\r\n *   }\r\n * });\r\n *\r\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\r\n */\r\nexport function mergeWith(object: any, ...otherArgs: any[]): any;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\r\n *\r\n * - `targetValue`: The current value of the property in the target object.\r\n * - `sourceValue`: The value of the property in the source object.\r\n * - `key`: The key of the property being merged.\r\n * - `target`: The target object.\r\n * - `source`: The source object.\r\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\r\n *\r\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {any} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {any[]} sources - The source objects whose properties will be merged into the target object.\r\n * @param {...any} otherArgs - Additional source objects to merge into the target object, including the custom `merge` function.\r\n * @returns {any} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @example\r\n * const target = { a: 1, b: 2 };\r\n * const source = { b: 3, c: 4 };\r\n *\r\n * mergeWith(target, source, (targetValue, sourceValue) => {\r\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\r\n *     return targetValue + sourceValue;\r\n *   }\r\n * });\r\n * // Returns { a: 1, b: 5, c: 4 }\r\n * @example\r\n * const target = { a: [1], b: [2] };\r\n * const source = { a: [3], b: [4] };\r\n *\r\n * const result = mergeWith(target, source, (objValue, srcValue) => {\r\n *   if (Array.isArray(objValue)) {\r\n *     return objValue.concat(srcValue);\r\n *   }\r\n * });\r\n *\r\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\r\n */\r\nexport function mergeWith(object: any, ...otherArgs: any[]): any {\r\n  const sources = otherArgs.slice(0, -1);\r\n  const merge = otherArgs[otherArgs.length - 1] as (\r\n    targetValue: any,\r\n    sourceValue: any,\r\n    key: string | symbol,\r\n    target: any,\r\n    source: any,\r\n    stack: Map<any, any>\r\n  ) => any;\r\n\r\n  let result = object;\r\n\r\n  for (let i = 0; i < sources.length; i++) {\r\n    const source = sources[i];\r\n\r\n    result = mergeWithDeep(object, source, merge, new Map());\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction mergeWithDeep(\r\n  target: any,\r\n  source: any,\r\n  merge: (\r\n    targetValue: any,\r\n    sourceValue: any,\r\n    key: string | symbol,\r\n    target: any,\r\n    source: any,\r\n    stack: Map<any, any>\r\n  ) => any,\r\n  stack: Map<any, any>\r\n) {\r\n  if (source == null || typeof source !== 'object') {\r\n    return target;\r\n  }\r\n\r\n  if (stack.has(source)) {\r\n    return clone(stack.get(source));\r\n  }\r\n\r\n  stack.set(source, target);\r\n\r\n  if (Array.isArray(source)) {\r\n    source = source.slice();\r\n    for (let i = 0; i < source.length; i++) {\r\n      source[i] = source[i] ?? undefined;\r\n    }\r\n  }\r\n\r\n  const sourceKeys = [...Object.keys(source), ...getSymbols(source)];\r\n\r\n  for (let i = 0; i < sourceKeys.length; i++) {\r\n    const key = sourceKeys[i];\r\n\r\n    let sourceValue = source[key];\r\n    let targetValue = target[key];\r\n\r\n    if (isArguments(sourceValue)) {\r\n      sourceValue = { ...sourceValue };\r\n    }\r\n\r\n    if (isArguments(targetValue)) {\r\n      targetValue = { ...targetValue };\r\n    }\r\n\r\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(sourceValue)) {\r\n      sourceValue = cloneDeep(sourceValue);\r\n    }\r\n\r\n    if (Array.isArray(sourceValue)) {\r\n      if (typeof targetValue === 'object') {\r\n        const cloned: any = [];\r\n        const targetKeys = Reflect.ownKeys(targetValue);\r\n\r\n        for (let i = 0; i < targetKeys.length; i++) {\r\n          const targetKey = targetKeys[i];\r\n          cloned[targetKey] = targetValue[targetKey];\r\n        }\r\n\r\n        targetValue = cloned;\r\n      } else {\r\n        targetValue = [];\r\n      }\r\n    }\r\n\r\n    const merged = merge(targetValue, sourceValue, key, target, source, stack);\r\n\r\n    if (merged != null) {\r\n      target[key] = merged;\r\n    } else if (Array.isArray(sourceValue)) {\r\n      target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\r\n    } else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {\r\n      target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\r\n    } else if (targetValue == null && isPlainObject(sourceValue)) {\r\n      target[key] = mergeWithDeep({}, sourceValue, merge, stack);\r\n    } else if (targetValue == null && isTypedArray(sourceValue)) {\r\n      target[key] = cloneDeep(sourceValue);\r\n    } else if (targetValue === undefined || sourceValue !== undefined) {\r\n      target[key] = sourceValue;\r\n    }\r\n  }\r\n\r\n  return target;\r\n}\r\n","import { isLength } from '../../predicate/isLength.ts';\r\n\r\n/**\r\n * Checks if `value` is array-like.\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {value is ArrayLike<unknown>} Returns `true` if `value` is array-like, else `false`.\r\n *\r\n * @example\r\n * isArrayLike([1, 2, 3]); // true\r\n * isArrayLike('abc'); // true\r\n * isArrayLike({ 0: 'a', length: 1 }); // true\r\n * isArrayLike({}); // false\r\n * isArrayLike(null); // false\r\n * isArrayLike(undefined); // false\r\n */\r\nexport function isArrayLike(value: unknown): value is ArrayLike<unknown> {\r\n  return value != null && typeof value !== 'function' && isLength((value as ArrayLike<unknown>).length);\r\n}\r\n","/**\r\n * Checks if `object` conforms to `source` by invoking the predicate properties of `source` with the corresponding property values of `object`.\r\n *\r\n * Note: This method is equivalent to `conforms` when source is partially applied.\r\n *\r\n * @param {Record<PropertyKey, any>} target The object to inspect.\r\n * @param {Record<PropertyKey, (value: any) => boolean>} source The object of property predicates to conform to.\r\n * @returns {boolean} Returns `true` if `object` conforms, else `false`.\r\n *\r\n * @example\r\n *\r\n * const object = { 'a': 1, 'b': 2 };\r\n * const source = {\r\n *   'a': (n) => n > 0,\r\n *   'b': (n) => n > 1\r\n * };\r\n *\r\n * console.log(conformsTo(object, source)); // => true\r\n *\r\n * const source2 = {\r\n *   'a': (n) => n > 1,\r\n *   'b': (n) => n > 1\r\n * };\r\n *\r\n * console.log(conformsTo(object, source2)); // => false\r\n */\r\nexport function conformsTo(\r\n  target: Record<PropertyKey, any>,\r\n  source: Record<PropertyKey, (value: any) => boolean>\r\n): boolean {\r\n  if (source == null) {\r\n    return true;\r\n  }\r\n\r\n  if (target == null) {\r\n    return Object.keys(source).length === 0;\r\n  }\r\n\r\n  const keys = Object.keys(source);\r\n  for (let i = 0; i < keys.length; i++) {\r\n    const key = keys[i];\r\n    const predicate = source[key];\r\n    const value = target[key];\r\n    if ((value === undefined && !(key in target)) || !predicate(value)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n","/**\r\n * Converts `value` to a string.\r\n *\r\n * An empty string is returned for `null` and `undefined` values.\r\n * The sign of `-0` is preserved.\r\n *\r\n * @param {unknown} value - The value to convert.\r\n * @returns {string} Returns the converted string.\r\n *\r\n * @example\r\n * toString(null) // returns ''\r\n * toString(undefined) // returns ''\r\n * toString(-0) // returns '-0'\r\n * toString([1, 2, -0]) // returns '1,2,-0'\r\n * toString([Symbol('a'), Symbol('b')]) // returns 'Symbol(a),Symbol(b)'\r\n */\r\nexport function toString(value?: unknown): string {\r\n  if (value == null) {\r\n    return '';\r\n  }\r\n\r\n  if (Array.isArray(value)) {\r\n    return value.map(toString).join(',');\r\n  }\r\n\r\n  const result = String(value);\r\n\r\n  if (result === '0' && Object.is(Number(value), -0)) {\r\n    return '-0';\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { toString } from '../util/toString.ts';\r\n\r\nexport function normalizeForCase(str: unknown): string {\r\n  // Coerce to string\r\n  if (typeof str !== 'string') {\r\n    str = toString(str);\r\n  }\r\n\r\n  // Remove contraction apostrophes\r\n  return (str as string).replace(/['\\u2019]/g, '');\r\n}\r\n","import { clamp as clampToolkit } from '../../math/clamp.ts';\r\n\r\n/**\r\n * Clamps a number within the inclusive upper bound.\r\n *\r\n * This function takes a number and a maximum bound, and returns the number clamped within the specified upper bound.\r\n * If only one bound is provided, it returns the minimum of the value and the bound.\r\n *\r\n * @param {number} value - The number to clamp.\r\n * @param {number} maximum - The maximum bound to clamp the number.\r\n * @returns {number} The clamped number within the specified upper bound.\r\n *\r\n * @example\r\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\r\n */\r\nexport function clamp(value: number, maximum: number): number;\r\n\r\n/**\r\n * Clamps a number within the inclusive lower and upper bounds.\r\n *\r\n * This function takes a number and two bounds, and returns the number clamped within the specified bounds.\r\n *\r\n * @param {number} value - The number to clamp.\r\n * @param {number} minimum - The minimum bound to clamp the number.\r\n * @param {number} maximum - The maximum bound to clamp the number.\r\n * @returns {number} The clamped number within the specified bounds.\r\n *\r\n * @example\r\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\r\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\r\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\r\n */\r\nexport function clamp(value: number, minimum: number, maximum: number): number;\r\n\r\n/**\r\n * Clamps a number within the specified bounds.\r\n *\r\n * This function takes a number and one or two bounds, and returns the number clamped within the specified bounds.\r\n * If only one bound is provided, it returns the minimum of the value and the bound.\r\n *\r\n * @param {number} value - The number to clamp.\r\n * @param {number} bound1 - The minimum bound to clamp the number, or the maximum bound if bound2 is not provided.\r\n * @param {number} [bound2] - The maximum bound to clamp the number. If not provided, the function will only consider bound1 as the upper limit.\r\n * @returns {number} The clamped number within the specified bounds.\r\n *\r\n * @example\r\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\r\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\r\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\r\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\r\n */\r\nexport function clamp(value: number, bound1: number, bound2?: number): number {\r\n  if (Number.isNaN(bound1)) {\r\n    bound1 = 0;\r\n  }\r\n\r\n  if (Number.isNaN(bound2)) {\r\n    bound2 = 0;\r\n  }\r\n\r\n  return clampToolkit(value, bound1, bound2!);\r\n}\r\n","/**\r\n * Clamps a number within the inclusive upper bound.\r\n *\r\n * This function takes a number and a maximum bound, and returns the number clamped within the specified upper bound.\r\n * If only one bound is provided, it returns the minimum of the value and the bound.\r\n *\r\n * @param {number} value - The number to clamp.\r\n * @param {number} maximum - The maximum bound to clamp the number.\r\n * @returns {number} The clamped number within the specified upper bound.\r\n *\r\n * @example\r\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\r\n */\r\nexport function clamp(value: number, maximum: number): number;\r\n\r\n/**\r\n * Clamps a number within the inclusive lower and upper bounds.\r\n *\r\n * This function takes a number and two bounds, and returns the number clamped within the specified bounds.\r\n *\r\n * @param {number} value - The number to clamp.\r\n * @param {number} minimum - The minimum bound to clamp the number.\r\n * @param {number} maximum - The maximum bound to clamp the number.\r\n * @returns {number} The clamped number within the specified bounds.\r\n *\r\n * @example\r\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\r\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\r\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\r\n */\r\nexport function clamp(value: number, minimum: number, maximum: number): number;\r\n\r\n/**\r\n * Clamps a number within the specified bounds.\r\n *\r\n * This function takes a number and one or two bounds, and returns the number clamped within the specified bounds.\r\n * If only one bound is provided, it returns the minimum of the value and the bound.\r\n *\r\n * @param {number} value - The number to clamp.\r\n * @param {number} bound1 - The minimum bound to clamp the number, or the maximum bound if bound2 is not provided.\r\n * @param {number} [bound2] - The maximum bound to clamp the number. If not provided, the function will only consider bound1 as the upper limit.\r\n * @returns {number} The clamped number within the specified bounds.\r\n *\r\n * @example\r\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\r\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\r\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\r\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\r\n */\r\nexport function clamp(value: number, bound1: number, bound2?: number): number {\r\n  if (bound2 == null) {\r\n    return Math.min(value, bound1);\r\n  }\r\n\r\n  return Math.min(Math.max(value, bound1), bound2);\r\n}\r\n","export function decimalAdjust(\r\n  type: 'round' | 'floor' | 'ceil',\r\n  number: number | string,\r\n  precision: number | string = 0\r\n): number {\r\n  number = Number(number);\r\n  if (Object.is(number, -0)) {\r\n    number = '-0';\r\n  }\r\n  precision = Math.min(Number.parseInt(precision as string, 10), 292);\r\n  if (precision) {\r\n    const [magnitude, exponent = 0] = number.toString().split('e');\r\n    let adjustedValue: string | number = Math[type](Number(`${magnitude}e${Number(exponent) + precision}`));\r\n    if (Object.is(adjustedValue, -0)) {\r\n      adjustedValue = '-0';\r\n    }\r\n    const [newMagnitude, newExponent = 0] = adjustedValue.toString().split('e');\r\n    return Number(`${newMagnitude}e${Number(newExponent) - precision}`);\r\n  }\r\n  return Math[type](Number(number));\r\n}\r\n","import { isSymbol } from '../predicate/isSymbol';\r\n\r\n/**\r\n * Converts `value` to a number.\r\n *\r\n * Unlike `Number()`, this function returns `NaN` for symbols.\r\n *\r\n * @param {unknown} value - The value to convert.\r\n * @returns {number} Returns the number.\r\n *\r\n * @example\r\n * toNumber(3.2); // => 3.2\r\n * toNumber(Number.MIN_VALUE); // => 5e-324\r\n * toNumber(Infinity); // => Infinity\r\n * toNumber('3.2'); // => 3.2\r\n * toNumber(Symbol.iterator); // => NaN\r\n * toNumber(NaN); // => NaN\r\n */\r\nexport function toNumber(value?: unknown): number {\r\n  if (isSymbol(value)) {\r\n    return NaN;\r\n  }\r\n\r\n  return Number(value);\r\n}\r\n","import { toNumber } from './toNumber';\r\n\r\n/**\r\n * Converts `value` to a finite number.\r\n *\r\n * @param {unknown} value - The value to convert.\r\n * @returns {number} Returns the number.\r\n *\r\n * @example\r\n * toNumber(3.2); // => 3.2\r\n * toNumber(Number.MIN_VALUE); // => 5e-324\r\n * toNumber(Infinity); // => 1.7976931348623157e+308\r\n * toNumber('3.2'); // => 3.2\r\n * toNumber(Symbol.iterator); // => 0\r\n * toNumber(NaN); // => 0\r\n */\r\nexport function toFinite(value?: unknown): number {\r\n  if (!value) {\r\n    return value === 0 ? value : 0;\r\n  }\r\n\r\n  value = toNumber(value);\r\n\r\n  if (value === Infinity || value === -Infinity) {\r\n    const sign = value < 0 ? -1 : 1;\r\n    return sign * Number.MAX_VALUE;\r\n  }\r\n\r\n  return value === value ? (value as number) : 0;\r\n}\r\n","/**\r\n * Creates a function that only executes starting from the `n`-th call.\r\n * The provided function will be invoked starting from the `n`-th call.\r\n *\r\n * This is particularly useful for scenarios involving events or asynchronous operations\r\n * where an action should occur only after a certain number of invocations.\r\n *\r\n * @template F - The type of the function to be invoked.\r\n * @param {number} n - The number of calls required for `func` to execute.\r\n * @param {F} func - The function to be invoked.\r\n * @returns {F} - A new function that:\r\n * - Tracks the number of calls.\r\n * - Invokes `func` starting from the `n`-th call.\r\n * - Returns `undefined` if fewer than `n` calls have been made.\r\n * @throws {Error} - Throws an error if `n` is negative.\r\n * @example\r\n *\r\n * const afterFn = after(3, () => {\r\n *  console.log(\"called\")\r\n * });\r\n *\r\n * // Will not log anything.\r\n * afterFn()\r\n * // Will not log anything.\r\n * afterFn()\r\n * // Will log 'called'.\r\n * afterFn()\r\n */\r\n\r\nexport function after<F extends (...args: any[]) => any>(n: number, func: F): F {\r\n  if (!Number.isInteger(n) || n < 0) {\r\n    throw new Error(`n must be a non-negative integer.`);\r\n  }\r\n\r\n  let counter = 0;\r\n  return ((...args: Parameters<F>) => {\r\n    if (++counter >= n) {\r\n      return func(...args);\r\n    }\r\n    return undefined;\r\n  }) as F;\r\n}\r\n","import { ary as aryToolkit } from '../../function/ary.ts';\r\n\r\n/**\r\n * Creates a function that invokes func, with up to `n` arguments, ignoring any additional arguments.\r\n *\r\n * @template F - The type of the function.\r\n * @param {F} func - The function to cap arguments for.\r\n * @param {number} n - The arity cap.\r\n * @param {unknown} guard - The value to guard the arity cap.\r\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new capped function.\r\n *\r\n * @example\r\n * function fn(a: number, b: number, c: number) {\r\n *   return Array.from(arguments);\r\n * }\r\n *\r\n * ary(fn, 0)(1, 2, 3); // []\r\n * ary(fn, 1)(1, 2, 3); // [1]\r\n * ary(fn, 2)(1, 2, 3); // [1, 2]\r\n * ary(fn, 3)(1, 2, 3); // [1, 2, 3]\r\n */\r\nexport function ary<F extends (...args: any[]) => any>(\r\n  func: F,\r\n  n: number = func.length,\r\n  guard?: unknown\r\n): (...args: any[]) => ReturnType<F> {\r\n  if (guard) {\r\n    n = func.length;\r\n  }\r\n\r\n  if (Number.isNaN(n) || n < 0) {\r\n    n = 0;\r\n  }\r\n\r\n  return aryToolkit(func, n);\r\n}\r\n","/**\r\n * Attempts to execute a function with the provided arguments.\r\n * If the function throws an error, it catches the error and returns it.\r\n * If the caught error is not an instance of Error, it wraps it in a new Error.\r\n *\r\n * @param {F} func - The function to be executed.\r\n * @param {...Parameters<F>} args - The arguments to pass to the function.\r\n * @returns {ReturnType<F> | Error} The return value of the function if successful, or an Error if an exception is thrown.\r\n *\r\n * @template F - The type of the function being attempted.\r\n *\r\n * @example\r\n * // Example 1: Successful execution\r\n * const result = attempt((x, y) => x + y, 2, 3);\r\n * console.log(result); // Output: 5\r\n *\r\n * @example\r\n * // Example 2: Function throws an error\r\n * const errorResult = attempt(() => {\r\n *   throw new Error(\"Something went wrong\");\r\n * });\r\n * console.log(errorResult); // Output: Error: Something went wrong\r\n *\r\n * @example\r\n * // Example 3: Non-Error thrown\r\n * const nonErrorResult = attempt(() => {\r\n *   throw \"This is a string error\";\r\n * });\r\n * console.log(nonErrorResult); // Output: Error: This is a string error\r\n */\r\nexport function attempt<F extends (...args: any[]) => any>(func: F, ...args: Parameters<F>): ReturnType<F> | Error {\r\n  try {\r\n    return func(...args);\r\n  } catch (e: any) {\r\n    return e instanceof Error ? e : new Error(e);\r\n  }\r\n}\r\n","/**\r\n * Creates a function that limits the number of times the given function (`func`) can be called.\r\n *\r\n * @template F - The type of the function to be invoked.\r\n * @param {number} n - The number of times the returned function is allowed to call `func` before stopping.\r\n * - If `n` is 0, `func` will never be called.\r\n * - If `n` is a positive integer, `func` will be called up to `n-1` times.\r\n * @param {F} func - The function to be called with the limit applied.\r\n * @returns {F} - A new function that:\r\n * - Tracks the number of calls.\r\n * - Invokes `func` until the `n-1`-th call.\r\n * - Returns `undefined` if the number of calls reaches or exceeds `n`, stopping further calls.\r\n * @throws {Error} - Throw an error if `n` is negative.\r\n * @example\r\n *\r\n * const beforeFn = before(3, () => {\r\n *  console.log(\"called\");\r\n * })\r\n *\r\n * // Will log 'called'.\r\n * beforeFn();\r\n *\r\n * // Will log 'called'.\r\n * beforeFn();\r\n *\r\n * // Will not log anything.\r\n * beforeFn();\r\n */\r\n\r\nexport function before<F extends (...args: any[]) => any>(n: number, func: F): F {\r\n  if (!Number.isInteger(n) || n < 0) {\r\n    throw new Error('n must be a non-negative integer.');\r\n  }\r\n\r\n  let counter = 0;\r\n  return ((...args: Parameters<F>) => {\r\n    if (++counter < n) {\r\n      return func(...args);\r\n    }\r\n    return undefined;\r\n  }) as F;\r\n}\r\n","import { camelCase as camelCaseToolkit } from '../../string/camelCase.ts';\r\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\r\n\r\n/**\r\n * Converts a string to camel case.\r\n *\r\n * Camel case is the naming convention in which the first word is written in lowercase and\r\n * each subsequent word begins with a capital letter, concatenated without any separator characters.\r\n *\r\n * @param {string | object} str - The string that is to be changed to camel case.\r\n * @returns {string} - The converted string to camel case.\r\n *\r\n * @example\r\n * const convertedStr1 = camelCase('camelCase') // returns 'camelCase'\r\n * const convertedStr2 = camelCase('some whitespace') // returns 'someWhitespace'\r\n * const convertedStr3 = camelCase('hyphen-text') // returns 'hyphenText'\r\n * const convertedStr4 = camelCase('HTTPRequest') // returns 'httpRequest'\r\n */\r\n\r\nexport function camelCase(str?: string | object): string {\r\n  return camelCaseToolkit(normalizeForCase(str));\r\n}\r\n","import { capitalize } from './capitalize.ts';\r\nimport { getWords } from './_internal/getWords.ts';\r\n\r\n/**\r\n * Converts a string to camel case.\r\n *\r\n * Camel case is the naming convention in which the first word is written in lowercase and\r\n * each subsequent word begins with a capital letter, concatenated without any separator characters.\r\n *\r\n * @param {string} str - The string that is to be changed to camel case.\r\n * @returns {string} - The converted string to camel case.\r\n *\r\n * @example\r\n * const convertedStr1 = camelCase('camelCase') // returns 'camelCase'\r\n * const convertedStr2 = camelCase('some whitespace') // returns 'someWhitespace'\r\n * const convertedStr3 = camelCase('hyphen-text') // returns 'hyphenText'\r\n * const convertedStr4 = camelCase('HTTPRequest') // returns 'httpRequest'\r\n * const convertedStr5 = camelCase('Keep unicode 😅') // returns 'keepUnicode😅'\r\n */\r\nexport function camelCase(str: string): string {\r\n  const words = getWords(str);\r\n\r\n  if (words.length === 0) {\r\n    return '';\r\n  }\r\n\r\n  const [first, ...rest] = words;\r\n\r\n  return `${first.toLowerCase()}${rest.map(word => capitalize(word)).join('')}`;\r\n}\r\n","/**\r\n * Casts value as an array if it's not one.\r\n *\r\n * @template T The type of elements in the array.\r\n * @param {T | T[]} value The value to be cast to an array.\r\n * @returns {T[]} An array containing the input value if it wasn't an array, or the original array if it was.\r\n *\r\n * @example\r\n * const arr1 = castArray(1);\r\n * // Returns: [1]\r\n *\r\n * const arr2 = castArray([1]);\r\n * // Returns: [1]\r\n *\r\n * const arr3 = castArray({'a': 1});\r\n * // Returns: [{'a': 1}]\r\n *\r\n * const arr4 = castArray(null);\r\n * // Returns: [null]\r\n *\r\n * const arr5 = castArray(undefined);\r\n * // Returns: [undefined]\r\n *\r\n * const arr6 = castArray();\r\n * // Returns: []\r\n */\r\n\r\nexport function castArray<T>(value?: T | readonly T[]): T[] {\r\n  if (arguments.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  return Array.isArray(value) ? value : ([value] as T[]);\r\n}\r\n","import { decimalAdjust } from '../_internal/decimalAdjust.ts';\r\n\r\n/**\r\n * Computes number rounded up to precision.\r\n *\r\n * @param {number | string} number The number to round up.\r\n * @param {number | string} precision The precision to round up to.\r\n * @returns {number} Returns the rounded up number.\r\n *\r\n * @example\r\n * ceil(4.006); // => 5\r\n * ceil(6.004, 2); // => 6.01\r\n * ceil(6040, -2); // => 6100\r\n */\r\nexport function ceil(number: number | string, precision: number | string = 0): number {\r\n  return decimalAdjust('ceil', number, precision);\r\n}\r\n","import { chunk as chunkToolkit } from '../../array/chunk.ts';\r\n\r\n/**\r\n * Splits an array into smaller arrays of a specified length.\r\n *\r\n * This function takes an input array and divides it into multiple smaller arrays,\r\n * each of a specified length. If the input array cannot be evenly divided,\r\n * the final sub-array will contain the remaining elements.\r\n *\r\n * @template T The type of elements in the array.\r\n * @param {T[]} arr - The array to be chunked into smaller arrays.\r\n * @param {number} size - The size of each smaller array. Must be a positive integer.\r\n * @returns {T[][]} A two-dimensional array where each sub-array has a maximum length of `size`.\r\n * @throws {Error} Throws an error if `size` is not a positive integer.\r\n *\r\n * @example\r\n * // Splits an array of numbers into sub-arrays of length 2\r\n * chunk([1, 2, 3, 4, 5], 2);\r\n * // Returns: [[1, 2], [3, 4], [5]]\r\n *\r\n * @example\r\n * // Splits an array of strings into sub-arrays of length 3\r\n * chunk(['a', 'b', 'c', 'd', 'e', 'f', 'g'], 3);\r\n * // Returns: [['a', 'b', 'c'], ['d', 'e', 'f'], ['g']]\r\n */\r\nexport function chunk<T>(arr: readonly T[], size = 1): T[][] {\r\n  size = Math.max(Math.floor(size), 0);\r\n\r\n  if (size === 0) {\r\n    return [];\r\n  }\r\n\r\n  return chunkToolkit(arr, size);\r\n}\r\n","/**\r\n * Splits an array into smaller arrays of a specified length.\r\n *\r\n * This function takes an input array and divides it into multiple smaller arrays,\r\n * each of a specified length. If the input array cannot be evenly divided,\r\n * the final sub-array will contain the remaining elements.\r\n *\r\n * @template T The type of elements in the array.\r\n * @param {T[]} arr - The array to be chunked into smaller arrays.\r\n * @param {number} size - The size of each smaller array. Must be a positive integer.\r\n * @returns {T[][]} A two-dimensional array where each sub-array has a maximum length of `size`.\r\n * @throws {Error} Throws an error if `size` is not a positive integer.\r\n *\r\n * @example\r\n * // Splits an array of numbers into sub-arrays of length 2\r\n * chunk([1, 2, 3, 4, 5], 2);\r\n * // Returns: [[1, 2], [3, 4], [5]]\r\n *\r\n * @example\r\n * // Splits an array of strings into sub-arrays of length 3\r\n * chunk(['a', 'b', 'c', 'd', 'e', 'f', 'g'], 3);\r\n * // Returns: [['a', 'b', 'c'], ['d', 'e', 'f'], ['g']]\r\n */\r\nexport function chunk<T>(arr: readonly T[], size: number): T[][] {\r\n  if (!Number.isInteger(size) || size <= 0) {\r\n    throw new Error('Size must be an integer greater than zero.');\r\n  }\r\n\r\n  const chunkLength = Math.ceil(arr.length / size);\r\n  const result: T[][] = Array(chunkLength);\r\n\r\n  for (let index = 0; index < chunkLength; index++) {\r\n    const start = index * size;\r\n    const end = start + size;\r\n\r\n    result[index] = arr.slice(start, end);\r\n  }\r\n\r\n  return result;\r\n}\r\n","type NotFalsey<T> = Exclude<T, false | null | 0 | 0n | '' | undefined>;\r\n\r\n/**\r\n * Removes falsey values (false, null, 0, 0n, '', undefined, NaN) from an array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The input array to remove falsey values.\r\n * @returns {Array<Exclude<T, false | null | 0 | 0n | '' | undefined>>} - A new array with all falsey values removed.\r\n *\r\n * @example\r\n * compact([0, 0n, 1, false, 2, '', 3, null, undefined, 4, NaN, 5]);\r\n * Returns: [1, 2, 3, 4, 5]\r\n */\r\nexport function compact<T>(arr: readonly T[]): Array<NotFalsey<T>> {\r\n  const result: Array<NotFalsey<T>> = [];\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const item = arr[i];\r\n    if (item) {\r\n      result.push(item as NotFalsey<T>);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { flatten } from '../../array/flatten.ts';\r\n\r\n/**\r\n * Concatenates multiple arrays and values into a single array.\r\n *\r\n * @template T The type of elements in the array.\r\n * @param {...(T | T[])} values - The values and/or arrays to concatenate.\r\n * @returns {T[]} A new array containing all the input values.\r\n *\r\n * @example\r\n * // Concatenate individual values\r\n * concat(1, 2, 3);\r\n * // returns [1, 2, 3]\r\n *\r\n * @example\r\n * // Concatenate arrays of values\r\n * concat([1, 2], [3, 4]);\r\n * // returns [1, 2, 3, 4]\r\n *\r\n * @example\r\n * // Concatenate a mix of individual values and arrays\r\n * concat(1, [2, 3], 4);\r\n * // returns [1, 2, 3, 4]\r\n *\r\n * @example\r\n * // Concatenate nested arrays\r\n * concat([1, [2, 3]], 4);\r\n * // returns [1, [2, 3], 4]\r\n */\r\nexport function concat<T>(...values: Array<T | readonly T[]>): T[] {\r\n  return flatten(values) as T[];\r\n}\r\n","import { conformsTo } from './conformsTo.ts';\r\nimport { cloneDeep } from '../../object/cloneDeep.ts';\r\n\r\n/**\r\n * Creates a function that invokes the predicate properties of `source` with the corresponding property values of a given object, returning `true` if all predicates return truthy, else `false`.\r\n *\r\n * Note: The created function is equivalent to `conformsTo` with source partially applied.\r\n *\r\n * @param {Record<PropertyKey, (value: any) => boolean>} source The object of property predicates to conform to.\r\n * @returns {(object: Record<PropertyKey, any>) => boolean} Returns the new spec function.\r\n *\r\n * @example\r\n * const isPositive = (n) => n > 0;\r\n * const isEven = (n) => n % 2 === 0;\r\n * const predicates = { a: isPositive, b: isEven };\r\n * const conform = conforms(predicates);\r\n *\r\n * console.log(conform({ a: 2, b: 4 })); // true\r\n * console.log(conform({ a: -1, b: 4 })); // false\r\n * console.log(conform({ a: 2, b: 3 })); // false\r\n * console.log(conform({ a: 0, b: 2 })); // false\r\n */\r\nexport function conforms(\r\n  source: Record<PropertyKey, (value: any) => boolean>\r\n): (object: Record<PropertyKey, any>) => boolean {\r\n  source = cloneDeep(source);\r\n\r\n  return function (object: Record<PropertyKey, any>) {\r\n    return conformsTo(object, source);\r\n  };\r\n}\r\n","import { getWords } from './_internal/getWords.ts';\r\n\r\n/**\r\n * Converts a string to constant case.\r\n *\r\n * Constant case is a naming convention where each word is written in uppercase letters and separated by an underscore (`_`). For example, `CONSTANT_CASE`.\r\n *\r\n * @param {string} str - The string that is to be changed to constant case.\r\n * @returns {string} - The converted string to constant case.\r\n *\r\n * @example\r\n * const convertedStr1 = constantCase('camelCase') // returns 'CAMEL_CASE'\r\n * const convertedStr2 = constantCase('some whitespace') // returns 'SOME_WHITESPACE'\r\n * const convertedStr3 = constantCase('hyphen-text') // returns 'HYPHEN_TEXT'\r\n * const convertedStr4 = constantCase('HTTPRequest') // returns 'HTTP_REQUEST'\r\n */\r\n\r\nexport function constantCase(str: string): string {\r\n  const words = getWords(str);\r\n  return words.map(word => word.toUpperCase()).join('_');\r\n}\r\n","/**\r\n * Count the occurrences of each item in an array\r\n * based on a transformation function.\r\n *\r\n * This function takes an array and a transformation function\r\n * that converts each item in the array to a key. It then\r\n * counts the occurrences of each transformed item and returns\r\n * an object with the transformed items as keys and the counts\r\n * as values.\r\n *\r\n * @template T - The type of the items in the input array.\r\n * @template K - The type of keys.\r\n * @param {T[]} arr - The input array to count occurrences.\r\n * @param {(item: T) => K} mapper - The transformation function that maps each item to a key.\r\n * @returns {Record<K, number>} An object containing the transformed items as keys and the\r\n * counts as values.\r\n *\r\n * @example\r\n * const array = ['a', 'b', 'c', 'a', 'b', 'a'];\r\n * const result = countBy(array, x => x);\r\n * // result will be { a: 3, b: 2, c: 1 }\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * const result = countBy(array, item => item % 2 === 0 ? 'even' : 'odd');\r\n * // result will be { odd: 3, even: 2 }\r\n */\r\nexport function countBy<T, K extends PropertyKey>(arr: readonly T[], mapper: (item: T) => K): Record<K, number> {\r\n  const result = {} as Record<K, number>;\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const item = arr[i];\r\n    const key = mapper(item);\r\n\r\n    result[key] = (result[key] ?? 0) + 1;\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Defers invoking the `func` until the current call stack has cleared. Any additional arguments are provided to func when it's invoked.\r\n *\r\n * @param {F} func The function to defer.\r\n * @param {Parameters<F>} args The arguments to invoke `func` with.\r\n * @returns {number} Returns the timer id.\r\n *\r\n * @example\r\n * defer((text) => {\r\n *   console.log(text);\r\n * }, 'deferred');\r\n * // => Logs 'deferred' after the current call stack has cleared.\r\n */\r\nexport function defer<F extends (...args: any[]) => any>(func: F, ...args: Parameters<F>): number {\r\n  if (typeof func !== 'function') {\r\n    throw new TypeError('Expected a function');\r\n  }\r\n  return setTimeout(func, 1, ...args);\r\n}\r\n","import { difference as differenceToolkit } from '../../array/difference.ts';\r\nimport { flatten } from '../../array/flatten.ts';\r\n\r\n/**\r\n * Computes the difference between an array and multiple arrays.\r\n *\r\n * @template T\r\n * @param {T[]} arr - The primary array from which to derive the difference. This is the main array\r\n * from which elements will be compared and filtered.\r\n * @param {...T[]} values - Multiple arrays containing elements to be excluded from the primary array.\r\n * These arrays will be flattened into a single array, and each element in this array will be checked against the primary array.\r\n * If a match is found, that element will be excluded from the result.\r\n * @returns {T[]} A new array containing the elements that are present in the primary array but not\r\n * in the flattened array.\r\n *\r\n * @example\r\n * const array1 = [1, 2, 3, 4, 5];\r\n * const array2 = [2, 4];\r\n * const array3 = [5, 6];\r\n * const result = difference(array1, array2, array3);\r\n * // result will be [1, 3] since 2, 4, and 5 are in the other arrays and are excluded from the result.\r\n */\r\nexport function difference<T>(arr: readonly T[], ...values: Array<readonly T[]>): T[] {\r\n  const arr1 = arr;\r\n  const arr2 = flatten(values);\r\n\r\n  return differenceToolkit(arr1, arr2);\r\n}\r\n","/**\r\n * Removes a specified number of elements from the beginning of an array and returns the rest.\r\n *\r\n * This function takes an array and a number, and returns a new array with the specified number\r\n * of elements removed from the start.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param { T[] |  null | undefined} collection - - The array from which to drop elements.\r\n * @param {number} itemsCount - The number of elements to drop from the beginning of the array.\r\n * @returns {T[]} A new array with the specified number of elements removed from the start.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * const result = drop(array, 2);\r\n * result will be [3, 4, 5] since the first two elements are dropped.\r\n */\r\nexport function drop<T>(collection: readonly T[] | null | undefined, itemsCount: number): T[] {\r\n  if (collection === null || collection === undefined) {\r\n    return [];\r\n  }\r\n\r\n  itemsCount = Math.max(itemsCount, 0);\r\n\r\n  return collection.slice(itemsCount);\r\n}\r\n","/**\r\n * Removes a specified number of elements from the end of an array and returns the rest.\r\n *\r\n * This function takes an array and a number, and returns a new array with the specified number\r\n * of elements removed from the end.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array from which to drop elements.\r\n * @param {number} itemsCount - The number of elements to drop from the end of the array.\r\n * @returns {T[]} A new array with the specified number of elements removed from the end.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * const result = dropRight(array, 2);\r\n * // result will be [1, 2, 3] since the last two elements are dropped.\r\n */\r\nexport function dropRight<T>(arr: readonly T[], itemsCount: number): T[] {\r\n  itemsCount = Math.min(-itemsCount, 0);\r\n\r\n  if (itemsCount === 0) {\r\n    return arr.slice();\r\n  }\r\n\r\n  return arr.slice(0, itemsCount);\r\n}\r\n","/**\r\n * Removes elements from the end of an array until the predicate returns false.\r\n *\r\n * This function iterates over an array from the end and drops elements until the provided\r\n * predicate function returns false. It then returns a new array with the remaining elements.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array from which to drop elements.\r\n * @param {(item: T) => boolean} canContinueDropping - A predicate function that determines\r\n * whether to continue dropping elements. The function is called with each element from the end,\r\n * and dropping continues as long as it returns true.\r\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * const result = dropRightWhile(array, x => x > 3);\r\n * // result will be [1, 2, 3] since elements greater than 3 are dropped from the end.\r\n */\r\nexport function dropRightWhile<T>(arr: readonly T[], canContinueDropping: (item: T) => boolean): T[] {\r\n  for (let i = arr.length - 1; i >= 0; i--) {\r\n    if (!canContinueDropping(arr[i])) {\r\n      return arr.slice(0, i + 1);\r\n    }\r\n  }\r\n\r\n  return [];\r\n}\r\n","/**\r\n * Removes elements from the beginning of an array until the predicate returns false.\r\n *\r\n * This function iterates over an array and drops elements from the start until the provided\r\n * predicate function returns false. It then returns a new array with the remaining elements.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array from which to drop elements.\r\n * @param {(item: T) => boolean} canContinueDropping - A predicate function that determines\r\n * whether to continue dropping elements. The function is called with each element, and dropping\r\n * continues as long as it returns true.\r\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * const result = dropWhile(array, x => x < 3);\r\n * // result will be [3, 4, 5] since elements less than 3 are dropped.\r\n */\r\nexport function dropWhile<T>(arr: readonly T[], canContinueDropping: (item: T) => boolean): T[] {\r\n  const dropEndIndex = arr.findIndex(item => !canContinueDropping(item));\r\n  if (dropEndIndex === -1) {\r\n    return [];\r\n  }\r\n\r\n  return arr.slice(dropEndIndex);\r\n}\r\n","/**\r\n * Checks if a string contains another string at the end of the string.\r\n *\r\n * Checks if one string endsWith another string. Optional position parameter to offset searching before a certain index.\r\n *\r\n * @param {string} str - The string that might contain the target string.\r\n * @param {string} target - The string to search for.\r\n * @param {number} position - An optional position from the start to search up to this index\r\n * @returns {boolean} - True if the str string ends with the target string.\r\n *\r\n * @example\r\n * const isPrefix = endsWith('fooBar', 'foo') // returns true\r\n * const isPrefix = endsWith('fooBar', 'bar') // returns false\r\n * const isPrefix = endsWith('fooBar', 'abc') // returns false\r\n * const isPrefix = endsWith('fooBar', 'foo', 3) // returns true\r\n * const isPrefix = endsWith('fooBar', 'abc', 5) // returns false\r\n */\r\nexport function endsWith(str: string, target: string, position: number = str.length): boolean {\r\n  return str.endsWith(target, position);\r\n}\r\n","/**\r\n * Escapes the RegExp special characters \"^\", \"$\", \"\\\\\", \".\", \"*\", \"+\", \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `str`.\r\n *\r\n * @param {string} str The string to escape.\r\n * @returns {string} Returns the escaped string.\r\n *\r\n * @example\r\n * import { escapeRegExp } from 'es-toolkit/string';\r\n *\r\n * escapeRegExp('[es-toolkit](https://es-toolkit.slash.page/)'); // returns '\\[es-toolkit\\]\\(https://es-toolkit\\.slash\\.page/\\)'\r\n */\r\nexport function escapeRegExp(str: string): string {\r\n  return str.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&');\r\n}\r\n","import { fill as fillToolkit } from '../../array/fill.ts';\r\n\r\n/**\r\n * Fills the whole array with a specified value.\r\n *\r\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\r\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\r\n * entire array.\r\n *\r\n * @template T, U, S, V\r\n * @param {Array<T | U>} array - The array to fill.\r\n * @param {U} value - The value to fill the array with.\r\n * @returns {Array<T | U>} The array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result = fill(array, 'a');\r\n * // => ['a', 'a', 'a']\r\n *\r\n * const result = fill(Array(3), 2);\r\n * // => [2, 2, 2]\r\n *\r\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\r\n * // => [4, '*', '*', 10]\r\n *\r\n * const result = fill(array, '*', -2, -1);\r\n * // => [1, '*', 3]\r\n */\r\nexport function fill<T>(array: unknown[], value?: T): T[];\r\n/**\r\n * Fills elements of an array with a specified value from the start position to the end.\r\n *\r\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\r\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\r\n * entire array.\r\n *\r\n * @template T, U, S, V\r\n * @param {Array<T | U>} array - The array to fill.\r\n * @param {U} value - The value to fill the array with.\r\n * @param {S} [start=0] - The start position. Defaults to 0.\r\n * @returns {Array<T | U>} The array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result = fill(array, 'a');\r\n * // => ['a', 'a', 'a']\r\n *\r\n * const result = fill(Array(3), 2);\r\n * // => [2, 2, 2]\r\n *\r\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\r\n * // => [4, '*', '*', 10]\r\n *\r\n * const result = fill(array, '*', -2, -1);\r\n * // => [1, '*', 3]\r\n */\r\nexport function fill<T, U, S>(array: Array<T | U>, value: U, start: S): Array<T | U>;\r\n/**\r\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\r\n *\r\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\r\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\r\n * entire array.\r\n *\r\n * @template T, U, S, V\r\n * @param {Array<T | U>} array - The array to fill.\r\n * @param {U} value - The value to fill the array with.\r\n * @param {S} [start=0] - The start position. Defaults to 0.\r\n * @param {V} [end=arr.length] - The end position. Defaults to the array's length.\r\n * @returns {Array<T | U>} The array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result = fill(array, 'a');\r\n * // => ['a', 'a', 'a']\r\n *\r\n * const result = fill(Array(3), 2);\r\n * // => [2, 2, 2]\r\n *\r\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\r\n * // => [4, '*', '*', 10]\r\n *\r\n * const result = fill(array, '*', -2, -1);\r\n * // => [1, '*', 3]\r\n */\r\nexport function fill<T, U, S, V>(array: Array<T | U>, value: U, start: S, end: V): Array<T | U>;\r\n/**\r\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\r\n *\r\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\r\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\r\n * entire array.\r\n *\r\n * @template T, U, S, V\r\n * @param {Array<T | U>} array - The array to fill.\r\n * @param {U} value - The value to fill the array with.\r\n * @param {S} [start=0] - The start position. Defaults to 0.\r\n * @param {V} [end=arr.length] - The end position. Defaults to the array's length.\r\n * @returns {Array<T | U>} The array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result = fill(array, 'a');\r\n * // => ['a', 'a', 'a']\r\n *\r\n * const result = fill(Array(3), 2);\r\n * // => [2, 2, 2]\r\n *\r\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\r\n * // => [4, '*', '*', 10]\r\n *\r\n * const result = fill(array, '*', -2, -1);\r\n * // => [1, '*', 3]\r\n */\r\nexport function fill<T, U>(array: Array<T | U>, value: U, start = 0, end = array.length): Array<T | U> {\r\n  start = Math.floor(start);\r\n  end = Math.floor(end);\r\n\r\n  if (!start) {\r\n    start = 0;\r\n  }\r\n  if (!end) {\r\n    end = 0;\r\n  }\r\n\r\n  return fillToolkit(array, value, start, end);\r\n}\r\n","/**\r\n * Fills the whole array with a specified value.\r\n *\r\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\r\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\r\n * entire array.\r\n *\r\n * @template T, U\r\n * @param {Array<T | U>} array - The array to fill.\r\n * @param {U} value - The value to fill the array with.\r\n * @returns {Array<T | U>} The array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result = fill(array, 'a');\r\n * // => ['a', 'a', 'a']\r\n *\r\n * const result = fill(Array(3), 2);\r\n * // => [2, 2, 2]\r\n *\r\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\r\n * // => [4, '*', '*', 10]\r\n *\r\n * const result = fill(array, '*', -2, -1);\r\n * // => [1, '*', 3]\r\n */\r\nexport function fill<T>(array: unknown[], value: T): T[];\r\n/**\r\n * Fills elements of an array with a specified value from the start position up to the end of the array.\r\n *\r\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\r\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\r\n * entire array.\r\n *\r\n * @template T, U\r\n * @param {Array<T | U>} array - The array to fill.\r\n * @param {U} value - The value to fill the array with.\r\n * @param {number} [start=0] - The start position. Defaults to 0.\r\n * @returns {Array<T | U>} The array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result = fill(array, 'a');\r\n * // => ['a', 'a', 'a']\r\n *\r\n * const result = fill(Array(3), 2);\r\n * // => [2, 2, 2]\r\n *\r\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\r\n * // => [4, '*', '*', 10]\r\n *\r\n * const result = fill(array, '*', -2, -1);\r\n * // => [1, '*', 3]\r\n */\r\nexport function fill<T, U>(array: Array<T | U>, value: U, start: number): Array<T | U>;\r\n/**\r\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\r\n *\r\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\r\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\r\n * entire array.\r\n *\r\n * @template T, U\r\n * @param {Array<T | U>} array - The array to fill.\r\n * @param {U} value - The value to fill the array with.\r\n * @param {number} [start=0] - The start position. Defaults to 0.\r\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\r\n * @returns {Array<T | U>} The array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result = fill(array, 'a');\r\n * // => ['a', 'a', 'a']\r\n *\r\n * const result = fill(Array(3), 2);\r\n * // => [2, 2, 2]\r\n *\r\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\r\n * // => [4, '*', '*', 10]\r\n *\r\n * const result = fill(array, '*', -2, -1);\r\n * // => [1, '*', 3]\r\n */\r\nexport function fill<T, U>(array: Array<T | U>, value: U, start: number, end: number): Array<T | U>;\r\n/**\r\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\r\n *\r\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\r\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\r\n * entire array.\r\n *\r\n * @template T, U\r\n * @param {Array<T | U>} array - The array to fill.\r\n * @param {U} value - The value to fill the array with.\r\n * @param {number} [start=0] - The start position. Defaults to 0.\r\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\r\n * @returns {Array<T | U>} The array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result = fill(array, 'a');\r\n * // => ['a', 'a', 'a']\r\n *\r\n * const result = fill(Array(3), 2);\r\n * // => [2, 2, 2]\r\n *\r\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\r\n * // => [4, '*', '*', 10]\r\n *\r\n * const result = fill(array, '*', -2, -1);\r\n * // => [1, '*', 3]\r\n */\r\nexport function fill<T, U>(array: Array<T | U>, value: U, start = 0, end = array.length): Array<T | U> {\r\n  const length = array.length;\r\n  const finalStart = Math.max(start >= 0 ? start : length + start, 0);\r\n  const finalEnd = Math.min(end >= 0 ? end : length + end, length);\r\n\r\n  for (let i = finalStart; i < finalEnd; i++) {\r\n    array[i] = value;\r\n  }\r\n\r\n  return array;\r\n}\r\n","import { property } from '../object/property.ts';\r\nimport { matches } from '../predicate/matches.ts';\r\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\r\n\r\n/**\r\n * Finds the first item in an array that matches the given predicate function.\r\n *\r\n * @template T\r\n * @param {T[]} arr - The array to search through.\r\n * @param {(item: T, index: number, arr: T[]) => unknown} doesMatch - A function that takes an item, its index, and the array, and returns a truthy value if the item matches the criteria.\r\n * @returns {T | undefined} - The first item that matches the predicate, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a predicate function\r\n * const items = [1, 2, 3, 4, 5];\r\n * const result = find(items, (item) => item > 3);\r\n * console.log(result); // 4\r\n */\r\nexport function find<T>(\r\n  arr: readonly T[],\r\n  doesMatch: (item: T, index: number, arr: readonly T[]) => unknown\r\n): T | undefined;\r\n\r\n/**\r\n * Finds the first item in an array that matches the given partial object.\r\n *\r\n * @template T\r\n * @param {T[]} arr - The array to search through.\r\n * @param {Partial<T>} doesMatch - A partial object that specifies the properties to match.\r\n * @returns {T | undefined} - The first item that matches the partial object, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a partial object\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = find(items, { name: 'Bob' });\r\n * console.log(result); // { id: 2, name: 'Bob' }\r\n */\r\nexport function find<T>(arr: readonly T[], doesMatch: Partial<T>): T | undefined;\r\n\r\n/**\r\n * Finds the first item in an array that matches a property with a specific value.\r\n *\r\n * @template T\r\n * @param {readonly T[]} arr - The array to search through.\r\n * @param {[keyof T, unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\r\n * @returns {T | undefined} - The first item that has the specified property value, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property-value pair\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = find(items, ['name', 'Alice']);\r\n * console.log(result); // { id: 1, name: 'Alice' }\r\n */\r\nexport function find<T>(arr: readonly T[], doesMatchProperty: [keyof T, unknown]): T | undefined;\r\n\r\n/**\r\n * Finds the first item in an array that has a specific property, where the property name is provided as a string.\r\n *\r\n * @template T\r\n * @param {readonly T[]} arr - The array to search through.\r\n * @param {string} propertyToCheck - The property name to check.\r\n * @returns {T | undefined} - The first item that has the specified property, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property name\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = find(items, 'name');\r\n * console.log(result); // { id: 1, name: 'Alice' }\r\n */\r\nexport function find<T>(arr: readonly T[], propertyToCheck: string): T | undefined;\r\n\r\n/**\r\n * Finds the first item in an object that matches the given predicate function.\r\n *\r\n * @template T\r\n * @param {T extends Record<string, unknown> ? T : never} object - The object to search through.\r\n * @param {(item: T[keyof T], index: number, arr: T) => unknown} doesMatch - A function that takes an item, its key, and the object, and returns a truthy value if the item matches the criteria.\r\n * @returns {T | undefined} - The first property value that matches the predicate, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a predicate function\r\n * const obj = { a: 1, b: 2, c: 3 };\r\n * const result = find(obj, (item) => item > 2);\r\n * console.log(result); // 3\r\n */\r\nexport function find<T extends Record<string, unknown>>(\r\n  object: T,\r\n  doesMatch: (item: T[keyof T], index: number, object: T) => unknown\r\n): T | undefined;\r\n\r\n/**\r\n * Finds the first item in an object that matches the given partial value.\r\n *\r\n * @template T\r\n * @param {T extends Record<string, unknown> ? T : never} object - The object to search through.\r\n * @param {Partial<T[keyof T]>} doesMatch - A partial value to match against the values of the object.\r\n * @returns {T | undefined} - The first property value that matches the partial value, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a partial value\r\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } };\r\n * const result = find(obj, { name: 'Bob' });\r\n * console.log(result); // { id: 2, name: 'Bob' }\r\n */\r\nexport function find<T extends Record<string, unknown>>(object: T, doesMatch: Partial<T[keyof T]>): T | undefined;\r\n\r\n/**\r\n * Finds the first item in an object that matches a property with a specific value.\r\n *\r\n * @template T\r\n * @param {readonly T[]} object - The object to search through.\r\n * @param {[keyof T, unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\r\n * @returns {T | undefined} - The first item that has the specified property value, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property-value pair\r\n * const items = { alice: { id: 1, name: 'Alice' }, bob: { id: 2, name: 'Bob' } };\r\n * const result = find(items, ['name', 'Alice']);\r\n * console.log(result); // { id: 1, name: 'Alice' }\r\n */\r\nexport function find<T extends Record<string, unknown>>(\r\n  object: T,\r\n  doesMatchProperty: [keyof T, unknown]\r\n): T | undefined;\r\n\r\n/**\r\n * Finds the first item in an object that has a specific property, where the property name is provided as a string.\r\n *\r\n * @template T\r\n * @param {T extends Record<string, unknown> ? T : never} object - The object to search through.\r\n * @param {string} propertyToCheck - The property name to check.\r\n * @returns {T | undefined} - The first property value that has the specified property, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property name\r\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } };\r\n * const result = find(obj, 'name');\r\n * console.log(result); // { id: 1, name: 'Alice' }\r\n */\r\nexport function find<T extends Record<string, unknown>>(object: T, propertyToCheck: string): T | undefined;\r\n\r\n/**\r\n * Finds the first item in an object that has a specific property, where the property name is provided as a string.\r\n *\r\n * @template T\r\n * @param {T extends Record<string, unknown> ? T : never} object - The object to search through.\r\n * @param {readonly T[] | Record<any, any>} source - The source array or object to search through.\r\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string} doesMatch - The criteria to match. It can be a function, a partial object, a key-value pair, or a property name.\r\n * @param {string} propertyToCheck - The property name to check.\r\n * @returns {T | undefined} - The first property value that has the specified property, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property name\r\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } };\r\n * const result = find(obj, 'name');\r\n * console.log(result); // { id: 1, name: 'Alice' }\r\n */\r\nexport function find<T>(\r\n  source: readonly T[] | Record<any, any>,\r\n  doesMatch: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string\r\n): T | undefined {\r\n  let values = source;\r\n\r\n  if (!Array.isArray(source)) {\r\n    values = Object.values(source);\r\n  }\r\n\r\n  switch (typeof doesMatch) {\r\n    case 'function': {\r\n      if (!Array.isArray(source)) {\r\n        const entries: any[] = Object.entries(source);\r\n\r\n        for (let i = 0; i < entries.length; i++) {\r\n          const entry = entries[i];\r\n          const key = entry[0];\r\n          const value = entry[1];\r\n\r\n          if (doesMatch(value, key, source)) {\r\n            return value;\r\n          }\r\n        }\r\n\r\n        return undefined;\r\n      }\r\n\r\n      return values.find(doesMatch);\r\n    }\r\n    case 'object': {\r\n      if (Array.isArray(doesMatch) && doesMatch.length === 2) {\r\n        const key = doesMatch[0];\r\n        const value = doesMatch[1];\r\n\r\n        return values.find(matchesProperty(key, value));\r\n      } else {\r\n        return values.find(matches(doesMatch));\r\n      }\r\n    }\r\n    case 'string': {\r\n      return values.find(property(doesMatch));\r\n    }\r\n  }\r\n}\r\n","import { property } from '../object/property.ts';\r\nimport { matches } from '../predicate/matches.ts';\r\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\r\n\r\n/**\r\n * Finds the index of the first item in an array that matches the given predicate function.\r\n *\r\n * @template T\r\n * @param {T[]} arr - The array to search through.\r\n * @param {(item: T, index: number, arr: T[]) => unknown} doesMatch - A function that takes an item, its index, and the array, and returns a truthy value if the item matches the criteria.\r\n * @returns {number} - The index of the first item that matches the predicate, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a predicate function\r\n * const items = [1, 2, 3, 4, 5];\r\n * const result = find(items, (item) => item > 3);\r\n * console.log(result); // 4\r\n */\r\nexport function findIndex<T>(\r\n  arr: readonly T[],\r\n  doesMatch: (item: T, index: number, arr: readonly T[]) => unknown\r\n): number;\r\n\r\n/**\r\n * Finds the index of the first item in an array that matches the given partial object.\r\n *\r\n * @template T\r\n * @param {T[]} arr - The array to search through.\r\n * @param {Partial<T>} doesMatch - A partial object that specifies the properties to match.\r\n * @returns {number} - The index of the first item that matches the partial object, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a partial object\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = findIndex(items, { name: 'Bob' });\r\n * console.log(result); // 1\r\n */\r\nexport function findIndex<T>(arr: readonly T[], doesMatch: Partial<T>): number;\r\n\r\n/**\r\n * Finds the index of the first item in an array that matches a property with a specific value.\r\n *\r\n * @template T\r\n * @param {readonly T[]} arr - The array to search through.\r\n * @param {[keyof T, unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\r\n * @returns {number} - The index of the first item that has the specified property value, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property-value pair\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = findIndex(items, ['name', 'Alice']);\r\n * console.log(result); // 0\r\n */\r\nexport function findIndex<T>(arr: readonly T[], doesMatchProperty: [keyof T, unknown]): number;\r\n\r\n/**\r\n * Finds the index of the first item in an array that has a specific property, where the property name is provided as a string.\r\n *\r\n * @template T\r\n * @param {readonly T[]} arr - The array to search through.\r\n * @param {string} propertyToCheck - The property name to check.\r\n * @returns {number} - The index of the first item that has the specified property, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property name\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = findIndex(items, 'name');\r\n * console.log(result); // 0\r\n */\r\nexport function findIndex<T>(arr: readonly T[], propertyToCheck: string): number;\r\n\r\n/**\r\n * Finds the index of the first item in an array that has a specific property, where the property name is provided as a string.\r\n *\r\n * @template T\r\n * @param {readonly T[]} arr - The array to search through.\r\n * @param {readonly T[]} source - The source array to search for the matching item.\r\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string} doesMatch - The criteria to match against the items in the array. This can be a function, a partial object, a key-value pair, or a property name.\r\n * @param {string} propertyToCheck - The property name to check for in the items of the array.\r\n * @returns {number} - The index of the first item that has the specified property, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property name\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = findIndex(items, 'name');\r\n * console.log(result); // 0\r\n */\r\nexport function findIndex<T>(\r\n  source: readonly T[],\r\n  doesMatch: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string\r\n): number {\r\n  switch (typeof doesMatch) {\r\n    case 'function': {\r\n      return source.findIndex(doesMatch);\r\n    }\r\n    case 'object': {\r\n      if (Array.isArray(doesMatch) && doesMatch.length === 2) {\r\n        const key = doesMatch[0];\r\n        const value = doesMatch[1];\r\n\r\n        return source.findIndex(matchesProperty(key, value));\r\n      } else {\r\n        return source.findIndex(matches(doesMatch));\r\n      }\r\n    }\r\n    case 'string': {\r\n      return source.findIndex(property(doesMatch));\r\n    }\r\n  }\r\n}\r\n","import { property } from '../object/property.ts';\r\nimport { matches } from '../predicate/matches.ts';\r\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\r\n\r\n/**\r\n * Iterates through an array in reverse order and returns the index of the first item that matches the given predicate function.\r\n *\r\n * @template T\r\n * @param {T[]} arr - The array to search through.\r\n * @param {(item: T, index: number, arr: T[]) => unknown} doesMatch - A function that takes an item, its index, and the array, and returns a truthy value if the item matches the criteria.\r\n * @param {number} [fromIndex=arr.length - 1] - The index to start the search from, defaults to the last index of the array.\r\n * @returns {number} - The index of the first item that matches the predicate, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a predicate function\r\n * const items = [1, 2, 3, 4, 5];\r\n * const result = findLastIndex(items, (item) => item > 3)\r\n * console.log(result); // 4\r\n */\r\nexport function findLastIndex<T>(\r\n  arr: readonly T[],\r\n  doesMatch: (item: T, index: number, arr: readonly T[]) => unknown,\r\n  fromIndex?: number\r\n): number;\r\n\r\n/**\r\n * Finds the index of the first item in an array that matches the given partial object.\r\n *\r\n * @template T\r\n * @param {readonly T[]} arr - The array to search through.\r\n * @param {Partial<T>} doesMatch - A partial object that specifies the properties to match.\r\n * @param {number} [fromIndex=arr.length - 1] - The index to start the search from, defaults to the last index of the array.\r\n * @returns {number} - The index of the first item that matches the partial object, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a partial object\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = findLastIndex(items, { name: 'Bob' });\r\n * console.log(result); // 1\r\n */\r\nexport function findLastIndex<T>(arr: readonly T[], doesMatch: Partial<T>, fromIndex?: number): number;\r\n\r\n/**\r\n * Finds the index of the first item in an array that matches a property with a specific value.\r\n *\r\n * @template T\r\n * @param {readonly T[]} arr - The array to search through.\r\n * @param {[keyof T, unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\r\n * @param {number} [fromIndex=arr.length - 1] - The index to start the search from, defaults to the last index of the array.\r\n * @returns {number} - The index of the first item that has the specified property value, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property-value pair\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = findLastIndex(items, ['name', 'Alice']);\r\n * console.log(result); // 0\r\n */\r\nexport function findLastIndex<T>(arr: readonly T[], doesMatchProperty: [keyof T, unknown], fromIndex?: number): number;\r\n\r\n/**\r\n * Finds the index of the first item in an array that has a specific property, where the property name is provided as a string.\r\n *\r\n * @template T\r\n * @param {readonly T[]} arr - The array to search through.\r\n * @param {string} propertyToCheck - The property name to check.\r\n * @param {number} [fromIndex=arr.length - 1] - The index to start the search from, defaults to the last index of the array.\r\n * @returns {number} - The index of the first item that has the specified property, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property name\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = findLastIndex(items, 'name');\r\n * console.log(result); // 1\r\n */\r\nexport function findLastIndex<T>(arr: readonly T[], propertyToCheck: string, fromIndex?: number): number;\r\n\r\n/**\r\n * Finds the index of the first item in an array that has a specific property, where the property name is provided as a string.\r\n *\r\n * @template T\r\n * @param {T[]} arr - The array to search through.\r\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string} doesMatch - The property name to check.\r\n * @param {number} [fromIndex=arr.length - 1] - The index to start the search from, defaults to the last index of the array.\r\n * @returns {number} - The index of the first item that has the specified property, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * // Using a property name\r\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\r\n * const result = findLastIndex(items, 'name');\r\n * console.log(result); // 1\r\n */\r\nexport function findLastIndex<T>(\r\n  arr: readonly T[],\r\n  doesMatch: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string,\r\n  fromIndex: number = arr.length - 1\r\n): number {\r\n  if (fromIndex < 0) {\r\n    fromIndex = Math.max(arr.length + fromIndex, 0);\r\n  } else {\r\n    fromIndex = Math.min(fromIndex, arr.length - 1);\r\n  }\r\n\r\n  arr = arr.slice(0, fromIndex + 1);\r\n\r\n  switch (typeof doesMatch) {\r\n    case 'function': {\r\n      return arr.findLastIndex(doesMatch);\r\n    }\r\n    case 'object': {\r\n      if (Array.isArray(doesMatch) && doesMatch.length === 2) {\r\n        const key = doesMatch[0];\r\n        const value = doesMatch[1];\r\n\r\n        return arr.findLastIndex(matchesProperty(key, value));\r\n      } else {\r\n        return arr.findLastIndex(matches(doesMatch));\r\n      }\r\n    }\r\n    case 'string': {\r\n      return arr.findLastIndex(property(doesMatch));\r\n    }\r\n  }\r\n}\r\n","import { flatten } from './flatten.ts';\r\n\r\n/**\r\n * Maps each element in the array using the iteratee function and flattens the result up to the specified depth.\r\n *\r\n * @template T - The type of elements within the array.\r\n * @template U - The type of elements within the returned array from the iteratee function.\r\n * @template D - The depth to which the array should be flattened.\r\n * @param {T[]} arr - The array to flatten.\r\n * @param {(item: T) => U} iteratee - The function that produces the new array elements.\r\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\r\n * @returns {Array<FlatArray<U[], D>>} The new array with the mapped and flattened elements.\r\n *\r\n * @example\r\n * const arr = [1, 2, 3];\r\n *\r\n * flatMap(arr, (item: number) => [item, item]);\r\n * // [1, 1, 2, 2, 3, 3]\r\n *\r\n * flatMap(arr, (item: number) => [[item, item]], 2);\r\n * // [1, 1, 2, 2, 3, 3]\r\n */\r\nexport function flatMap<T, U, D extends number>(\r\n  arr: readonly T[],\r\n  iteratee: (item: T) => U,\r\n  depth = 1 as D\r\n): Array<FlatArray<U[], D>> {\r\n  return flatten(\r\n    arr.map(item => iteratee(item)),\r\n    depth\r\n  );\r\n}\r\n","import { ExtractNestedArrayType, flattenDeep } from './flattenDeep.ts';\r\n\r\n/**\r\n * Recursively maps each element in an array using a provided iteratee function and then deeply flattens the resulting array.\r\n *\r\n * @template T - The type of elements within the array.\r\n * @template U - The type of elements within the returned array from the iteratee function.\r\n * @param {T[]} arr - The array to flatten.\r\n * @param {(item: T) => U} iteratee - The function that produces the new array elements.\r\n * @returns {Array<ExtractNestedArrayType<U>>} A new array that has been flattened.\r\n *\r\n * @example\r\n * const result = flatMapDeep([1, 2, 3], n => [[n, n]]);\r\n * // [1, 1, 2, 2, 3, 3]\r\n */\r\nexport function flatMapDeep<T, U>(arr: readonly T[], iteratee: (item: T) => U): Array<ExtractNestedArrayType<U>> {\r\n  return flattenDeep(arr.map((item: T) => iteratee(item)));\r\n}\r\n","import { flatten } from './flatten.ts';\r\n\r\n/**\r\n * Utility type for recursively unpacking nested array types to extract the type of the innermost element\r\n *\r\n * @example\r\n * ExtractNestedArrayType<(number | (number | number[])[])[]>\r\n * // number\r\n *\r\n * ExtractNestedArrayType<(boolean | (string | number[])[])[]>\r\n * // string | number | boolean\r\n */\r\nexport type ExtractNestedArrayType<T> = T extends ReadonlyArray<infer U> ? ExtractNestedArrayType<U> : T;\r\n\r\n/**\r\n * Flattens all depths of a nested array.\r\n *\r\n * @template T - The type of elements within the array.\r\n * @param {T[]} arr - The array to flatten.\r\n * @returns {Array<ExtractNestedArrayType<T>>} A new array that has been flattened.\r\n *\r\n * @example\r\n * const arr = flattenDeep([1, [2, [3]], [4, [5, 6]]]);\r\n * // Returns: [1, 2, 3, 4, 5, 6]\r\n */\r\nexport function flattenDeep<T>(arr: readonly T[]): Array<ExtractNestedArrayType<T>> {\r\n  return flatten(arr, Infinity) as Array<ExtractNestedArrayType<T>>;\r\n}\r\n","import { flatten } from './flatten.ts';\r\n\r\n/**\r\n * Utility type for recursively unpacking nested array types to extract the type of the innermost element\r\n *\r\n * @example\r\n * ExtractNestedArrayType<(number | (number | number[])[])[]>\r\n * // number\r\n *\r\n * ExtractNestedArrayType<(boolean | (string | number[])[])[]>\r\n * // string | number | boolean\r\n */\r\ntype ExtractNestedArrayType<T> = T extends ReadonlyArray<infer U> ? ExtractNestedArrayType<U> : T;\r\n\r\n/**\r\n * Flattens all depths of a nested array.\r\n *\r\n * @template T - The type of elements within the array.\r\n * @param {T[] | object} value - The value to flatten.\r\n * @returns {Array<ExtractNestedArrayType<T>> | []} A new array that has been flattened.\r\n *\r\n * @example\r\n * const value = flattenDeep([1, [2, [3]], [4, [5, 6]]]);\r\n * // Returns: [1, 2, 3, 4, 5, 6]\r\n */\r\nexport function flattenDeep<T>(value: readonly T[] | object): Array<ExtractNestedArrayType<T>> | [] {\r\n  return flatten(value, Infinity) as Array<ExtractNestedArrayType<T>>;\r\n}\r\n","import { flatten } from './flatten.ts';\r\n\r\n/**\r\n * Flattens an array up to the specified depth.\r\n *\r\n * @template T - The type of elements within the array.\r\n * @template D - The depth to which the array should be flattened.\r\n * @param {T[] | object} value - The value to flatten.\r\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\r\n * @returns {Array<FlatArray<T[], D>> | []} A new array that has been flattened.\r\n *\r\n * @example\r\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 1);\r\n * // Returns: [1, 2, 3, 4, [5, 6]]\r\n *\r\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 2);\r\n * // Returns: [1, 2, 3, 4, 5, 6]\r\n */\r\nexport function flattenDepth<T, D extends number = 1>(\r\n  value: readonly T[] | object,\r\n  depth = 1 as D\r\n): Array<FlatArray<T[], D>> | [] {\r\n  return flatten(value, depth);\r\n}\r\n","import { decimalAdjust } from '../_internal/decimalAdjust.ts';\r\n\r\n/**\r\n * Computes number rounded down to precision.\r\n *\r\n * @param {number | string} number The number to round down.\r\n * @param {number | string} precision The precision to round down to.\r\n * @returns {number} Returns the rounded down number.\r\n *\r\n * @example\r\n * floor(4.006); // => 4\r\n * floor(0.046, 2); // => 0.04\r\n * floor(4060, -2); // => 4000\r\n */\r\nexport function floor(number: number | string, precision: number | string = 0): number {\r\n  return decimalAdjust('floor', number, precision);\r\n}\r\n","/**\r\n * Creates a function that returns the result of invoking the given functions with the `this` binding of the created function, where each successive invocation is supplied the return value of the previous.\r\n *\r\n * @param {() => R} f The function to invoke.\r\n * @returns {() => R} Returns the new composite function.\r\n *\r\n * @example\r\n * function noArgFunc() {\r\n *  return 42;\r\n * }\r\n *\r\n * const combined = flow(noArgFunc);\r\n * console.log(combined()); // 42\r\n */\r\nexport function flow<R>(f: () => R): () => R;\r\n/**\r\n * Creates a function that returns the result of invoking the given functions with the `this` binding of the created function, where each successive invocation is supplied the return value of the previous.\r\n *\r\n * @param {(...args: A) => R} f1 The function to invoke.\r\n * @returns {(...args: A) => R} Returns the new composite function.\r\n *\r\n * @example\r\n * function oneArgFunc(a: number) {\r\n *   return a * 2;\r\n * }\r\n *\r\n * const combined = flow(oneArgFunc);\r\n * console.log(combined(5)); // 10\r\n */\r\nexport function flow<A extends any[], R>(f1: (...args: A) => R): (...args: A) => R;\r\n/**\r\n * Creates a function that returns the result of invoking the given functions with the `this` binding of the created function, where each successive invocation is supplied the return value of the previous.\r\n *\r\n * @param {(...args: A) => R1} f1 The function to invoke.\r\n * @param {(a: R1) => R2} f2 The function to invoke.\r\n * @returns {(...args: A) => R2} Returns the new composite function.\r\n *\r\n * @example\r\n * const add = (x: number, y: number) => x + y;\r\n * const square = (n: number) => n * n;\r\n *\r\n * const combined = flow(add, square);\r\n * console.log(combined(1, 2)); // 9\r\n */\r\nexport function flow<A extends any[], R1, R2>(f1: (...args: A) => R1, f2: (a: R1) => R2): (...args: A) => R2;\r\n/**\r\n * Creates a function that returns the result of invoking the given functions with the `this` binding of the created function, where each successive invocation is supplied the return value of the previous.\r\n *\r\n * @param {(...args: A) => R1} f1 The function to invoke.\r\n * @param {(a: R1) => R2} f2 The function to invoke.\r\n * @param {(a: R2) => R3} f3 The function to invoke.\r\n * @returns {(...args: A) => R3} Returns the new composite function.\r\n *\r\n * @example\r\n * const add = (x: number, y: number) => x + y;\r\n * const square = (n: number) => n * n;\r\n * const double = (n: number) => n * 2;\r\n *\r\n * const combined = flow(add, square, double);\r\n * console.log(combined(1, 2)); // 18\r\n */\r\nexport function flow<A extends any[], R1, R2, R3>(\r\n  f1: (...args: A) => R1,\r\n  f2: (a: R1) => R2,\r\n  f3: (a: R2) => R3\r\n): (...args: A) => R3;\r\n/**\r\n * Creates a function that returns the result of invoking the given functions with the `this` binding of the created function, where each successive invocation is supplied the return value of the previous.\r\n *\r\n * @param {(...args: A) => R1} f1 The function to invoke.\r\n * @param {(a: R1) => R2} f2 The function to invoke.\r\n * @param {(a: R2) => R3} f3 The function to invoke.\r\n * @param {(a: R3) => R4} f4 The function to invoke.\r\n * @returns {(...args: A) => R4} Returns the new composite function.\r\n *\r\n * @example\r\n * const add = (x: number, y: number) => x + y;\r\n * const square = (n: number) => n * n;\r\n * const double = (n: number) => n * 2;\r\n * const toStr = (n: number) => n.toString();\r\n *\r\n * const combined = flow(add, square, double, toStr);\r\n * console.log(combined(1, 2)); // '18'\r\n */\r\nexport function flow<A extends any[], R1, R2, R3, R4>(\r\n  f1: (...args: A) => R1,\r\n  f2: (a: R1) => R2,\r\n  f3: (a: R2) => R3,\r\n  f4: (a: R3) => R4\r\n): (...args: A) => R4;\r\n/**\r\n * Creates a function that returns the result of invoking the given functions with the `this` binding of the created function, where each successive invocation is supplied the return value of the previous.\r\n *\r\n * @param {(...args: A) => R1} f1 The function to invoke.\r\n * @param {(a: R1) => R2} f2 The function to invoke.\r\n * @param {(a: R2) => R3} f3 The function to invoke.\r\n * @param {(a: R3) => R4} f4 The function to invoke.\r\n * @param {(a: R4) => R5} f5 The function to invoke.\r\n * @returns {(...args: A) => R5} Returns the new composite function.\r\n *\r\n * @example\r\n * const add = (x: number, y: number) => x + y;\r\n * const square = (n: number) => n * n;\r\n * const double = (n: number) => n * 2;\r\n * const toStr = (n: number) => n.toString();\r\n * const split = (s: string) => s.split('');\r\n *\r\n * const combined = flow(add, square, double, toStr, split);\r\n * console.log(combined(1, 2)); // ['1', '8']\r\n */\r\nexport function flow<A extends any[], R1, R2, R3, R4, R5>(\r\n  f1: (...args: A) => R1,\r\n  f2: (a: R1) => R2,\r\n  f3: (a: R2) => R3,\r\n  f4: (a: R3) => R4,\r\n  f5: (a: R4) => R5\r\n): (...args: A) => R5;\r\n/**\r\n * Creates a function that returns the result of invoking the given functions with the `this` binding of the created function, where each successive invocation is supplied the return value of the previous.\r\n *\r\n * @param {Array<(...args: any[]) => any>} funcs The functions to invoke.\r\n * @returns {(...args: any[]) => any} Returns the new composite function.\r\n *\r\n * @example\r\n * const add = (x: number, y: number) => x + y;\r\n * const square = (n: number) => n * n;\r\n *\r\n * const combined = flow(add, square);\r\n * console.log(combined(1, 2)); // 9\r\n */\r\nexport function flow(...funcs: Array<(...args: any[]) => any>): (...args: any[]) => any;\r\n/**\r\n * Creates a function that returns the result of invoking the given functions with the `this` binding of the created function, where each successive invocation is supplied the return value of the previous.\r\n *\r\n * @param {Array<(...args: any[]) => any>} funcs The functions to invoke.\r\n * @returns {(...args: any[]) => any} Returns the new composite function.\r\n *\r\n * @example\r\n * const add = (x: number, y: number) => x + y;\r\n * const square = (n: number) => n * n;\r\n *\r\n * const combined = flow(add, square);\r\n * console.log(combined(1, 2)); // 9\r\n */\r\nexport function flow(...funcs: Array<(...args: any[]) => any>): (...args: any[]) => any {\r\n  return function (this: any, ...args: any[]) {\r\n    let result = funcs.length ? funcs[0].apply(this, args) : args[0];\r\n\r\n    for (let i = 1; i < funcs.length; i++) {\r\n      result = funcs[i].call(this, result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n}\r\n","/**\r\n * Iterates over elements of 'arr' from right to left and invokes 'callback' for each element.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to iterate over.\r\n * @param {(value: T, index: number, arr: T[]) => void} callback - The function invoked per iteration.\r\n * The callback function receives three arguments:\r\n *  - 'value': The current element being processed in the array.\r\n *  - 'index': The index of the current element being processed in the array.\r\n *  - 'arr': The array 'forEachRight' was called upon.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result: number[] = [];\r\n *\r\n * // Use the forEachRight function to iterate through the array and add each element to the result array.\r\n * forEachRight(array, (value) => {\r\n *  result.push(value);\r\n * })\r\n *\r\n * console.log(result) // Output: [3, 2, 1]\r\n */\r\nexport function forEachRight<T>(arr: T[], callback: (value: T, index: number, arr: T[]) => void): void;\r\n/**\r\n * Iterates over elements of 'arr' from right to left and invokes 'callback' for each element.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to iterate over.\r\n * @param {(value: T, index: number, arr: T[]) => void} callback - The function invoked per iteration.\r\n * The callback function receives three arguments:\r\n *  - 'value': The current element being processed in the array.\r\n *  - 'index': The index of the current element being processed in the array.\r\n *  - 'arr': The array 'forEachRight' was called upon.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result: number[] = [];\r\n *\r\n * // Use the forEachRight function to iterate through the array and add each element to the result array.\r\n * forEachRight(array, (value) => {\r\n *  result.push(value);\r\n * })\r\n *\r\n * console.log(result) // Output: [3, 2, 1]\r\n */\r\nexport function forEachRight<T>(\r\n  arr: readonly T[],\r\n  callback: (value: T, index: number, arr: readonly T[]) => void\r\n): void;\r\n\r\n/**\r\n * Iterates over elements of 'arr' from right to left and invokes 'callback' for each element.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to iterate over.\r\n * @param {(value: T, index: number, arr: T[]) => void} callback - The function invoked per iteration.\r\n * The callback function receives three arguments:\r\n *  - 'value': The current element being processed in the array.\r\n *  - 'index': The index of the current element being processed in the array.\r\n *  - 'arr': The array 'forEachRight' was called upon.\r\n *\r\n * @example\r\n * const array = [1, 2, 3];\r\n * const result: number[] = [];\r\n *\r\n * // Use the forEachRight function to iterate through the array and add each element to the result array.\r\n * forEachRight(array, (value) => {\r\n *  result.push(value);\r\n * })\r\n *\r\n * console.log(result) // Output: [3, 2, 1]\r\n */\r\nexport function forEachRight<T>(arr: readonly T[], callback: (value: T, index: number, arr: T[]) => void): void {\r\n  for (let i = arr.length - 1; i >= 0; i--) {\r\n    const element = arr[i];\r\n    callback(element, i, arr as T[]);\r\n  }\r\n}\r\n","import { isArrayLike } from '../predicate/isArrayLike.ts';\r\n\r\n/**\r\n * Converts an array of key-value pairs into an object.\r\n *\r\n * @param {any[]} pairs - An array of key-value pairs where each key is a `PropertyKey` and each value is of type `U`.\r\n * @returns {Record<string, any>} - An object where the keys are from the first element and values are from the second element.\r\n *\r\n * @example\r\n * const pairs = [['a', 1], ['b', 2]];\r\n * const result = fromPairs(pairs);\r\n * // result will be: { a: 1, b: 2 }\r\n */\r\nexport function fromPairs(pairs: readonly any[]): Record<string, any>;\r\n/**\r\n * Converts an array of key-value pairs into an object.\r\n *\r\n * @template T - The type of the keys in the resulting object. It must extend `PropertyKey`.\r\n * @template U - The type of the values in the resulting object.\r\n *\r\n * @param {Array<[T, U]>} pairs - An array of key-value pairs where each key is a `PropertyKey` and each value is of type `U`.\r\n * @returns {Record<T, U>} - An object where the keys are of type `T` and the values are of type `U`.\r\n *\r\n * @example\r\n * const pairs = [['a', 1], ['b', 2]];\r\n * const result = fromPairs(pairs);\r\n * // result will be: { a: 1, b: 2 }\r\n */\r\nexport function fromPairs<T extends PropertyKey, U>(pairs: ReadonlyArray<[T, U]> | Map<T, U>): Record<T, U>;\r\n/**\r\n * Converts an array of key-value pairs into an object.\r\n *\r\n * @template T - The type of the keys in the resulting object. It must extend `PropertyKey`.\r\n * @template U - The type of the values in the resulting object.\r\n *\r\n * @param {Array<[T, U]>} pairs - An array of key-value pairs where each key is a `PropertyKey` and each value is of type `U`.\r\n * @returns {Record<T, U>} - An object where the keys are of type `T` and the values are of type `U`.\r\n *\r\n * @example\r\n * const pairs = [['a', 1], ['b', 2]];\r\n * const result = fromPairs(pairs);\r\n * // result will be: { a: 1, b: 2 }\r\n */\r\nexport function fromPairs<T extends PropertyKey, U>(pairs: ReadonlyArray<[T, U]> | Map<T, U>): Record<T, U> {\r\n  if (!isArrayLike(pairs) && !(pairs instanceof Map)) {\r\n    return {} as Record<T, U>;\r\n  }\r\n\r\n  const result = {} as Record<T, U>;\r\n\r\n  for (const [key, value] of pairs) {\r\n    result[key as T] = value;\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Groups the elements of an array based on a provided key-generating function.\r\n *\r\n * This function takes an array and a function that generates a key from each element. It returns\r\n * an object where the keys are the generated keys and the values are arrays of elements that share\r\n * the same key.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @template K - The type of keys.\r\n * @param {T[]} arr - The array to group.\r\n * @param {(item: T) => K} getKeyFromItem - A function that generates a key from an element.\r\n * @returns {Record<K, T[]>} An object where each key is associated with an array of elements that\r\n * share that key.\r\n *\r\n * @example\r\n * const array = [\r\n *   { category: 'fruit', name: 'apple' },\r\n *   { category: 'fruit', name: 'banana' },\r\n *   { category: 'vegetable', name: 'carrot' }\r\n * ];\r\n * const result = groupBy(array, item => item.category);\r\n * // result will be:\r\n * // {\r\n * //   fruit: [\r\n * //     { category: 'fruit', name: 'apple' },\r\n * //     { category: 'fruit', name: 'banana' }\r\n * //   ],\r\n * //   vegetable: [\r\n * //     { category: 'vegetable', name: 'carrot' }\r\n * //   ]\r\n * // }\r\n */\r\nexport function groupBy<T, K extends PropertyKey>(arr: readonly T[], getKeyFromItem: (item: T) => K): Record<K, T[]> {\r\n  const result = Object.create(null) as Record<K, T[]>;\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const item = arr[i];\r\n    const key = getKeyFromItem(item);\r\n\r\n    if (result[key] == null) {\r\n      result[key] = [];\r\n    }\r\n\r\n    result[key].push(item);\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { inRange as inRangeToolkit } from '../../math/inRange.ts';\r\n\r\n/**\r\n * Checks if the value is less than the maximum.\r\n *\r\n * @param {number} value The value to check.\r\n * @param {number} maximum The upper bound of the range (exclusive).\r\n * @returns {boolean} `true` if the value is less than the maximum, otherwise `false`.\r\n *\r\n * @example\r\n * const result = inRange(3, 5); // result will be true.\r\n * const result2 = inRange(5, 5); // result2 will be false.\r\n */\r\nexport function inRange(value: number, maximum: number): boolean;\r\n\r\n/**\r\n * Checks if the value is within the range defined by minimum (inclusive) and maximum (exclusive).\r\n *\r\n * @param {number} value The value to check.\r\n * @param {number} minimum The lower bound of the range (inclusive).\r\n * @param {number} maximum The upper bound of the range (exclusive).\r\n * @returns {boolean} `true` if the value is within the specified range, otherwise `false`.\r\n *\r\n * @example\r\n * const result = inRange(3, 2, 5); // result will be true.\r\n * const result2 = inRange(1, 2, 5); // result2 will be false.\r\n */\r\nexport function inRange(value: number, minimum: number, maximum: number): boolean;\r\n\r\n/**\r\n * Checks if the value is within a specified range.\r\n *\r\n * @param {number} value The value to check.\r\n * @param {number} minimum The lower bound of the range (inclusive).\r\n * @param {number} maximum The upper bound of the range (exclusive).\r\n * @returns {boolean} `true` if the value is within the specified range, otherwise `false`.\r\n * @throws {Error} Throws an error if the `minimum` is greater or equal than the `maximum`.\r\n *\r\n * @example\r\n * const result1 = inRange(3, 5); // result1 will be true.\r\n * const result2 = inRange(1, 2, 5); // result2 will be false.\r\n * const result3 = inRange(1, 5, 2); // If the minimum is greater or equal than the maximum, an error is thrown.\r\n */\r\nexport function inRange(value: number, minimum: number, maximum?: number): boolean {\r\n  if (!minimum) {\r\n    minimum = 0;\r\n  }\r\n\r\n  if (maximum != null && !maximum) {\r\n    maximum = 0;\r\n  }\r\n\r\n  if (minimum != null && typeof minimum !== 'number') {\r\n    minimum = Number(minimum);\r\n  }\r\n\r\n  if (maximum == null && minimum === 0) {\r\n    return false;\r\n  }\r\n\r\n  if (maximum != null && typeof maximum !== 'number') {\r\n    maximum = Number(maximum);\r\n  }\r\n\r\n  if (maximum != null && minimum > maximum) {\r\n    [minimum, maximum] = [maximum, minimum];\r\n  }\r\n\r\n  if (minimum === maximum) {\r\n    return false;\r\n  }\r\n\r\n  return inRangeToolkit(value, minimum, maximum!);\r\n}\r\n","/**\r\n * Checks if the value is less than the maximum.\r\n *\r\n * @param {number} value The value to check.\r\n * @param {number} maximum The upper bound of the range (exclusive).\r\n * @returns {boolean} `true` if the value is less than the maximum, otherwise `false`.\r\n *\r\n * @example\r\n * const result = inRange(3, 5); // result will be true.\r\n * const result2 = inRange(5, 5); // result2 will be false.\r\n */\r\nexport function inRange(value: number, maximum: number): boolean;\r\n\r\n/**\r\n * Checks if the value is within the range defined by minimum (inclusive) and maximum (exclusive).\r\n *\r\n * @param {number} value The value to check.\r\n * @param {number} minimum The lower bound of the range (inclusive).\r\n * @param {number} maximum The upper bound of the range (exclusive).\r\n * @returns {boolean} `true` if the value is within the specified range, otherwise `false`.\r\n *\r\n * @example\r\n * const result = inRange(3, 2, 5); // result will be true.\r\n * const result2 = inRange(1, 2, 5); // result2 will be false.\r\n */\r\nexport function inRange(value: number, minimum: number, maximum: number): boolean;\r\n\r\n/**\r\n * Checks if the value is within a specified range.\r\n *\r\n * @param {number} value The value to check.\r\n * @param {number} minimum The lower bound of the range (inclusive).\r\n * @param {number} maximum The upper bound of the range (exclusive).\r\n * @returns {boolean} `true` if the value is within the specified range, otherwise `false`.\r\n * @throws {Error} Throws an error if the `minimum` is greater or equal than the `maximum`.\r\n *\r\n * @example\r\n * const result1 = inRange(3, 5); // result1 will be true.\r\n * const result2 = inRange(1, 2, 5); // result2 will be false.\r\n * const result3 = inRange(1, 5, 2); // If the minimum is greater or equal than the maximum, an error is thrown.\r\n */\r\nexport function inRange(value: number, minimum: number, maximum?: number): boolean {\r\n  if (maximum == null) {\r\n    maximum = minimum;\r\n    minimum = 0;\r\n  }\r\n\r\n  if (minimum >= maximum) {\r\n    throw new Error('The maximum value must be greater than the minimum value.');\r\n  }\r\n\r\n  return minimum <= value && value < maximum;\r\n}\r\n","/**\r\n * Finds the index of the first occurrence of a value in an array.\r\n *\r\n * This method is similar to `Array.prototype.indexOf`, but it also finds `NaN` values.\r\n * It uses strict equality (`===`) to compare elements.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @template U - The type of the value to search for.\r\n * @param {T[] | null | undefined} array - The array to search.\r\n * @param {T} searchElement - The value to search for.\r\n * @param {number} [fromIndex] - The index to start the search at.\r\n * @returns {number} The index (zero-based) of the first occurrence of the value in the array, or `-1` if the value is not found.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, NaN];\r\n * indexOf(array, 3); // => 2\r\n * indexOf(array, NaN); // => 3\r\n */\r\nexport function indexOf<T>(array: readonly T[] | null | undefined, searchElement: T, fromIndex?: number): number {\r\n  if (array == null) {\r\n    return -1;\r\n  }\r\n\r\n  // `Array.prototype.indexOf` doesn't find `NaN` values, so we need to handle that case separately.\r\n  if (Number.isNaN(searchElement)) {\r\n    fromIndex = fromIndex ?? 0;\r\n\r\n    if (fromIndex < 0) {\r\n      fromIndex = Math.max(0, array.length + fromIndex);\r\n    }\r\n\r\n    for (let i = fromIndex; i < array.length; i++) {\r\n      if (Number.isNaN(array[i])) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  // Array.prototype.indexOf already handles `fromIndex < -array.length`, `fromIndex >= array.length` and converts `fromIndex` to an integer, so we don't need to handle those cases here.\r\n  // And it uses strict equality (===) to compare elements like `lodash/indexOf` does.\r\n  return array.indexOf(searchElement as T, fromIndex);\r\n}\r\n","/**\r\n * Returns an empty array when the input is a tuple containing exactly one element.\r\n *\r\n * @template T The type of the single element.\r\n * @param {[T]} arr - A tuple containing exactly one element.\r\n * @returns {[]} An empty array since there is only one element.\r\n *\r\n * @example\r\n * const array = [100] as const;\r\n * const result = initial(array);\r\n * // result will be []\r\n */\r\nexport function initial<T>(arr: readonly [T]): [];\r\n\r\n/**\r\n * Returns an empty array when the input array is empty.\r\n *\r\n * @returns {[]} Always returns an empty array for an empty input.\r\n *\r\n * @example\r\n * const array = [] as const;\r\n * const result = initial(array);\r\n * // result will be []\r\n */\r\nexport function initial(arr: readonly []): [];\r\n\r\n/**\r\n * Returns a new array containing all elements except the last one from a tuple with multiple elements.\r\n *\r\n * @template T The types of the initial elements.\r\n * @template U The type of the last element in the tuple.\r\n * @param {[...T[], U]} arr - A tuple with one or more elements.\r\n * @returns {T[]} A new array containing all but the last element of the tuple.\r\n *\r\n * @example\r\n * const array = ['apple', 'banana', 'cherry'] as const;\r\n * const result = initial(array);\r\n * // result will be ['apple', 'banana']\r\n */\r\nexport function initial<T, U>(arr: readonly [...T[], U]): T[];\r\n\r\n/**\r\n * Returns a new array containing all elements except the last one from the input array.\r\n * If the input array is empty or has only one element, the function returns an empty array.\r\n *\r\n * @template T The type of elements in the array.\r\n * @param {T[]} arr - The input array.\r\n * @returns {T[]} A new array containing all but the last element of the input array.\r\n *\r\n * @example\r\n * const arr = [1, 2, 3, 4];\r\n * const result = initial(arr);\r\n * // result will be [1, 2, 3]\r\n */\r\nexport function initial<T>(arr: readonly T[]): T[];\r\n\r\n/**\r\n * Returns a new array containing all elements except the last one from the input array.\r\n * If the input array is empty or has only one element, the function returns an empty array.\r\n *\r\n * @template T The type of elements in the array.\r\n * @param {T[]} arr - The input array.\r\n * @returns {T[]} A new array containing all but the last element of the input array.\r\n *\r\n * @example\r\n * const arr = [1, 2, 3, 4];\r\n * const result = initial(arr);\r\n * // result will be [1, 2, 3]\r\n */\r\nexport function initial<T>(arr: readonly T[]): T[] {\r\n  return arr.slice(0, -1);\r\n}\r\n","/**\r\n * Inverts the keys and values of an object. The keys of the input object become the values of the output object and vice versa.\r\n *\r\n * This function takes an object and creates a new object by inverting its keys and values. If the input object has duplicate values,\r\n * the key of the last occurrence will be used as the value for the new key in the output object. It effectively creates a reverse mapping\r\n * of the input object's key-value pairs.\r\n *\r\n * @template K - Type of the keys in the input object (string, number, symbol)\r\n * @template V - Type of the values in the input object (string, number, symbol)\r\n * @param {Record<K, V>} obj - The input object whose keys and values are to be inverted\r\n * @returns {Record<V, K>} - A new object with keys and values inverted\r\n *\r\n * @example\r\n * invert({ a: 1, b: 2, c: 3 }); // { 1: 'a', 2: 'b', 3: 'c' }\r\n * invert({ 1: 'a', 2: 'b', 3: 'c' }); // { a: '1', b: '2', c: '3' }\r\n * invert({ a: 1, 2: 'b', c: 3, 4: 'd' }); // { 1: 'a', b: '2', 3: 'c', d: '4' }\r\n * invert({ a: Symbol('sym1'), b: Symbol('sym2') }); // { [Symbol('sym1')]: 'a', [Symbol('sym2')]: 'b' }\r\n */\r\nexport function invert<K extends PropertyKey, V extends PropertyKey>(obj: Record<K, V>): Record<V, K> {\r\n  const result = {} as Record<V, K>;\r\n\r\n  const keys = Object.keys(obj) as K[];\r\n\r\n  for (let i = 0; i < keys.length; i++) {\r\n    const key = keys[i];\r\n    const value = obj[key];\r\n    result[value] = key;\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Checks if the given value is an array.\r\n *\r\n * This function tests whether the provided value is an array or not.\r\n * It returns `true` if the value is an array, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an array.\r\n *\r\n * @param {unknown} value - The value to test if it is an array.\r\n * @returns {value is any[]} `true` if the value is an array, `false` otherwise.\r\n *\r\n * @example\r\n * const value1 = [1, 2, 3];\r\n * const value2 = 'abc';\r\n * const value3 = () => {};\r\n *\r\n * console.log(isArray(value1)); // true\r\n * console.log(isArray(value2)); // false\r\n * console.log(isArray(value3)); // false\r\n */\r\nexport function isArray(value?: unknown): value is any[] {\r\n  return Array.isArray(value);\r\n}\r\n","import { isArrayLike } from './isArrayLike';\r\nimport { isObjectLike } from './isObjectLike';\r\n\r\n/**\r\n * Checks if the given value is a non-primitive, array-like object.\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {value is ArrayLike<unknown> & object} `true` if the value is a non-primitive, array-like object, `false` otherwise.\r\n *\r\n * @example\r\n * isArrayLikeObject([1, 2, 3]); // true\r\n * isArrayLikeObject({ 0: 'a', length: 1 }); // true\r\n * isArrayLikeObject('abc'); // false\r\n * isArrayLikeObject(()=>{}); // false\r\n */\r\nexport function isArrayLikeObject(value: unknown): value is ArrayLike<unknown> & object {\r\n  return isObjectLike(value) && isArrayLike(value);\r\n}\r\n","/**\r\n * Checks if the given value is boolean.\r\n *\r\n * This function tests whether the provided value is strictly `boolean`.\r\n * It returns `true` if the value is `boolean`, and `false` otherwise.\r\n *\r\n *  This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `boolean`.\r\n *\r\n * @param {unknown} value - The Value to test if it is boolean.\r\n * @returns {value is boolean} True if the value is boolean, false otherwise.\r\n *\r\n * @example\r\n *\r\n * const value1 = true;\r\n * const value2 = 0;\r\n * const value3 = 'abc';\r\n *\r\n * console.log(isBoolean(value1)); // true\r\n * console.log(isBoolean(value2)); // false\r\n * console.log(isBoolean(value3)); // false\r\n *\r\n */\r\nexport function isBoolean(value?: unknown): value is boolean {\r\n  return typeof value === 'boolean' || value instanceof Boolean;\r\n}\r\n","/**\r\n * Checks if `value` is a Date object.\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {value is Date} Returns `true` if `value` is a Date object, `false` otherwise.\r\n *\r\n * @example\r\n * const value1 = new Date();\r\n * const value2 = '2024-01-01';\r\n *\r\n * console.log(isDate(value1)); // true\r\n * console.log(isDate(value2)); // false\r\n */\r\nexport function isDate(value: unknown): value is Date {\r\n  return value instanceof Date;\r\n}\r\n","import { getTag } from '../_internal/getTag';\r\n\r\n/**\r\n * Checks if `value` is an Error object.\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {value is Error} Returns `true` if `value` is an Error object, `false` otherwise.\r\n *\r\n * @example\r\n * ```typescript\r\n * console.log(isError(new Error())); // true\r\n * console.log(isError('Error')); // false\r\n * console.log(isError({ name: 'Error', message: '' })); // false\r\n * ```\r\n */\r\nexport function isError(value?: unknown): value is Error {\r\n  return getTag(value) === '[object Error]';\r\n}\r\n","/**\r\n * Checks if `value` is a finite number.\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {value is number} Returns `true` if `value` is a finite number, `false` otherwise.\r\n *\r\n * @example\r\n * ```typescript\r\n * const value1 = 100;\r\n * const value2 = Infinity;\r\n * const value3 = '100';\r\n *\r\n * console.log(isFinite(value1)); // true\r\n * console.log(isFinite(value2)); // false\r\n * console.log(isFinite(value3)); // false\r\n * ```\r\n */\r\nexport function isFinite(value: unknown): value is number {\r\n  return Number.isFinite(value);\r\n}\r\n","/**\r\n * Checks if `value` is a function.\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\r\n *\r\n * @example\r\n * isFunction(Array.prototype.slice); // true\r\n * isFunction(async function () {}); // true\r\n * isFunction(function* () {}); // true\r\n * isFunction(Proxy); // true\r\n * isFunction(Int8Array); // true\r\n */\r\nexport function isFunction(value: unknown): value is (...args: unknown[]) => unknown {\r\n  return typeof value === 'function';\r\n}\r\n","/**\r\n * Checks if `value` is an integer.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `number`.\r\n *\r\n * @param {unknown} value - The value to check\r\n * @returns {boolean} `true` if `value` is integer, otherwise `false`.\r\n *\r\n * @example\r\n * isInteger(3); // Returns: true\r\n * isInteger(Infinity); // Returns: false\r\n * isInteger('3'); // Returns: false\r\n * isInteger([]); // Returns: false\r\n */\r\nexport function isInteger(value?: unknown): value is number {\r\n  return Number.isInteger(value);\r\n}\r\n","/**\r\n * Checks if a given value is `Map`.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `Map`.\r\n *\r\n * @param {unknown} value The value to check if it is a `Map`.\r\n * @returns {value is Map<any, any>} Returns `true` if `value` is a `Map`, else `false`.\r\n *\r\n * @example\r\n * const value1 = new Map();\r\n * const value2 = new Set();\r\n * const value3 = new WeakMap();\r\n *\r\n * console.log(isMap(value1)); // true\r\n * console.log(isMap(value2)); // false\r\n * console.log(isMap(value3)); // false\r\n */\r\n\r\nexport function isMap(value: unknown): value is Map<any, any> {\r\n  return value instanceof Map;\r\n}\r\n","/**\r\n * Checks if the value is NaN.\r\n *\r\n * @param {unknown} value - The value to check.\r\n * @returns {value is typeof NaN} `true` if the value is NaN, `false` otherwise.\r\n *\r\n * @example\r\n * isNaN(NaN); // true\r\n * isNaN(0); // false\r\n * isNaN('NaN'); // false\r\n * isNaN(undefined); // false\r\n */\r\nexport function isNaN(value: unknown): value is typeof NaN {\r\n  return Number.isNaN(value);\r\n}\r\n","/**\r\n * Checks if the given value is not null nor undefined.\r\n *\r\n * The main use of this function is to be used with TypeScript as a type predicate.\r\n *\r\n * @template T - The type of value.\r\n * @param {T | null | undefined} x - The value to test if it is not null nor undefined.\r\n * @returns {x is T} True if the value is not null nor undefined, false otherwise.\r\n *\r\n * @example\r\n * // Here the type of `arr` is (number | undefined)[]\r\n * const arr = [1, undefined, 3];\r\n * // Here the type of `result` is number[]\r\n * const result = arr.filter(isNotNil);\r\n * // result will be [1, 3]\r\n */\r\nexport function isNotNil<T>(x: T | null | undefined): x is T {\r\n  return x != null;\r\n}\r\n","/**\r\n * Checks if the given value is null.\r\n *\r\n * This function tests whether the provided value is strictly equal to `null`.\r\n * It returns `true` if the value is `null`, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null`.\r\n *\r\n * @param {unknown} x - The value to test if it is null.\r\n * @returns {x is null} True if the value is null, false otherwise.\r\n *\r\n * @example\r\n * const value1 = null;\r\n * const value2 = undefined;\r\n * const value3 = 42;\r\n *\r\n * console.log(isNull(value1)); // true\r\n * console.log(isNull(value2)); // false\r\n * console.log(isNull(value3)); // false\r\n */\r\nexport function isNull(x: unknown): x is null {\r\n  return x === null;\r\n}\r\n","/**\r\n * Checks if a given value is a number.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `number`.\r\n *\r\n * @param {unknown} value The value to check if it is a number.\r\n * @returns {value is number} Returns `true` if `value` is a number, else `false`.\r\n *\r\n * @example\r\n * const value1 = 123;\r\n * const value2 = 'abc';\r\n * const value3 = true;\r\n *\r\n * console.log(isNumber(value1)); // true\r\n * console.log(isNumber(value2)); // false\r\n * console.log(isNumber(value3)); // false\r\n */\r\nexport function isNumber(value?: unknown): value is number {\r\n  return typeof value === 'number' || value instanceof Number;\r\n}\r\n","/**\r\n * Checks if the given value is an object. An object is a value that is\r\n * not a primitive type (string, number, boolean, symbol, null, or undefined).\r\n *\r\n * This function tests whether the provided value is an object or not.\r\n * It returns `true` if the value is an object, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an object value.\r\n *\r\n * @param {unknown} value - The value to check if it is an object.\r\n * @returns {value is object} `true` if the value is an object, `false` otherwise.\r\n *\r\n * @example\r\n * const value1 = {};\r\n * const value2 = [1, 2, 3];\r\n * const value3 = () => {};\r\n * const value4 = null;\r\n *\r\n * console.log(isObject(value1)); // true\r\n * console.log(isObject(value2)); // true\r\n * console.log(isObject(value3)); // true\r\n * console.log(isObject(value4)); // false\r\n */\r\n\r\nexport function isObject(value: unknown): value is object {\r\n  return value !== null && (typeof value === 'object' || typeof value === 'function');\r\n}\r\n","import { isRegExp as isRegExpToolkit } from '../../predicate/isRegExp';\r\n\r\n/**\r\n * Checks if `value` is a RegExp.\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a RegExp, `false` otherwise.\r\n *\r\n * @example\r\n * const value1 = /abc/;\r\n * const value2 = '/abc/';\r\n *\r\n * console.log(isRegExp(value1)); // true\r\n * console.log(isRegExp(value2)); // false\r\n */\r\nexport function isRegExp(value?: unknown): value is RegExp {\r\n  return isRegExpToolkit(value);\r\n}\r\n","/**\r\n * Checks if `value` is a RegExp.\r\n *\r\n * @param {unknown} value The value to check.\r\n * @returns {value is RegExp} Returns `true` if `value` is a RegExp, `false` otherwise.\r\n *\r\n * @example\r\n * const value1 = /abc/;\r\n * const value2 = '/abc/';\r\n *\r\n * console.log(isRegExp(value1)); // true\r\n * console.log(isRegExp(value2)); // false\r\n */\r\nexport function isRegExp(value: unknown): value is RegExp {\r\n  return value instanceof RegExp;\r\n}\r\n","/**\r\n * Checks if `value` is a safe integer (between -(2^53 – 1) and (2^53 – 1), inclusive).\r\n *\r\n * A safe integer is an integer that can be precisely represented as a `number` in JavaScript,\r\n * without any other integer being rounded to it.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `number`.\r\n *\r\n * @param {unknown} value - The value to check\r\n * @returns {boolean} `true` if `value` is an integer and between the safe values, otherwise `false`\r\n *\r\n * @example\r\n * isSafeInteger(3); // Returns: true\r\n * isSafeInteger(Number.MIN_SAFE_INTEGER - 1); // Returns: false\r\n * isSafeInteger(1n); // Returns: false\r\n * isSafeInteger('1'); // Returns: false\r\n */\r\nexport function isSafeInteger(value?: unknown): value is number {\r\n  return Number.isSafeInteger(value);\r\n}\r\n","/**\r\n * Checks if a given value is `Set`.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `string`.\r\n *\r\n * @param {unknown} value The value to check if it is a `Set`.\r\n * @returns {value is Set<any>} Returns `true` if `value` is a `Set`, else `false`.\r\n *\r\n * @example\r\n * const value1 = new Set();\r\n * const value2 = new Map();\r\n * const value3 = new WeakSet();\r\n *\r\n * console.log(isSet(value1)); // true\r\n * console.log(isSet(value2)); // false\r\n * console.log(isSet(value3)); // false\r\n */\r\n\r\nexport function isSet(value: unknown): value is Set<any> {\r\n  return value instanceof Set;\r\n}\r\n","/**\r\n * Checks if a given value is string.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `string`.\r\n *\r\n * @param {unknown} value The value to check if it is string.\r\n * @returns {value is string} Returns `true` if `value` is a string, else `false`.\r\n *\r\n * @example\r\n * const value1 = 'abc';\r\n * const value2 = 123;\r\n * const value3 = true;\r\n *\r\n * console.log(isString(value1)); // true\r\n * console.log(isString(value2)); // false\r\n * console.log(isString(value3)); // false\r\n */\r\n\r\nexport function isString(value?: unknown): value is string {\r\n  return typeof value === 'string' || value instanceof String;\r\n}\r\n","import { difference } from '../array/difference.ts';\r\n\r\n/**\r\n * Checks if the `subset` array is entirely contained within the `superset` array.\r\n *\r\n *\r\n * @template T - The type of elements contained in the arrays.\r\n * @param {T[]} superset - The array that may contain all elements of the subset.\r\n * @param {T[]} subset - The array to check against the superset.\r\n * @returns {boolean} - Returns `true` if all elements of the `subset` are present in the `superset`, otherwise returns `false`.\r\n *\r\n * @example\r\n * ```typescript\r\n * const superset = [1, 2, 3, 4, 5];\r\n * const subset = [2, 3, 4];\r\n * isSubset(superset, subset); // true\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * const superset = ['a', 'b', 'c'];\r\n * const subset = ['a', 'd'];\r\n * isSubset(superset, subset); // false\r\n * ```\r\n */\r\n\r\nexport function isSubset<T>(superset: readonly T[], subset: readonly T[]): boolean {\r\n  return difference(subset, superset).length === 0;\r\n}\r\n","/**\r\n * Checks if the given value is undefined.\r\n *\r\n * This function tests whether the provided value is strictly equal to `undefined`.\r\n * It returns `true` if the value is `undefined`, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `undefined`.\r\n *\r\n * @param {unknown} x - The value to test if it is undefined.\r\n * @returns {x is undefined} true if the value is undefined, false otherwise.\r\n *\r\n * @example\r\n * const value1 = undefined;\r\n * const value2 = null;\r\n * const value3 = 42;\r\n *\r\n * console.log(isUndefined(value1)); // true\r\n * console.log(isUndefined(value2)); // false\r\n * console.log(isUndefined(value3)); // false\r\n */\r\nexport function isUndefined(x: unknown): x is undefined {\r\n  return x === undefined;\r\n}\r\n","import { isWeakMap as isWeakMapToolkit } from '../../predicate/isWeakMap.ts';\r\n\r\n/**\r\n * Checks if the given value is a `WeakMap`.\r\n *\r\n * This function tests whether the provided value is an instance of `WeakMap`.\r\n * It returns `true` if the value is a `WeakMap`, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `WeakMap`.\r\n *\r\n * @param {unknown} value - The value to test if it is a `WeakMap`.\r\n * @returns {value is WeakMap<WeakKey, any>} true if the value is a `WeakMap`, false otherwise.\r\n *\r\n * @example\r\n * const value1 = new WeakMap();\r\n * const value2 = new Map();\r\n * const value3 = new Set();\r\n *\r\n * console.log(isWeakMap(value1)); // true\r\n * console.log(isWeakMap(value2)); // false\r\n * console.log(isWeakMap(value3)); // false\r\n */\r\nexport function isWeakMap(value?: unknown): value is WeakMap<WeakKey, any> {\r\n  return isWeakMapToolkit(value);\r\n}\r\n","/**\r\n * Checks if the given value is a `WeakMap`.\r\n *\r\n * This function tests whether the provided value is an instance of `WeakMap`.\r\n * It returns `true` if the value is a `WeakMap`, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `WeakMap`.\r\n *\r\n * @param {unknown} value - The value to test if it is a `WeakMap`.\r\n * @returns {value is WeakMap<WeakKey, any>} true if the value is a `WeakMap`, false otherwise.\r\n *\r\n * @example\r\n * const value1 = new WeakMap();\r\n * const value2 = new Map();\r\n * const value3 = new Set();\r\n *\r\n * console.log(isWeakMap(value1)); // true\r\n * console.log(isWeakMap(value2)); // false\r\n * console.log(isWeakMap(value3)); // false\r\n */\r\nexport function isWeakMap(value: unknown): value is WeakMap<WeakKey, any> {\r\n  return value instanceof WeakMap;\r\n}\r\n","import { isWeakSet as isWeakSetToolkit } from '../../predicate/isWeakSet.ts';\r\n\r\n/**\r\n * Checks if the given value is a `WeakSet`.\r\n *\r\n * This function tests whether the provided value is an instance of `WeakSet`.\r\n * It returns `true` if the value is a `WeakSet`, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `WeakSet`.\r\n *\r\n * @param {unknown} value - The value to test if it is a `WeakSet`.\r\n * @returns {value is WeakSet<WeakKey>} true if the value is a `WeakSet`, false otherwise.\r\n *\r\n * @example\r\n * const value1 = new WeakSet();\r\n * const value2 = new Map();\r\n * const value3 = new Set();\r\n *\r\n * console.log(isWeakSet(value1)); // true\r\n * console.log(isWeakSet(value2)); // false\r\n * console.log(isWeakSet(value3)); // false\r\n */\r\nexport function isWeakSet(value?: unknown): value is WeakSet<WeakKey> {\r\n  return isWeakSetToolkit(value);\r\n}\r\n","/**\r\n * Checks if the given value is a `WeakSet`.\r\n *\r\n * This function tests whether the provided value is an instance of `WeakSet`.\r\n * It returns `true` if the value is a `WeakSet`, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `WeakSet`.\r\n *\r\n * @param {unknown} value - The value to test if it is a `WeakSet`.\r\n * @returns {value is WeakSet<WeakKey>} true if the value is a `WeakSet`, false otherwise.\r\n *\r\n * @example\r\n * const value1 = new WeakSet();\r\n * const value2 = new Map();\r\n * const value3 = new Set();\r\n *\r\n * console.log(isWeakSet(value1)); // true\r\n * console.log(isWeakSet(value2)); // false\r\n * console.log(isWeakSet(value3)); // false\r\n */\r\nexport function isWeakSet(value: unknown): value is WeakSet<WeakKey> {\r\n  return value instanceof WeakSet;\r\n}\r\n","/**\r\n * Joins elements of an array into a string.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} array - The array to join.\r\n * @param {string} separator - The separator used to join the elements, default is common separator `,`.\r\n * @returns {string} - Returns a string containing all elements of the array joined by the specified separator.\r\n *\r\n * @example\r\n * const arr = [\"a\", \"b\", \"c\"];\r\n * const result = join(arr, \"~\");\r\n * console.log(result); // Output: \"a~b~c\"\r\n */\r\nexport function join<T>(array: readonly T[], separator = ','): string {\r\n  return array.join(separator);\r\n}\r\n","import { kebabCase as kebabCaseToolkit } from '../../string/kebabCase.ts';\r\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\r\n\r\n/**\r\n * Converts a string to kebab case.\r\n *\r\n * Kebab case is the naming convention in which each word is written in lowercase and separated by a dash (-) character.\r\n *\r\n * @param {string | object} str - The string that is to be changed to kebab case.\r\n * @returns {string} - The converted string to kebab case.\r\n *\r\n * @example\r\n * const convertedStr1 = kebabCase('camelCase') // returns 'camel-case'\r\n * const convertedStr2 = kebabCase('some whitespace') // returns 'some-whitespace'\r\n * const convertedStr3 = kebabCase('hyphen-text') // returns 'hyphen-text'\r\n * const convertedStr4 = kebabCase('HTTPRequest') // returns 'http-request'\r\n */\r\nexport function kebabCase(str?: string | object): string {\r\n  return kebabCaseToolkit(normalizeForCase(str));\r\n}\r\n","import { getWords } from './_internal/getWords.ts';\r\n\r\n/**\r\n * Converts a string to kebab case.\r\n *\r\n * Kebab case is the naming convention in which each word is written in lowercase and separated by a dash (-) character.\r\n *\r\n * @param {string} str - The string that is to be changed to kebab case.\r\n * @returns {string} - The converted string to kebab case.\r\n *\r\n * @example\r\n * const convertedStr1 = kebabCase('camelCase') // returns 'camel-case'\r\n * const convertedStr2 = kebabCase('some whitespace') // returns 'some-whitespace'\r\n * const convertedStr3 = kebabCase('hyphen-text') // returns 'hyphen-text'\r\n * const convertedStr4 = kebabCase('HTTPRequest') // returns 'http-request'\r\n */\r\n\r\nexport function kebabCase(str: string): string {\r\n  const words = getWords(str);\r\n  return words.map(word => word.toLowerCase()).join('-');\r\n}\r\n","/**\r\n * Maps each element of an array based on a provided key-generating function.\r\n *\r\n * This function takes an array and a function that generates a key from each element. It returns\r\n * an object where the keys are the generated keys and the values are the corresponding elements.\r\n * If there are multiple elements generating the same key, the last element among them is used\r\n * as the value.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @template K - The type of keys.\r\n * @param {T[]} arr - The array of elements to be mapped.\r\n * @param {(item: T) => K} getKeyFromItem - A function that generates a key from an element.\r\n * @returns {Record<K, T>} An object where keys are mapped to each element of an array.\r\n *\r\n * @example\r\n * const array = [\r\n *   { category: 'fruit', name: 'apple' },\r\n *   { category: 'fruit', name: 'banana' },\r\n *   { category: 'vegetable', name: 'carrot' }\r\n * ];\r\n * const result = keyBy(array, item => item.category);\r\n * // result will be:\r\n * // {\r\n * //   fruit: { category: 'fruit', name: 'banana' },\r\n * //   vegetable: { category: 'vegetable', name: 'carrot' }\r\n * // }\r\n */\r\nexport function keyBy<T, K extends PropertyKey>(arr: readonly T[], getKeyFromItem: (item: T) => K): Record<K, T> {\r\n  const result = {} as Record<K, T>;\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const item = arr[i];\r\n    const key = getKeyFromItem(item);\r\n    result[key] = item;\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Returns the last element of an array.\r\n *\r\n * This function takes an array and returns the last element of the array.\r\n * If the array is empty, the function returns `undefined`.\r\n *\r\n * Unlike some implementations, this function is optimized for performance\r\n * by directly accessing the last index of the array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {[...T[], T]} arr - The array from which to get the last element.\r\n * @returns {T} The last element of the array, or `undefined` if the array is empty.\r\n *\r\n * @example\r\n * const arr = [1, 2, 3];\r\n * const lastElement = last(arr);\r\n * // lastElement will be 3\r\n *\r\n * const emptyArr: number[] = [];\r\n * const noElement = last(emptyArr);\r\n * // noElement will be undefined\r\n */\r\nexport function last<T>(arr: readonly [...T[], T]): T;\r\n\r\n/**\r\n * Returns the last element of an array.\r\n *\r\n * This function takes an array and returns the last element of the array.\r\n * If the array is empty, the function returns `undefined`.\r\n *\r\n * Unlike some implementations, this function is optimized for performance\r\n * by directly accessing the last index of the array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array from which to get the last element.\r\n * @returns {T | undefined} The last element of the array, or `undefined` if the array is empty.\r\n *\r\n * @example\r\n * const arr = [1, 2, 3];\r\n * const lastElement = last(arr);\r\n * // lastElement will be 3\r\n *\r\n * const emptyArr: number[] = [];\r\n * const noElement = last(emptyArr);\r\n * // noElement will be undefined\r\n */\r\nexport function last<T>(arr: readonly T[]): T | undefined;\r\n\r\n/**\r\n * Returns the last element of an array.\r\n *\r\n * This function takes an array and returns the last element of the array.\r\n * If the array is empty, the function returns `undefined`.\r\n *\r\n * Unlike some implementations, this function is optimized for performance\r\n * by directly accessing the last index of the array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array from which to get the last element.\r\n * @returns {T | undefined} The last element of the array, or `undefined` if the array is empty.\r\n *\r\n * @example\r\n * const arr = [1, 2, 3];\r\n * const lastElement = last(arr);\r\n * // lastElement will be 3\r\n *\r\n * const emptyArr: number[] = [];\r\n * const noElement = last(emptyArr);\r\n * // noElement will be undefined\r\n */\r\nexport function last<T>(arr: readonly T[]): T | undefined {\r\n  return arr[arr.length - 1];\r\n}\r\n","import { lowerCase as lowerCaseToolkit } from '../../string/lowerCase.ts';\r\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\r\n\r\n/**\r\n * Converts a string to lower case.\r\n *\r\n * Lower case is the naming convention in which each word is written in lowercase and separated by an space ( ) character.\r\n *\r\n * @param {string | object} str - The string that is to be changed to lower case.\r\n * @returns {string} - The converted string to lower case.\r\n *\r\n * @example\r\n * const convertedStr1 = lowerCase('camelCase') // returns 'camel case'\r\n * const convertedStr2 = lowerCase('some whitespace') // returns 'some whitespace'\r\n * const convertedStr3 = lowerCase('hyphen-text') // returns 'hyphen text'\r\n * const convertedStr4 = lowerCase('HTTPRequest') // returns 'http request'\r\n */\r\nexport function lowerCase(str?: string | object): string {\r\n  return lowerCaseToolkit(normalizeForCase(str));\r\n}\r\n","import { getWords } from './_internal/getWords.ts';\r\n\r\n/**\r\n * Converts a string to lower case.\r\n *\r\n * Lower case is the naming convention in which each word is written in lowercase and separated by an space ( ) character.\r\n *\r\n * @param {string} str - The string that is to be changed to lower case.\r\n * @returns {string} - The converted string to lower case.\r\n *\r\n * @example\r\n * const convertedStr1 = lowerCase('camelCase') // returns 'camel case'\r\n * const convertedStr2 = lowerCase('some whitespace') // returns 'some whitespace'\r\n * const convertedStr3 = lowerCase('hyphen-text') // returns 'hyphen text'\r\n * const convertedStr4 = lowerCase('HTTPRequest') // returns 'http request'\r\n */\r\nexport function lowerCase(str: string): string {\r\n  const words = getWords(str);\r\n  return words.map(word => word.toLowerCase()).join(' ');\r\n}\r\n","/**\r\n * Converts the first character of string to lower case.\r\n *\r\n * @param {string} str - The string that is to be changed\r\n * @returns {string} - The converted string.\r\n *\r\n * @example\r\n * const convertedStr1 = lowerCase('fred') // returns 'fred'\r\n * const convertedStr2 = lowerCase('Fred') // returns 'fred'\r\n * const convertedStr3 = lowerCase('FRED') // returns 'fRED'\r\n */\r\nexport function lowerFirst(str: string): string {\r\n  return str.substring(0, 1).toLowerCase() + str.substring(1);\r\n}\r\n","import { mapKeys as mapKeysToolkit } from '../../object/mapKeys.ts';\r\nimport { identity } from '../_internal/identity.ts';\r\nimport { property } from './property.ts';\r\n\r\n/**\r\n * Creates a new object with the same values as the given object, but with keys generated\r\n * by running each own enumerable property of the object through the iteratee function.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the keys in the object.\r\n *\r\n * @param {T} object - The object to iterate over.\r\n * @param {PropertyKey | PropertyKey[]} getNewKey - The path of the property to get to generate the new keys.\r\n * @returns {Record<PropertyKey, T[K1]>} - Returns the new mapped object.\r\n *\r\n * @example\r\n * // Example usage:\r\n * const obj = { a: 1, b: 2 };\r\n * const result = mapKeys(obj, (value, key) => key + value);\r\n * console.log(result); // { a1: 1, b2: 2 }\r\n */\r\nexport function mapKeys<T extends object>(\r\n  object: T,\r\n  getNewKey?: PropertyKey | readonly PropertyKey[]\r\n): Record<PropertyKey, T[keyof T]>;\r\n\r\n/**\r\n * Creates a new object with the same values as the given object, but with keys generated\r\n * by running each own enumerable property of the object through the iteratee function.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the keys in the object.\r\n * @template K2 - The type of the new keys generated by the iteratee function.\r\n *\r\n * @param {T} object - The object to iterate over.\r\n * @param {(value: T[K1], key: K1, object: T) => K2} getNewKey - The function invoked per own enumerable property.\r\n * @returns {Record<K2, T[K1]>} - Returns the new mapped object.\r\n *\r\n * @example\r\n * // Example usage:\r\n * const obj = { a: 1, b: 2 };\r\n * const result = mapKeys(obj, (value, key) => key + value);\r\n * console.log(result); // { a1: 1, b2: 2 }\r\n */\r\nexport function mapKeys<T extends object, K1 extends keyof T, K2 extends PropertyKey>(\r\n  object: T,\r\n  getNewKey?: (value: T[K1], key: K1, object: T) => K2\r\n): Record<K2, T[K1]>;\r\n\r\n/**\r\n * Creates a new object with the same values as the given object, but with keys generated\r\n * by running each own enumerable property of the object through the iteratee function.\r\n *\r\n * @template T - The type of the object.\r\n * @template K1 - The type of the keys in the object.\r\n * @template K2 - The type of the new keys generated by the iteratee function.\r\n *\r\n * @param {T} object - The object to iterate over.\r\n * @param {(value: T[K1], key: K1, object: T) => K2} [getNewKey] - The function invoked per own enumerable property, or a path to generate new keys.\r\n * @returns {Record<K2, T[K1]>} - Returns the new mapped object.\r\n *\r\n * @example\r\n * // Example usage:\r\n * const obj = { a: 1, b: 2 };\r\n * const result = mapKeys(obj, (value, key) => key + value);\r\n * console.log(result); // { a1: 1, b2: 2 }\r\n */\r\nexport function mapKeys<T extends object, K1 extends keyof T, K2 extends PropertyKey>(\r\n  object: T,\r\n  getNewKey?: PropertyKey | readonly PropertyKey[] | ((value: T[K1], key: K1, object: T) => K2)\r\n): Record<K2, T[K1]> {\r\n  getNewKey = getNewKey ?? (identity as (value: T[K1], key: K1, object: T) => K2);\r\n\r\n  switch (typeof getNewKey) {\r\n    case 'string':\r\n    case 'symbol':\r\n    case 'number':\r\n    case 'object': {\r\n      return mapKeysToolkit(object, property(getNewKey));\r\n    }\r\n    case 'function': {\r\n      return mapKeysToolkit(object, getNewKey);\r\n    }\r\n  }\r\n}\r\n","import { mapValues as mapValuesToolkit } from '../../object/mapValues.ts';\r\nimport { identity } from '../_internal/identity.ts';\r\nimport { property } from './property.ts';\r\n\r\n/**\r\n * Creates a new object with the same keys as the given object, but with values generated\r\n * by running each own enumerable property of the object through the iteratee function.\r\n *\r\n * @template T - The type of the object.\r\n * @template K - The type of the keys in the object.\r\n * @template V - The type of the new values generated by the iteratee function.\r\n *\r\n * @param {T} object - The object to iterate over.\r\n * @param {(value: T[K], key: K, object: T) => V} getNewValue - The function invoked per own enumerable property.\r\n * @returns {Record<K, V>} - Returns the new mapped object.\r\n *\r\n * @example\r\n * // Example usage:\r\n * const obj = { a: 1, b: 2 };\r\n * const result = mapValues(obj, (value) => value * 2);\r\n * console.log(result); // { a: 2, b: 4 }\r\n */\r\nexport function mapValues<T extends object, K extends keyof T, V>(\r\n  object: T,\r\n  getNewValue?: PropertyKey | readonly PropertyKey[] | null | undefined\r\n): Record<K, V>;\r\n\r\n/**\r\n * Creates a new object with the same keys as the given object, but with values generated\r\n * by running each own enumerable property of the object through the iteratee function.\r\n *\r\n * @template T - The type of the object.\r\n * @template K - The type of the keys in the object.\r\n * @template V - The type of the new values generated by the iteratee function.\r\n *\r\n * @param {T} object - The object to iterate over.\r\n * @param {(value: T[K], key: K, object: T) => V} getNewValue - The function invoked per own enumerable property.\r\n * @returns {Record<K, V>} - Returns the new mapped object.\r\n *\r\n * @example\r\n * // Example usage:\r\n * const obj = { a: 1, b: 2 };\r\n * const result = mapValues(obj, (value) => value * 2);\r\n * console.log(result); // { a: 2, b: 4 }\r\n */\r\nexport function mapValues<T extends object, K extends keyof T, V>(\r\n  object: T,\r\n  getNewValue: (value: T[K], key: K, object: T) => V\r\n): Record<K, V>;\r\n\r\n/**\r\n * Creates a new object with the same keys as the given object, but with values generated\r\n * by running each own enumerable property of the object through the iteratee function.\r\n *\r\n * @template T - The type of the object.\r\n * @template K - The type of the keys in the object.\r\n * @template V - The type of the new values generated by the iteratee function.\r\n *\r\n * @param {T} object - The object to iterate over.\r\n * @param {(value: T[K], key: K, object: T) => V | PropertyKey | readonly PropertyKey[] | null | undefined} [getNewValue] -\r\n *        The function invoked per own enumerable property, or a path to generate new values.\r\n * @returns {Record<K, V>} - Returns the new mapped object.\r\n *\r\n * @example\r\n * // Example usage:\r\n * const obj = { a: 1, b: 2 };\r\n * const result = mapValues(obj, (value) => value * 2);\r\n * console.log(result); // { a: 2, b: 4 }\r\n */\r\nexport function mapValues<T extends object, K extends keyof T, V>(\r\n  object: T,\r\n  getNewValue?: PropertyKey | readonly PropertyKey[] | null | undefined | ((value: T[K], key: K, object: T) => V)\r\n): Record<K, V> {\r\n  getNewValue = getNewValue ?? (identity as (value: T[K], key: K, object: T) => V);\r\n\r\n  switch (typeof getNewValue) {\r\n    case 'string':\r\n    case 'symbol':\r\n    case 'number':\r\n    case 'object': {\r\n      return mapValuesToolkit(object, property(getNewValue));\r\n    }\r\n    case 'function': {\r\n      return mapValuesToolkit(object, getNewValue);\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Finds the element in an array that has the maximum value.\r\n *\r\n * @param {[T, ...T[]]} items - The array of elements to search.\r\n * @returns {T | undefined} - The element with the maximum value, or undefined if the array is empty.\r\n * @example\r\n * // Returns 9\r\n * max([3, 1, 4, 1, 5, 9]);\r\n *\r\n * @example\r\n * // Returns 8\r\n * max([0, -3, 2, 8, 7]);\r\n */\r\nexport function max<T>(items: readonly [T, ...T[]]): T;\r\n/**\r\n * Finds the element in an array that has the maximum value.\r\n * Returns undefined when no arguments are provided.\r\n * @returns {undefined}\r\n */\r\nexport function max(): undefined;\r\n/**\r\n * Finds the element in an array that has the maximum value.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} [items] - The array of elements to search. Defaults to an empty array.\r\n * @returns {T | undefined} - The element with the maximum value, or undefined if the array is empty.\r\n */\r\nexport function max<T>(items?: readonly T[]): T | undefined;\r\n/**\r\n * Finds the element in an array that has the maximum value.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} [items] - The array of elements to search. Defaults to an empty array.\r\n * @returns {T | undefined} - The element with the maximum value, or undefined if the array is empty.\r\n */\r\nexport function max<T>(items: readonly T[] = []): T | undefined {\r\n  let maxElement = items[0];\r\n  let max: any = undefined;\r\n\r\n  for (let i = 0; i < items.length; i++) {\r\n    const element = items[i];\r\n    if (max == null || element > max) {\r\n      max = element;\r\n      maxElement = element;\r\n    }\r\n  }\r\n\r\n  return maxElement;\r\n}\r\n","/**\r\n * Finds the element in an array that has the maximum value when applying\r\n * the `getValue` function to each element.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {[T, ...T[]]} items The nonempty array of elements to search.\r\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\r\n * @returns {T} The element with the maximum value as determined by the `getValue` function.\r\n * @example\r\n * maxBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 3 }\r\n * maxBy([], x => x.a); // Returns: undefined\r\n * maxBy(\r\n *   [\r\n *     { name: 'john', age: 30 },\r\n *     { name: 'jane', age: 28 },\r\n *     { name: 'joe', age: 26 },\r\n *   ],\r\n *   x => x.age\r\n * ); // Returns: { name: 'john', age: 30 }\r\n */\r\nexport function maxBy<T>(items: readonly [T, ...T[]], getValue: (element: T) => number): T;\r\n/**\r\n * Finds the element in an array that has the maximum value when applying\r\n * the `getValue` function to each element.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} items The array of elements to search.\r\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\r\n * @returns {T | undefined} The element with the maximum value as determined by the `getValue` function.\r\n * @example\r\n * maxBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 3 }\r\n * maxBy([], x => x.a); // Returns: undefined\r\n * maxBy(\r\n *   [\r\n *     { name: 'john', age: 30 },\r\n *     { name: 'jane', age: 28 },\r\n *     { name: 'joe', age: 26 },\r\n *   ],\r\n *   x => x.age\r\n * ); // Returns: { name: 'john', age: 30 }\r\n */\r\nexport function maxBy<T>(items: readonly T[], getValue: (element: T) => number): T | undefined;\r\n/**\r\n * Finds the element in an array that has the maximum value when applying\r\n * the `getValue` function to each element.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} items The array of elements to search.\r\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\r\n * @returns {T | undefined} The element with the maximum value as determined by the `getValue` function.\r\n * @example\r\n * maxBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 3 }\r\n * maxBy([], x => x.a); // Returns: undefined\r\n * maxBy(\r\n *   [\r\n *     { name: 'john', age: 30 },\r\n *     { name: 'jane', age: 28 },\r\n *     { name: 'joe', age: 26 },\r\n *   ],\r\n *   x => x.age\r\n * ); // Returns: { name: 'john', age: 30 }\r\n */\r\nexport function maxBy<T>(items: readonly T[], getValue: (element: T) => number): T {\r\n  let maxElement = items[0];\r\n  let max = -Infinity;\r\n\r\n  for (let i = 0; i < items.length; i++) {\r\n    const element = items[i];\r\n    const value = getValue(element);\r\n    if (value > max) {\r\n      max = value;\r\n      maxElement = element;\r\n    }\r\n  }\r\n\r\n  return maxElement;\r\n}\r\n","import { mean } from './mean.ts';\r\n\r\n/**\r\n * Calculates the average of an array of numbers when applying\r\n * the `getValue` function to each element.\r\n *\r\n * If the array is empty, this function returns `NaN`.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} items An array to calculate the average.\r\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\r\n * @returns {number} The average of all the numbers as determined by the `getValue` function.\r\n *\r\n * @example\r\n * meanBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: 2\r\n * meanBy([], x => x.a); // Returns: NaN\r\n */\r\nexport function meanBy<T>(items: readonly T[], getValue: (element: T) => number): number {\r\n  const nums = items.map(x => getValue(x));\r\n\r\n  return mean(nums);\r\n}\r\n","/**\r\n * Creates a memoized version of the provided function. The memoized function caches\r\n * results based on the argument it receives, so if the same argument is passed again,\r\n * it returns the cached result instead of recomputing it.\r\n *\r\n * This function works with functions that take zero or just one argument. If your function\r\n * originally takes multiple arguments, you should refactor it to take a single object or array\r\n * that combines those arguments.\r\n *\r\n * If the argument is not primitive (e.g., arrays or objects), provide a\r\n * `getCacheKey` function to generate a unique cache key for proper caching.\r\n *\r\n * @template F - The type of the function to be memoized.\r\n * @param {F} fn - The function to be memoized. It should accept a single argument and return a value.\r\n * @param {MemoizeOptions<Parameters<F>[0], ReturnType<F>>} [options={}] - Optional configuration for the memoization.\r\n * @param {MemoizeCache<any, V>} [options.cache] - The cache object used to store results. Defaults to a new `Map`.\r\n * @param {(args: A) => unknown} [options.getCacheKey] - An optional function to generate a unique cache key for each argument.\r\n *\r\n * @returns The memoized function with an additional `cache` property that exposes the internal cache.\r\n *\r\n * @example\r\n * // Example using the default cache\r\n * const add = (x: number) => x + 10;\r\n * const memoizedAdd = memoize(add);\r\n *\r\n * console.log(memoizedAdd(5)); // 15\r\n * console.log(memoizedAdd(5)); // 15 (cached result)\r\n * console.log(memoizedAdd.cache.size); // 1\r\n *\r\n * @example\r\n * // Example using a custom resolver\r\n * const sum = (arr: number[]) => arr.reduce((x, y) => x + y, 0);\r\n * const memoizedSum = memoize(sum, { getCacheKey: (arr: number[]) => arr.join(',') });\r\n * console.log(memoizedSum([1, 2])); // 3\r\n * console.log(memoizedSum([1, 2])); // 3 (cached result)\r\n * console.log(memoizedSum.cache.size); // 1\r\n *\r\n * @example\r\n * // Example using a custom cache implementation\r\n * class CustomCache<K, T> implements MemoizeCache<K, T> {\r\n *   private cache = new Map<K, T>();\r\n *\r\n *   set(key: K, value: T): void {\r\n *     this.cache.set(key, value);\r\n *   }\r\n *\r\n *   get(key: K): T | undefined {\r\n *     return this.cache.get(key);\r\n *   }\r\n *\r\n *   has(key: K): boolean {\r\n *     return this.cache.has(key);\r\n *   }\r\n *\r\n *   delete(key: K): boolean {\r\n *     return this.cache.delete(key);\r\n *   }\r\n *\r\n *   clear(): void {\r\n *     this.cache.clear();\r\n *   }\r\n *\r\n *   get size(): number {\r\n *     return this.cache.size;\r\n *   }\r\n * }\r\n * const customCache = new CustomCache<string, number>();\r\n * const memoizedSumWithCustomCache = memoize(sum, { cache: customCache });\r\n * console.log(memoizedSumWithCustomCache([1, 2])); // 3\r\n * console.log(memoizedSumWithCustomCache([1, 2])); // 3 (cached result)\r\n * console.log(memoizedAddWithCustomCache.cache.size); // 1\r\n */\r\nexport function memoize<F extends (...args: any) => any>(\r\n  fn: F,\r\n  options: {\r\n    cache?: MemoizeCache<any, ReturnType<F>>;\r\n    getCacheKey?: (args: Parameters<F>[0]) => unknown;\r\n  } = {}\r\n): F & { cache: MemoizeCache<any, ReturnType<F>> } {\r\n  const { cache = new Map<unknown, ReturnType<F>>(), getCacheKey } = options;\r\n\r\n  const memoizedFn = function (this: unknown, arg: Parameters<F>[0]): ReturnType<F> {\r\n    const key = getCacheKey ? getCacheKey(arg) : arg;\r\n\r\n    if (cache.has(key)) {\r\n      return cache.get(key)!;\r\n    }\r\n\r\n    const result = fn.call(this, arg);\r\n\r\n    cache.set(key, result);\r\n\r\n    return result;\r\n  };\r\n\r\n  memoizedFn.cache = cache;\r\n\r\n  return memoizedFn as F & { cache: MemoizeCache<any, ReturnType<F>> };\r\n}\r\n\r\n/**\r\n * Represents a cache for memoization, allowing storage and retrieval of computed values.\r\n *\r\n * @template K - The type of keys used to store values in the cache.\r\n * @template V - The type of values stored in the cache.\r\n */\r\nexport interface MemoizeCache<K, V> {\r\n  /**\r\n   * Stores a value in the cache with the specified key.\r\n   *\r\n   * @param key - The key to associate with the value.\r\n   * @param value - The value to store in the cache.\r\n   */\r\n  set(key: K, value: V): void;\r\n\r\n  /**\r\n   * Retrieves a value from the cache by its key.\r\n   *\r\n   * @param key - The key of the value to retrieve.\r\n   * @returns The value associated with the key, or undefined if the key does not exist.\r\n   */\r\n  get(key: K): V | undefined;\r\n\r\n  /**\r\n   * Checks if a value exists in the cache for the specified key.\r\n   *\r\n   * @param key - The key to check for existence in the cache.\r\n   * @returns True if the cache contains the key, false otherwise.\r\n   */\r\n  has(key: K): boolean;\r\n\r\n  /**\r\n   * Deletes a value from the cache by its key.\r\n   *\r\n   * @param key - The key of the value to delete.\r\n   * @returns True if the value was successfully deleted, false otherwise.\r\n   */\r\n  delete(key: K): boolean | void;\r\n\r\n  /**\r\n   * Clears all values from the cache.\r\n   */\r\n  clear(): void;\r\n\r\n  /**\r\n   * The number of entries in the cache.\r\n   */\r\n  size: number;\r\n}\r\n","import { noop } from '../../function/noop.ts';\r\nimport { mergeWith } from './mergeWith.ts';\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S} source - The first source object whose properties will be merged into the target object.\r\n * @returns {O & S} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @template O - Type of the target object.\r\n * @template S - Type of the first source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function merge<O, S>(object: O, source: S): O & S;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S1} source1 - The first source object to be merged into the target object.\r\n * @param {S2} source2 - The second source object to be merged into the target object.\r\n * @returns {O & S1 & S2} The updated target object with properties from the source objects merged in.\r\n *\r\n * @template O - Type of the target object.\r\n * @template S1 - Type of the first source object.\r\n * @template S2 - Type of the second source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function merge<O, S1, S2>(object: O, source1: S1, source2: S2): O & S1 & S2;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S1} source1 - The first source object whose properties will be merged into the target object.\r\n * @param {S2} source2 - The second source object whose properties will be merged into the target object.\r\n * @param {S3} source3 - The third source object whose properties will be merged into the target object.\r\n * @returns {O & S1 & S2 & S3} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @template O - Type of the target object.\r\n * @template S1 - Type of the first source object.\r\n * @template S2 - Type of the second source object.\r\n * @template S3 - Type of the third source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function merge<O, S1, S2, S3>(object: O, source1: S1, source2: S2, source3: S3): O & S1 & S2 & S3;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {S1} source1 - The first source object whose properties will be merged into the target object.\r\n * @param {S2} source2 - The second source object whose properties will be merged into the target object.\r\n * @param {S3} source3 - The third source object whose properties will be merged into the target object.\r\n * @param {S4} source4 - The fourth source object whose properties will be merged into the target object.\r\n * @returns {O & S1 & S2 & S3 & S4} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @template O - Type of the target object.\r\n * @template S1 - Type of the first source object.\r\n * @template S2 - Type of the second source object.\r\n * @template S3 - Type of the third source object.\r\n * @template S4 - Type of the fourth source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function merge<O, S1, S2, S3, S4>(\r\n  object: O,\r\n  source1: S1,\r\n  source2: S2,\r\n  source3: S3,\r\n  source4: S4\r\n): O & S1 & S2 & S3;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {any} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {any[]} sources - The source objects whose properties will be merged into the target object.\r\n * @returns {any} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function merge(object: any, ...sources: any[]): any;\r\n\r\n/**\r\n * Merges the properties of one or more source objects into the target object.\r\n *\r\n * This function performs a deep merge, recursively merging nested objects and arrays.\r\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\r\n *\r\n * The function can handle multiple source objects and will merge them all into the target object.\r\n *\r\n * @param {any} object - The target object into which the source object properties will be merged. This object is modified in place.\r\n * @param {any[]} sources - The source objects whose properties will be merged into the target object.\r\n * @returns {any} The updated target object with properties from the source object(s) merged in.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = merge(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function merge(object: any, ...sources: any[]): any {\r\n  return mergeWith(object, ...sources, noop);\r\n}\r\n","/**\r\n * Finds the element in an array that has the minimum value.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {[T, ...T[]]} items - The array of elements to search.\r\n * @returns {T | undefined} - The element with the minimum value, or undefined if the array is empty.\r\n * @example\r\n * // Returns 1\r\n * min([3, 1, 4, 1, 5, 9]);\r\n *\r\n * @example\r\n * // Returns -3\r\n * min([0, -3, 2, 8, 7]);\r\n */\r\nexport function min<T>(items: readonly [T, ...T[]]): T;\r\n\r\n/**\r\n * Finds the element in an array that has the minimum value.\r\n * Returns undefined when no arguments are provided.\r\n * @returns {undefined}\r\n */\r\nexport function min(): undefined;\r\n\r\n/**\r\n * Finds the element in an array that has the minimum value.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} [items] - The array of elements to search. Defaults to an empty array.\r\n * @returns {T | undefined} - The element with the minimum value, or undefined if the array is empty.\r\n */\r\nexport function min<T>(items?: readonly T[]): T | undefined;\r\n\r\n/**\r\n * Finds the element in an array that has the minimum value.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} [items] - The array of elements to search. Defaults to an empty array.\r\n * @returns {T} - The element with the minimum value.\r\n */\r\nexport function min<T>(items: readonly T[] = []): T {\r\n  let minElement = items[0];\r\n  let min: any = undefined;\r\n\r\n  for (let i = 0; i < items.length; i++) {\r\n    const element = items[i];\r\n    if (min == null || element < min) {\r\n      min = element;\r\n      minElement = element;\r\n    }\r\n  }\r\n\r\n  return minElement;\r\n}\r\n","/**\r\n * Finds the element in an array that has the minimum value when applying\r\n * the `getValue` function to each element.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {[T, ...T[]]} items The nonempty array of elements to search.\r\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\r\n * @returns {T} The element with the minimum value as determined by the `getValue` function.\r\n * @example\r\n * minBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 1 }\r\n * minBy([], x => x.a); // Returns: undefined\r\n * minBy(\r\n *   [\r\n *     { name: 'john', age: 30 },\r\n *     { name: 'jane', age: 28 },\r\n *     { name: 'joe', age: 26 },\r\n *   ],\r\n *   x => x.age\r\n * ); // Returns: { name: 'joe', age: 26 }\r\n */\r\nexport function minBy<T>(items: readonly [T, ...T[]], getValue: (element: T) => number): T;\r\n/**\r\n * Finds the element in an array that has the minimum value when applying\r\n * the `getValue` function to each element.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} items The array of elements to search.\r\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\r\n * @returns {T | undefined} The element with the minimum value as determined by the `getValue` function.\r\n * @example\r\n * minBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 1 }\r\n * minBy([], x => x.a); // Returns: undefined\r\n * minBy(\r\n *   [\r\n *     { name: 'john', age: 30 },\r\n *     { name: 'jane', age: 28 },\r\n *     { name: 'joe', age: 26 },\r\n *   ],\r\n *   x => x.age\r\n * ); // Returns: { name: 'joe', age: 26 }\r\n */\r\nexport function minBy<T>(items: readonly T[], getValue: (element: T) => number): T | undefined;\r\n/**\r\n * Finds the element in an array that has the minimum value when applying\r\n * the `getValue` function to each element.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} items The array of elements to search.\r\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\r\n * @returns {T | undefined} The element with the minimum value as determined by the `getValue` function.\r\n * @example\r\n * minBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 1 }\r\n * minBy([], x => x.a); // Returns: undefined\r\n * minBy(\r\n *   [\r\n *     { name: 'john', age: 30 },\r\n *     { name: 'jane', age: 28 },\r\n *     { name: 'joe', age: 26 },\r\n *   ],\r\n *   x => x.age\r\n * ); // Returns: { name: 'joe', age: 26 }\r\n */\r\nexport function minBy<T>(items: readonly T[], getValue: (element: T) => number): T | undefined {\r\n  let minElement = items[0];\r\n  let min = Infinity;\r\n\r\n  for (let i = 0; i < items.length; i++) {\r\n    const element = items[i];\r\n    const value = getValue(element);\r\n    if (value < min) {\r\n      min = value;\r\n      minElement = element;\r\n    }\r\n  }\r\n\r\n  return minElement;\r\n}\r\n","/**\r\n * Creates a function that negates the result of the predicate function.\r\n *\r\n * @template F - The type of the function to negate.\r\n * @param {F} func - The function to negate.\r\n * @returns {F} The new negated function, which negates the boolean result of `func`.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5, 6];\r\n * const isEven = (n: number) => n % 2 === 0;\r\n * const result = array.filter(negate(isEven));\r\n * // result will be [1, 3, 5]\r\n */\r\nexport function negate<F extends (...args: any[]) => boolean>(func: F): F {\r\n  return ((...args: any[]) => !func(...args)) as F;\r\n}\r\n","import { cloneDeep } from '../../object/cloneDeep.ts';\r\nimport { unset } from './unset.ts';\r\n\r\n/**\r\n * Creates a new object with specified keys omitted.\r\n *\r\n * This function takes an object and an array of keys, and returns a new object that\r\n * excludes the properties corresponding to the specified keys.\r\n *\r\n * @template T - The type of object.\r\n * @template K - The type of keys in object.\r\n * @param {T} obj - The object to omit keys from.\r\n * @param {K[]} keys - An array of keys to be omitted from the object.\r\n * @returns {Omit<T, K>} A new object with the specified keys omitted.\r\n *\r\n * @example\r\n * const obj = { a: 1, b: 2, c: 3 };\r\n * const result = omit(obj, ['b', 'c']);\r\n * // result will be { a: 1 }\r\n */\r\nexport function omit<T extends Record<string, any>, K extends keyof T>(obj: T, keys: readonly K[]): Omit<T, K>;\r\n\r\n/**\r\n * Creates a new object with specified keys omitted.\r\n *\r\n * This function takes an object and a variable number of keys, and returns a new object that\r\n * excludes the properties corresponding to the specified keys.\r\n *\r\n * Deep keys can be specified for keys.\r\n *\r\n * @template T - The type of object.\r\n * @param {T} obj - The object to omit keys from.\r\n * @param {...(PropertyKey | PropertyKey[] | PropertyKey[][]} keys - A variable number of keys to be omitted from the object.\r\n * @returns {Partial<T>} A new object with the specified keys omitted.\r\n */\r\nexport function omit<\r\n  // eslint-disable-next-line\r\n  T extends {},\r\n>(\r\n  obj: T | null | undefined,\r\n  ...keys: Array<PropertyKey | readonly PropertyKey[] | ReadonlyArray<readonly PropertyKey[]>>\r\n): Partial<T>;\r\n\r\n/**\r\n * Creates a new object with specified keys omitted.\r\n *\r\n * This function takes an object and a variable number of keys, and returns a new object that\r\n * excludes the properties corresponding to the specified keys. Note that keys can be deep.\r\n *\r\n * Deep keys can be specified for keys.\r\n *\r\n * @template T - The type of object.\r\n * @param {T} obj - The object to omit keys from.\r\n * @param {...(PropertyKey | PropertyKey[] | PropertyKey[][])} keysArr - A variable number of keys to be omitted from the object.\r\n * @returns {Partial<T>} A new object with the specified keys omitted.\r\n */\r\nexport function omit<\r\n  // eslint-disable-next-line\r\n  T extends {},\r\n>(\r\n  obj: T | null | undefined,\r\n  ...keysArr: Array<PropertyKey | readonly PropertyKey[] | ReadonlyArray<readonly PropertyKey[]>>\r\n): Partial<T> {\r\n  if (obj == null) {\r\n    return {};\r\n  }\r\n\r\n  const result = cloneDeep(obj);\r\n\r\n  for (let i = 0; i < keysArr.length; i++) {\r\n    let keys = keysArr[i];\r\n\r\n    switch (typeof keys) {\r\n      case 'object': {\r\n        if (!Array.isArray(keys)) {\r\n          // eslint-disable-next-line\r\n          // @ts-ignore\r\n          keys = Array.from(keys) as PropertyKey[];\r\n        }\r\n\r\n        for (let j = 0; j < keys.length; j++) {\r\n          const key = keys[j];\r\n\r\n          unset(result, key);\r\n        }\r\n\r\n        break;\r\n      }\r\n      case 'string':\r\n      case 'symbol':\r\n      case 'number': {\r\n        unset(result, keys);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Creates a new object composed of the properties that do not satisfy the predicate function.\r\n *\r\n * This function takes an object and a predicate function, and returns a new object that\r\n * includes only the properties for which the predicate function returns false.\r\n *\r\n * @template T - The type of object.\r\n * @param {T} obj - The object to omit properties from.\r\n * @param {(value: T[string], key: keyof T) => boolean} shouldOmit - A predicate function that determines\r\n * whether a property should be omitted. It takes the property's key and value as arguments and returns `true`\r\n * if the property should be omitted, and `false` otherwise.\r\n * @returns {Partial<T>} A new object with the properties that do not satisfy the predicate function.\r\n *\r\n * @example\r\n * const obj = { a: 1, b: 'omit', c: 3 };\r\n * const shouldOmit = (key, value) => typeof value === 'string';\r\n * const result = omitBy(obj, shouldOmit);\r\n * // result will be { a: 1, c: 3 }\r\n */\r\nexport function omitBy<T extends Record<string, any>>(\r\n  obj: T,\r\n  shouldOmit: (value: T[keyof T], key: keyof T) => boolean\r\n): Partial<T> {\r\n  const result: Partial<T> = {};\r\n\r\n  const objEntries = Object.entries(obj);\r\n  for (let i = 0; i < objEntries.length; i++) {\r\n    const [key, value] = objEntries[i];\r\n    if (!shouldOmit(value, key)) {\r\n      (result as any)[key] = value;\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Creates a function that is restricted to invoking the provided function `func` once.\r\n * Repeated calls to the function will return the value from the first invocation.\r\n *\r\n * @template F - The type of function.\r\n * @param {F} func - The function to restrict.\r\n * @returns {F} A new function that invokes `func` once and caches the result.\r\n *\r\n * @example\r\n * const initialize = once(() => {\r\n *   console.log('Initialized!');\r\n *   return true;\r\n * });\r\n *\r\n * initialize(); // Logs: 'Initialized!' and returns true\r\n * initialize(); // Returns true without logging\r\n */\r\nexport function once<F extends () => any>(func: F): F {\r\n  let called = false;\r\n  let cache: ReturnType<F> | undefined;\r\n\r\n  return function () {\r\n    if (called) {\r\n      return cache;\r\n    }\r\n\r\n    const result = func();\r\n\r\n    called = true;\r\n    cache = result;\r\n\r\n    return result;\r\n  } as F;\r\n}\r\n","import { pad as padToolkit } from '../../string/pad.ts';\r\nimport { toString } from '../util/toString.ts';\r\n/**\r\n * Pads string on the left and right sides if it's shorter than length. Padding characters are truncated if they can't be evenly divided by length.\r\n * If the length is less than or equal to the original string's length, or if the padding character is an empty string, the original string is returned unchanged.\r\n *\r\n * @param {string} str - The string to pad.\r\n * @param {number} [length] - The length of the resulting string once padded.\r\n * @param {string} [chars] - The character(s) to use for padding.\r\n * @returns {string} - The padded string, or the original string if padding is not required.\r\n *\r\n * @example\r\n * const result1 = pad('abc', 8);         // result will be '  abc   '\r\n * const result2 = pad('abc', 8, '_-');   // result will be '_-abc_-_'\r\n * const result3 = pad('abc', 3);         // result will be 'abc'\r\n * const result4 = pad('abc', 2);         // result will be 'abc'\r\n *\r\n */\r\nexport function pad(str: string, length: number, chars = ' '): string {\r\n  return padToolkit(toString(str), length, chars);\r\n}\r\n","/**\r\n * Pads string on the left and right sides if it's shorter than length. Padding characters are truncated if they can't be evenly divided by length.\r\n * If the length is less than or equal to the original string's length, or if the padding character is an empty string, the original string is returned unchanged.\r\n *\r\n * @param {string} str - The string to pad.\r\n * @param {number} [length] - The length of the resulting string once padded.\r\n * @param {string} [chars] - The character(s) to use for padding.\r\n * @returns {string} - The padded string, or the original string if padding is not required.\r\n *\r\n * @example\r\n * const result1 = pad('abc', 8);         // result will be '  abc   '\r\n * const result2 = pad('abc', 8, '_-');   // result will be '_-abc_-_'\r\n * const result3 = pad('abc', 3);         // result will be 'abc'\r\n * const result4 = pad('abc', 2);         // result will be 'abc'\r\n *\r\n */\r\nexport function pad(str: string, length: number, chars = ' '): string {\r\n  return str.padStart(Math.floor((length - str.length) / 2) + str.length, chars).padEnd(length, chars);\r\n}\r\n","import { toString } from '../util/toString.ts';\r\n\r\n/**\r\n * Pads the end of a string with a given character until it reaches the specified length.\r\n *\r\n * If the length is less than or equal to the original string's length, or if the padding character is an empty string,\r\n * the original string is returned unchanged.\r\n *\r\n * @param {string} str - The string to pad.\r\n * @param {number} [length] - The length of the resulting string once padded.\r\n * @param {string} [chars] - The character(s) to use for padding.\r\n * @returns {string} - The padded string, or the original string if padding is not required.\r\n *\r\n * @example\r\n * const result1 = padEnd('abc', 6);          // result will be 'abc   '\r\n * const result2 = padEnd('abc', 6, '_-');    // result will be 'abc_-_'\r\n * const result3 = padEnd('abc', 3);          // result will be 'abc'\r\n * const result4 = padEnd('abc', 2);          // result will be 'abc'\r\n */\r\n\r\nexport function padEnd(str: string, length = 0, chars = ' '): string {\r\n  return toString(str).padEnd(length, chars);\r\n}\r\n","import { toString } from '../util/toString.ts';\r\n\r\n/**\r\n * Pads the start of a string with a given character until it reaches the specified length.\r\n *\r\n * If the length is less than or equal to the original string's length, or if the padding character is an empty string,\r\n * the original string is returned unchanged.\r\n *\r\n * @param {string} str - The string to pad.\r\n * @param {number} [length] - The length of the resulting string once padded.\r\n * @param {string} [chars] - The character(s) to use for padding.\r\n * @returns {string} - The padded string, or the original string if padding is not required.\r\n *\r\n * @example\r\n * const result1 = padStart('abc', 6);          // result will be '   abc'\r\n * const result2 = padStart('abc', 6, '_-');    // result will be '_-_abc'\r\n * const result3 = padStart('abc', 3);          // result will be 'abc'\r\n * const result4 = padStart('abc', 2);          // result will be 'abc'\r\n */\r\nexport function padStart(str: string, length = 0, chars = ' '): string {\r\n  return toString(str).padStart(length, chars);\r\n}\r\n","/**\r\n * Converts `string` to an integer of the specified radix. If `radix` is undefined or 0, a `radix` of 10 is used unless `string` is a hexadecimal, in which case a `radix` of 16 is used.\r\n *\r\n * @param {string} string The string to convert to an integer.\r\n * @param {number} radix The radix to use when converting the string to an integer. Defaults to `0`.\r\n * @param {unknown} guard Enables use as an iteratee for methods like `Array#map`.\r\n * @returns {number} Returns the converted integer.\r\n *\r\n * @example\r\n * parseInt('08'); // => 8\r\n * parseInt('0x20'); // => 32\r\n *\r\n * parseInt('08', 10); // => 8\r\n * parseInt('0x20', 16); // => 32\r\n *\r\n * ['6', '08', '10'].map(parseInt); // => [6, 8, 10]\r\n */\r\nexport function parseInt(string: string, radix = 0, guard?: unknown): number {\r\n  if (guard) {\r\n    radix = 0;\r\n  }\r\n  return Number.parseInt(string, radix);\r\n}\r\n","/**\r\n * Splits an array into two groups based on a predicate function.\r\n *\r\n * This function takes an array and a predicate function. It returns a tuple of two arrays:\r\n * the first array contains elements for which the predicate function returns true, and\r\n * the second array contains elements for which the predicate function returns false.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to partition.\r\n * @param {(value: T) => boolean} isInTruthy - A predicate function that determines\r\n * whether an element should be placed in the truthy array. The function is called with each\r\n * element of the array.\r\n * @returns {[T[], T[]]} A tuple containing two arrays: the first array contains elements for\r\n * which the predicate returned true, and the second array contains elements for which the\r\n * predicate returned false.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * const isEven = x => x % 2 === 0;\r\n * const [even, odd] = partition(array, isEven);\r\n * // even will be [2, 4], and odd will be [1, 3, 5]\r\n */\r\nexport function partition<T>(arr: readonly T[], isInTruthy: (value: T) => boolean): [truthy: T[], falsy: T[]] {\r\n  const truthy: T[] = [];\r\n  const falsy: T[] = [];\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const item = arr[i];\r\n    if (isInTruthy(item)) {\r\n      truthy.push(item);\r\n    } else {\r\n      falsy.push(item);\r\n    }\r\n  }\r\n\r\n  return [truthy, falsy];\r\n}\r\n","import { getWords } from './_internal/getWords.ts';\r\nimport { capitalize } from './capitalize.ts';\r\n\r\n/**\r\n * Converts a string to Pascal case.\r\n *\r\n * Pascal case is the naming convention in which each word is capitalized and concatenated without any separator characters.\r\n *\r\n * @param {string} str - The string that is to be changed to pascal case.\r\n * @returns {string} - The converted string to Pascal case.\r\n *\r\n * @example\r\n * const convertedStr1 = pascalCase('pascalCase') // returns 'PascalCase'\r\n * const convertedStr2 = pascalCase('some whitespace') // returns 'SomeWhitespace'\r\n * const convertedStr3 = pascalCase('hyphen-text') // returns 'HyphenText'\r\n * const convertedStr4 = pascalCase('HTTPRequest') // returns 'HttpRequest'\r\n */\r\nexport function pascalCase(str: string): string {\r\n  const words = getWords(str);\r\n  return words.map(word => capitalize(word)).join('');\r\n}\r\n","import { isNil } from '../predicate/isNil.ts';\r\nimport { get } from './get.ts';\r\nimport { set } from './set.ts';\r\n\r\n/**\r\n * Creates a new object composed of the picked object properties.\r\n *\r\n * This function takes an object and an array of keys, and returns a new object that\r\n * includes only the properties corresponding to the specified keys.\r\n *\r\n * @template T - The type of object.\r\n * @template K - The type of keys in object.\r\n * @param {T} obj - The object to pick keys from.\r\n * @param {K[]} keys - An array of keys to be picked from the object.\r\n * @returns {Pick<T, K>} A new object with the specified keys picked.\r\n *\r\n * @example\r\n * const obj = { a: 1, b: 2, c: 3 };\r\n * const result = pick(obj, ['a', 'c']);\r\n * // result will be { a: 1, c: 3 }\r\n */\r\nexport function pick<T extends Record<string, any>, K extends keyof T>(obj: T, keys: readonly K[]): Pick<T, K>;\r\n\r\n/**\r\n * Creates a new object composed of the picked object properties.\r\n *\r\n * This function takes an object and an array of keys, and returns a new object that\r\n * includes only the properties corresponding to the specified keys.\r\n *\r\n * @template T - The type of object.\r\n * @param {T | null | undefined} obj - The object to pick keys from.\r\n * @param {...any} keys\r\n * @param {PropertyKey | PropertyKey[] | ProperyKey[][]}} keys - An array of keys to be picked from the object. received keysgoes through a flattening process before being used.\r\n * @returns {Partial<T, K>} A new object with the specified keys picked.\r\n *\r\n * @example\r\n * const obj = { a: 1, b: 2, c: 3 };\r\n * const result = pick(obj, ['a', 'c']);\r\n * // result will be { a: 1, c: 3 }\r\n *\r\n * // each path can be passed individually as an argument\r\n * const obj = { a: 1, b: 2, c: 3 };\r\n * const result = pick(obj, 'a', 'c');\r\n *\r\n * // pick a key over a path\r\n * const obj = { 'a.b': 1, a: { b: 2 } };\r\n * const result = pick(obj, 'a.b');\r\n * // result will be { 'a.b': 1 }\r\n */\r\nexport function pick<\r\n  // eslint-disable-next-line\r\n  T extends {},\r\n>(\r\n  obj: T | null | undefined,\r\n  ...keys: Array<PropertyKey | readonly PropertyKey[] | ReadonlyArray<readonly PropertyKey[]>>\r\n): Partial<T>;\r\n\r\n/**\r\n * Creates a new object composed of the picked object properties.\r\n *\r\n * This function takes an object and an array of keys, and returns a new object that\r\n * includes only the properties corresponding to the specified keys.\r\n *\r\n * @template T - The type of object.\r\n * @param {T | null | undefined} obj - The object to pick keys from.\r\n * @param {...any} keysArr - An array of keys to be picked from the object. received keysgoes through a flattening process before being used.\r\n * @param {PropertyKey | PropertyKey[] | ProperyKey[][]}} keys - An array of keys to be picked from the object. received keysgoes through a flattening process before being used.\r\n * @returns {Partial<T, K>} A new object with the specified keys picked.\r\n *\r\n * @example\r\n * const obj = { a: 1, b: 2, c: 3 };\r\n * const result = pick(obj, ['a', 'c']);\r\n * // result will be { a: 1, c: 3 }\r\n *\r\n * // each path can be passed individually as an argument\r\n * const obj = { a: 1, b: 2, c: 3 };\r\n * const result = pick(obj, 'a', 'c');\r\n *\r\n * // pick a key over a path\r\n * const obj = { 'a.b': 1, a: { b: 2 } };\r\n * const result = pick(obj, 'a.b');\r\n * // result will be { 'a.b': 1 }\r\n */\r\nexport function pick<\r\n  // eslint-disable-next-line\r\n  T extends {},\r\n>(\r\n  obj: T | null | undefined,\r\n  ...keysArr: Array<PropertyKey | readonly PropertyKey[] | ReadonlyArray<readonly PropertyKey[]>>\r\n): Partial<T> {\r\n  if (isNil(obj)) {\r\n    return {};\r\n  }\r\n\r\n  const result: any = {};\r\n\r\n  for (let i = 0; i < keysArr.length; i++) {\r\n    let keys = keysArr[i];\r\n    switch (typeof keys) {\r\n      case 'object': {\r\n        if (!Array.isArray(keys)) {\r\n          // eslint-disable-next-line\r\n          // @ts-ignore\r\n          keys = Array.from(keys) as PropertyKey[];\r\n        }\r\n        break;\r\n      }\r\n      case 'string':\r\n      case 'symbol':\r\n      case 'number': {\r\n        keys = [keys];\r\n        break;\r\n      }\r\n    }\r\n\r\n    for (const key of keys) {\r\n      const value = get(obj, key);\r\n\r\n      if (typeof key === 'string' && Object.prototype.hasOwnProperty.call(obj, key)) {\r\n        result[key] = value;\r\n      } else {\r\n        set(result, key, value);\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Creates a new object composed of the properties that satisfy the predicate function.\r\n *\r\n * This function takes an object and a predicate function, and returns a new object that\r\n * includes only the properties for which the predicate function returns true.\r\n *\r\n * @template T - The type of object.\r\n * @param {T} obj - The object to pick properties from.\r\n * @param {(value: T[keyof T], key: keyof T) => boolean} shouldPick - A predicate function that determines\r\n * whether a property should be picked. It takes the property's key and value as arguments and returns `true`\r\n * if the property should be picked, and `false` otherwise.\r\n * @returns {Partial<T>} A new object with the properties that satisfy the predicate function.\r\n *\r\n * @example\r\n * const obj = { a: 1, b: 'pick', c: 3 };\r\n * const shouldPick = (value) => typeof value === 'string';\r\n * const result = pickBy(obj, shouldPick);\r\n * // result will be { b: 'pick' }\r\n */\r\nexport function pickBy<T extends Record<string, any>>(\r\n  obj: T,\r\n  shouldPick: (value: T[keyof T], key: keyof T) => boolean\r\n): Partial<T> {\r\n  const result: Partial<T> = {};\r\n\r\n  const objEntries = Object.entries(obj);\r\n  for (let i = 0; i < objEntries.length; i++) {\r\n    const [key, value] = objEntries[i];\r\n    if (shouldPick(value, key)) {\r\n      (result as any)[key] = value;\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { at } from './at.ts';\r\n\r\n/**\r\n * Removes elements from an array at specified indices and returns the removed elements.\r\n *\r\n * This function supports negative indices, which count from the end of the array.\r\n *\r\n * @template T\r\n * @param {T[]} arr - The array from which elements will be removed.\r\n * @param {number[]} indicesToRemove - An array of indices specifying the positions of elements to remove.\r\n * @returns {Array<T | undefined>} An array containing the elements that were removed from the original array.\r\n *\r\n * @example\r\n * import { pullAt } from './pullAt';\r\n *\r\n * const numbers = [10, 20, 30, 40, 50];\r\n * const removed = pullAt(numbers, [1, 3, 4]);\r\n * console.log(removed); // [20, 40, 50]\r\n * console.log(numbers); // [10, 30]\r\n */\r\nexport function pullAt<T>(arr: T[], indicesToRemove: number[]): Array<T | undefined> {\r\n  const removed = at(arr, indicesToRemove);\r\n  const indices = new Set(indicesToRemove.slice().sort((x, y) => y - x));\r\n\r\n  for (const index of indices) {\r\n    arr.splice(index, 1);\r\n  }\r\n\r\n  return removed;\r\n}\r\n","import { random as randomToolkit } from '../../math/random.ts';\r\nimport { randomInt as randomIntToolkit } from '../../math/randomInt.ts';\r\nimport { clamp } from './clamp.ts';\r\n\r\n/**\r\n * Generate a random number within 0 and 1.\r\n *\r\n * @returns {number} A random number between 0 (inclusive) and 1 (exclusive). The number can be an integer or a decimal.\r\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\r\n *\r\n * @example\r\n * const result = random(); // Returns a random number between 0 and 1.\r\n */\r\nexport function random(floating?: boolean): number;\r\n\r\n/**\r\n * Generate a random number within 0 and 1.\r\n *\r\n * @returns {number} A random number between 0 (inclusive) and 1 (exclusive). The number can be an integer or a decimal.\r\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\r\n *\r\n * @example\r\n * const result = random(); // Returns a random number between 0 and 1.\r\n */\r\nexport function random(min: number, index: string | number, guard: object): number;\r\n\r\n/**\r\n * Generate a random number within the given range.\r\n *\r\n * If only one argument is provided, a number between `0` and the given number is returned.\r\n *\r\n * @param {number} maximum - The upper bound (exclusive).\r\n * @returns {number} A random number between 0 (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\r\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\r\n *\r\n * @example\r\n * const result1 = random(5); // Returns a random number between 0 and 5.\r\n * const result2 = random(0); // Returns a random number between 0 and 0 (which is 0).\r\n */\r\nexport function random(maximum: number, floating?: boolean): number;\r\n\r\n/**\r\n * Generate a random number within the given range.\r\n *\r\n * @param {number} minimum - The lower bound (inclusive).\r\n * @param {number} maximum - The upper bound (exclusive).\r\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\r\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\r\n *\r\n * @example\r\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\r\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown.\r\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\r\n */\r\nexport function random(minimum: number, maximum: number, floating?: boolean): number;\r\n\r\n/**\r\n * Generate a random number within the given range.\r\n *\r\n * @param {number} minimum - The lower bound (inclusive).\r\n * @param {number} maximum - The upper bound (exclusive).\r\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\r\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\r\n *\r\n * @example\r\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\r\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown.\r\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\r\n */\r\nexport function random(...args: any[]): number {\r\n  let minimum = 0;\r\n  let maximum = 1;\r\n  let floating = false;\r\n\r\n  switch (args.length) {\r\n    case 1: {\r\n      if (typeof args[0] === 'boolean') {\r\n        floating = args[0];\r\n      } else {\r\n        maximum = args[0];\r\n      }\r\n\r\n      break;\r\n    }\r\n    case 2: {\r\n      if (typeof args[1] === 'boolean') {\r\n        maximum = args[0];\r\n        floating = args[1];\r\n      } else {\r\n        minimum = args[0];\r\n        maximum = args[1];\r\n      }\r\n    }\r\n    // eslint-disable-next-line no-fallthrough\r\n    case 3: {\r\n      if (typeof args[2] === 'object' && args[2] != null && args[2][args[1]] === args[0]) {\r\n        minimum = 0;\r\n        maximum = args[0];\r\n        floating = false;\r\n      } else {\r\n        minimum = args[0];\r\n        maximum = args[1];\r\n        floating = args[2];\r\n      }\r\n    }\r\n  }\r\n\r\n  if (typeof minimum !== 'number') {\r\n    minimum = Number(minimum);\r\n  }\r\n\r\n  if (typeof maximum !== 'number') {\r\n    minimum = Number(maximum);\r\n  }\r\n\r\n  if (!minimum) {\r\n    minimum = 0;\r\n  }\r\n\r\n  if (!maximum) {\r\n    maximum = 0;\r\n  }\r\n\r\n  if (minimum > maximum) {\r\n    [minimum, maximum] = [maximum, minimum];\r\n  }\r\n\r\n  minimum = clamp(minimum, -Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\r\n  maximum = clamp(maximum, -Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\r\n\r\n  if (minimum === maximum) {\r\n    return minimum;\r\n  }\r\n\r\n  if (floating) {\r\n    return randomToolkit(minimum, maximum + 1);\r\n  } else {\r\n    return randomIntToolkit(minimum, maximum + 1);\r\n  }\r\n}\r\n","/**\r\n * Returns an array of numbers from `0` (inclusive) to `end` (exclusive), incrementing by `1`.\r\n *\r\n * @param {number} end - The end number of the range (exclusive).\r\n * @returns {number[]} An array of numbers from `0` (inclusive) to `end` (exclusive) with a step of `1`.\r\n *\r\n * @example\r\n * // Returns [0, 1, 2, 3]\r\n * range(4);\r\n */\r\nexport function range(end: number): number[];\r\n\r\n/**\r\n * Returns an array of numbers from `start` (inclusive) to `end` (exclusive), incrementing by `1`.\r\n *\r\n * @param {number} start - The starting number of the range (inclusive).\r\n * @param {number} end - The end number of the range (exclusive).\r\n * @returns {number[]} An array of numbers from `start` (inclusive) to `end` (exclusive) with a step of `1`.\r\n *\r\n * @example\r\n * // Returns [1, 2, 3]\r\n * range(1, 4);\r\n */\r\nexport function range(start: number, end: number): number[];\r\n\r\n/**\r\n * Returns an array of numbers from `start` (inclusive) to `end` (exclusive), incrementing by `step`.\r\n *\r\n * @param {number} start - The starting number of the range (inclusive).\r\n * @param {number} end - The end number of the range (exclusive).\r\n * @param {number} step - The step value for the range.\r\n * @returns {number[]} An array of numbers from `start` (inclusive) to `end` (exclusive) with the specified `step`.\r\n *\r\n * @example\r\n * // Returns [0, 5, 10, 15]\r\n * range(0, 20, 5);\r\n */\r\nexport function range(start: number, end: number, step: number): number[];\r\n\r\n/**\r\n * Returns an array of numbers from `start` (inclusive) to `end` (exclusive), incrementing by `step`.\r\n *\r\n * @param {number} start - The starting number of the range (inclusive).\r\n * @param {number} end - The end number of the range (exclusive).\r\n * @param {number} step - The step value for the range.\r\n * @returns {number[]} An array of numbers from `start` (inclusive) to `end` (exclusive) with the specified `step`.\r\n * @throws {Error} Throws an error if the step value is not a non-zero integer.\r\n *\r\n * @example\r\n * // Returns [0, 1, 2, 3]\r\n * range(4);\r\n *\r\n * @example\r\n * // Returns [0, -1, -2, -3]\r\n * range(0, -4, -1);\r\n */\r\nexport function range(start: number, end?: number, step?: number): number[] {\r\n  if (end == null) {\r\n    end = start;\r\n    start = 0;\r\n  }\r\n\r\n  if (step == null) {\r\n    step = 1;\r\n  }\r\n\r\n  if (!Number.isInteger(step) || step === 0) {\r\n    throw new Error(`The step value must be a non-zero integer.`);\r\n  }\r\n\r\n  const length = Math.max(Math.ceil((end - start) / step), 0);\r\n  const result = new Array(length);\r\n\r\n  for (let i = 0; i < length; i++) {\r\n    result[i] = start + i * step;\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { flatten } from '../array/flatten.ts';\r\n\r\n/**\r\n * Creates a function that invokes `func` with arguments arranged according to the specified `indices`\r\n * where the argument value at the first index is provided as the first argument,\r\n * the argument value at the second index is provided as the second argument, and so on.\r\n *\r\n * @template F The type of the function to re-arrange.\r\n * @param {F} func The function to rearrange arguments for.\r\n * @param {Array<number | number[]>} indices The arranged argument indices.\r\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new function.\r\n *\r\n * @example\r\n * const greet = (greeting: string, name: string) => `${greeting}, ${name}!`;\r\n * const rearrangedGreet = rearg(greet, 1, 0);\r\n * console.log(rearrangedGreet('World', 'Hello')); // Output: \"Hello, World!\"\r\n */\r\nexport function rearg<F extends (...args: any[]) => any>(\r\n  func: F,\r\n  ...indices: Array<number | number[]>\r\n): (...args: any[]) => ReturnType<F> {\r\n  const flattenIndices = flatten(indices);\r\n\r\n  return function (this: any, ...args: any[]) {\r\n    const reorderedArgs: any[] = flattenIndices.map(i => args[i]).slice(0, args.length);\r\n\r\n    for (let i = reorderedArgs.length; i < args.length; i++) {\r\n      reorderedArgs.push(args[i]);\r\n    }\r\n\r\n    return func.apply(this, reorderedArgs);\r\n  };\r\n}\r\n","/**\r\n * Repeats the given string n times.\r\n *\r\n * If n is less than 1, an empty string is returned, or if the string is an empty string,\r\n * the original string is returned unchanged.\r\n *\r\n * @param {string} str - The string to repeat.\r\n * @param {number} n - The number of times to repeat the string.\r\n * @returns {string} - The repeated string, or an empty string if n is less than 1.\r\n *\r\n * @example\r\n * repeat('abc', 0); // ''\r\n * repeat('abc', 2); // 'abcabc'\r\n */\r\nexport function repeat(str: string, n: number): string {\r\n  return str.repeat(n);\r\n}\r\n","import { rest as restToolkit } from '../../function/rest.ts';\r\n\r\n/**\r\n * Creates a function that transforms the arguments of the provided function `func`.\r\n * The transformed arguments are passed to `func` such that the arguments starting from a specified index\r\n * are grouped into an array, while the previous arguments are passed as individual elements.\r\n *\r\n * @template F - The type of the function being transformed.\r\n * @param {F} func - The function whose arguments are to be transformed.\r\n * @param {number} [start=func.length - 1] - The index from which to start grouping the remaining arguments into an array.\r\n *                                            Defaults to `func.length - 1`, grouping all arguments after the last parameter.\r\n * @returns {(...args: any[]) => ReturnType<F>} A new function that, when called, returns the result of calling `func` with the transformed arguments.\r\n *\r\n * The transformed arguments are:\r\n * - The first `start` arguments as individual elements.\r\n * - The remaining arguments from index `start` onward grouped into an array.\r\n * @example\r\n * function fn(a, b, c) {\r\n *   return [a, b, c];\r\n * }\r\n *\r\n * // Using default start index (func.length - 1, which is 2 in this case)\r\n * const transformedFn = rest(fn);\r\n * console.log(transformedFn(1, 2, 3, 4)); // [1, 2, [3, 4]]\r\n *\r\n * // Using start index 1\r\n * const transformedFnWithStart = rest(fn, 1);\r\n * console.log(transformedFnWithStart(1, 2, 3, 4)); // [1, [2, 3, 4]]\r\n *\r\n * // With fewer arguments than the start index\r\n * console.log(transformedFn(1)); // [1, undefined, []]\r\n */\r\nexport function rest<F extends (...args: any[]) => any>(\r\n  func: F,\r\n  start = func.length - 1\r\n): (...args: any[]) => ReturnType<F> {\r\n  start = Number.parseInt(start as any, 10);\r\n\r\n  if (Number.isNaN(start) || start < 0) {\r\n    start = func.length - 1;\r\n  }\r\n\r\n  return restToolkit(func, start);\r\n}\r\n","/**\r\n * Creates a function that transforms the arguments of the provided function `func`.\r\n * The transformed arguments are passed to `func` such that the arguments starting from a specified index\r\n * are grouped into an array, while the previous arguments are passed as individual elements.\r\n *\r\n * @template F - The type of the function being transformed.\r\n * @param {F} func - The function whose arguments are to be transformed.\r\n * @param {number} [startIndex=func.length - 1] - The index from which to start grouping the remaining arguments into an array.\r\n *                                            Defaults to `func.length - 1`, grouping all arguments after the last parameter.\r\n * @returns {(...args: any[]) => ReturnType<F>} A new function that, when called, returns the result of calling `func` with the transformed arguments.\r\n *\r\n * The transformed arguments are:\r\n * - The first `start` arguments as individual elements.\r\n * - The remaining arguments from index `start` onward grouped into an array.\r\n * @example\r\n * function fn(a, b, c) {\r\n *   return [a, b, c];\r\n * }\r\n *\r\n * // Using default start index (func.length - 1, which is 2 in this case)\r\n * const transformedFn = rest(fn);\r\n * console.log(transformedFn(1, 2, 3, 4)); // [1, 2, [3, 4]]\r\n *\r\n * // Using start index 1\r\n * const transformedFnWithStart = rest(fn, 1);\r\n * console.log(transformedFnWithStart(1, 2, 3, 4)); // [1, [2, 3, 4]]\r\n *\r\n * // With fewer arguments than the start index\r\n * console.log(transformedFn(1)); // [1, undefined, []]\r\n */\r\nexport function rest<F extends (...args: any[]) => any>(\r\n  func: F,\r\n  startIndex = func.length - 1\r\n): (...args: any[]) => ReturnType<F> {\r\n  return function (this: any, ...args: any[]) {\r\n    const rest = args.slice(startIndex);\r\n    const params = args.slice(0, startIndex);\r\n    while (params.length < startIndex) {\r\n      params.push(undefined);\r\n    }\r\n    return func.apply(this, [...params, rest]);\r\n  };\r\n}\r\n","import { decimalAdjust } from '../_internal/decimalAdjust.ts';\r\n\r\n/**\r\n * Computes number rounded to precision.\r\n *\r\n * @param {number | string} number  The number to round.\r\n * @param {number | string} precision The precision to round to.\r\n * @returns {number} Returns the rounded number.\r\n *\r\n * @example\r\n * round(4.006); // => 4\r\n * round(4.006, 2); // => 4.01\r\n * round(4060, -2); // => 4100\r\n */\r\nexport function round(number: number | string, precision: number | string = 0): number {\r\n  return decimalAdjust('round', number, precision);\r\n}\r\n","/**\r\n * Returns a random element from an array.\r\n *\r\n * This function takes an array and returns a single element selected randomly from the array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to sample from.\r\n * @returns {T} A random element from the array.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * const randomElement = sample(array);\r\n * // randomElement will be one of the elements from the array, selected randomly.\r\n */\r\nexport function sample<T>(arr: readonly T[]): T {\r\n  const randomIndex = Math.floor(Math.random() * arr.length);\r\n  return arr[randomIndex];\r\n}\r\n","import { randomInt } from '../math/randomInt.ts';\r\n\r\n/**\r\n * Returns a sample element array of a specified `size`.\r\n *\r\n * This function takes an array and a number, and returns an array containing the sampled elements using Floyd's algorithm.\r\n *\r\n * {@link https://www.nowherenearithaca.com/2013/05/robert-floyds-tiny-and-beautiful.html Floyd's algorithm}\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} array - The array to sample from.\r\n * @param {number} size - The size of sample.\r\n * @returns {T[]} A new array with sample size applied.\r\n * @throws {Error} Throws an error if `size` is greater than the length of `array`.\r\n *\r\n * @example\r\n * const result = sampleSize([1, 2, 3], 2)\r\n * // result will be an array containing two of the elements from the array.\r\n * // [1, 2] or [1, 3] or [2, 3]\r\n */\r\nexport function sampleSize<T>(array: readonly T[], size: number): T[] {\r\n  if (size > array.length) {\r\n    throw new Error('Size must be less than or equal to the length of array.');\r\n  }\r\n\r\n  const result = new Array(size);\r\n  const selected = new Set();\r\n\r\n  for (let step = array.length - size, resultIndex = 0; step < array.length; step++, resultIndex++) {\r\n    let index = randomInt(0, step + 1);\r\n\r\n    if (selected.has(index)) {\r\n      index = step;\r\n    }\r\n\r\n    selected.add(index);\r\n\r\n    result[resultIndex] = array[index];\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Randomizes the order of elements in an array using the Fisher-Yates algorithm.\r\n *\r\n * This function takes an array and returns a new array with its elements shuffled in a random order.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to shuffle.\r\n * @returns {T[]} A new array with its elements shuffled in random order.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * const shuffledArray = shuffle(array);\r\n * // shuffledArray will be a new array with elements of array in random order, e.g., [3, 1, 4, 5, 2]\r\n */\r\nexport function shuffle<T>(arr: readonly T[]): T[] {\r\n  const result = arr.slice();\r\n\r\n  /**\r\n   * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\r\n   */\r\n  for (let i = result.length - 1; i >= 1; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [result[i], result[j]] = [result[j], result[i]];\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { isNil } from '../../predicate/isNil.ts';\r\n\r\n/**\r\n * Returns the length of an array, string, or object.\r\n *\r\n * This function takes an array, string, or object and returns its length.\r\n * For arrays and strings, it returns the number of elements or characters, respectively.\r\n * For objects, it returns the number of enumerable properties.\r\n *\r\n * @template T - The type of the input value.\r\n * @param {T[] | object | string | Map<unknown, T> | Set<T> | null | undefined } target - The value whose size is to be determined. It can be an array, string, or object.\r\n * @returns {number} The size of the input value.\r\n *\r\n * @example\r\n * const arr = [1, 2, 3];\r\n * const arrSize = size(arr);\r\n * // arrSize will be 3\r\n *\r\n * const str = 'hello';\r\n * const strSize = size(str);\r\n * // strSize will be 5\r\n *\r\n * const obj = { a: 1, b: 2, c: 3 };\r\n * const objSize = size(obj);\r\n * // objSize will be 3\r\n *\r\n * const emptyArr = [];\r\n * const emptyArrSize = size(emptyArr);\r\n * // emptyArrSize will be 0\r\n *\r\n * const emptyStr = '';\r\n * const emptyStrSize = size(emptyStr);\r\n * // emptyStrSize will be 0\r\n *\r\n * const emptyObj = {};\r\n * const emptyObjSize = size(emptyObj);\r\n * // emptyObjSize will be 0\r\n */\r\nexport function size<T>(target: readonly T[] | object | string | Map<unknown, T> | Set<T> | null | undefined): number {\r\n  if (isNil(target)) {\r\n    return 0;\r\n  }\r\n\r\n  if (target instanceof Map || target instanceof Set) {\r\n    return target.size;\r\n  }\r\n\r\n  return Object.keys(target).length;\r\n}\r\n","/**\r\n * Checks if a given value is null or undefined.\r\n *\r\n * This function tests whether the provided value is either `null` or `undefined`.\r\n * It returns `true` if the value is `null` or `undefined`, and `false` otherwise.\r\n *\r\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null` or `undefined`.\r\n *\r\n * @param {unknown} x - The value to test for null or undefined.\r\n * @returns {boolean} `true` if the value is null or undefined, `false` otherwise.\r\n *\r\n * @example\r\n * const value1 = null;\r\n * const value2 = undefined;\r\n * const value3 = 42;\r\n * const result1 = isNil(value1); // true\r\n * const result2 = isNil(value2); // true\r\n * const result3 = isNil(value3); // false\r\n */\r\nexport function isNil(x: unknown): x is null | undefined {\r\n  return x == null;\r\n}\r\n","import { snakeCase as snakeCaseToolkit } from '../../string/snakeCase.ts';\r\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\r\n\r\n/**\r\n * Converts a string to snake case.\r\n *\r\n * Snake case is the naming convention in which each word is written in lowercase and separated by an underscore (_) character.\r\n *\r\n * @param {string | object} str - The string that is to be changed to snake case.\r\n * @returns {string} - The converted string to snake case.\r\n *\r\n * @example\r\n * const convertedStr1 = snakeCase('camelCase') // returns 'camel_case'\r\n * const convertedStr2 = snakeCase('some whitespace') // returns 'some_whitespace'\r\n * const convertedStr3 = snakeCase('hyphen-text') // returns 'hyphen_text'\r\n * const convertedStr4 = snakeCase('HTTPRequest') // returns 'http_request'\r\n */\r\nexport function snakeCase(str?: string | object): string {\r\n  return snakeCaseToolkit(normalizeForCase(str));\r\n}\r\n","import { getWords } from './_internal/getWords.ts';\r\n\r\n/**\r\n * Converts a string to snake case.\r\n *\r\n * Snake case is the naming convention in which each word is written in lowercase and separated by an underscore (_) character.\r\n *\r\n * @param {string} str - The string that is to be changed to snake case.\r\n * @returns {string} - The converted string to snake case.\r\n *\r\n * @example\r\n * const convertedStr1 = snakeCase('camelCase') // returns 'camel_case'\r\n * const convertedStr2 = snakeCase('some whitespace') // returns 'some_whitespace'\r\n * const convertedStr3 = snakeCase('hyphen-text') // returns 'hyphen_text'\r\n * const convertedStr4 = snakeCase('HTTPRequest') // returns 'http_request'\r\n */\r\n\r\nexport function snakeCase(str: string): string {\r\n  const words = getWords(str);\r\n  return words.map(word => word.toLowerCase()).join('_');\r\n}\r\n","import { identity } from '../_internal/identity.ts';\r\nimport { property } from '../object/property.ts';\r\nimport { matches } from '../predicate/matches.ts';\r\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\r\n\r\n/**\r\n * Checks if there is an element in an array that is truthy.\r\n *\r\n * @param {T[]} arr The array to iterate over.\r\n * @returns {boolean} Returns `true` if any element is truthy, else `false`.\r\n *\r\n * @example\r\n * some([1, 2, 3, 4]);\r\n * // => true\r\n */\r\nexport function some<T>(arr: readonly T[]): boolean;\r\n\r\n/**\r\n * Checks if there is an element in an array that matches the given predicate function.\r\n *\r\n * @param {T[]} arr The array to iterate over.\r\n * @param {(item: T, index: number, arr: any) => unknown} predicate The function invoked per iteration.\r\n * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\r\n *\r\n * @example\r\n * some([1, 2, 3, 4], n => n % 2 === 0);\r\n * // => true\r\n */\r\nexport function some<T>(arr: readonly T[], predicate: (item: T, index: number, arr: any) => unknown): boolean;\r\n\r\n/**\r\n * Checks if there is an element in an array that matches the given key-value pair.\r\n *\r\n * @param {T[]} arr The array to iterate over.\r\n * @param {[keyof T, unknown]} predicate The key-value pair to match.\r\n * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\r\n *\r\n * @example\r\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], ['a', 2]);\r\n * // => true\r\n */\r\nexport function some<T>(arr: readonly T[], predicate: [keyof T, unknown]): boolean;\r\n\r\n/**\r\n * Checks if there is an element in an array that has a truthy value for the given property name.\r\n *\r\n * @param {T[]} arr The array to iterate over.\r\n * @param {string} propertyToCheck The property name to check.\r\n * @returns {boolean} Returns `true` if any element has a truthy value for the property, else `false`.\r\n *\r\n * @example\r\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], 'a');\r\n * // => true\r\n */\r\nexport function some<T>(arr: readonly T[], propertyToCheck: string): boolean;\r\n\r\n/**\r\n * Checks if there is an element in an array that matches the given partial object.\r\n *\r\n * @param {T[]} arr The array to iterate over.\r\n * @param {Partial<T>} doesMatch The partial object to match.\r\n * @returns {boolean} Returns `true` if any element matches the partial object, else `false`.\r\n *\r\n * @example\r\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], { a: 2 });\r\n * // => true\r\n */\r\nexport function some<T>(arr: readonly T[], doesMatch: Partial<T>): boolean;\r\n\r\n/**\r\n * Checks if there is an element in an array that matches the given predicate.\r\n *\r\n * Iteration is stopped once there is an element that matches `predicate`.\r\n *\r\n * @param {T[]} arr The array to iterate over.\r\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string} [predicate=identity] The function invoked per iteration.\r\n * If a property name or an object is provided it will be used to create a predicate function.\r\n * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\r\n *\r\n * @example\r\n * some([1, 2, 3, 4], n => n % 2 === 0);\r\n * // => true\r\n *\r\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], { a: 2 });\r\n * // => true\r\n *\r\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], ['a', 2]);\r\n * // => true\r\n *\r\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], 'a');\r\n * // => true\r\n */\r\nexport function some<T>(\r\n  arr: readonly T[] | null | undefined,\r\n  predicate?: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string,\r\n  guard?: unknown\r\n): boolean;\r\n\r\n/**\r\n * Checks if there is an element in an array that matches the given predicate.\r\n *\r\n * Iteration is stopped once there is an element that matches `predicate`.\r\n *\r\n * @param {T[]} arr The array to iterate over.\r\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string} [predicate=identity] The function invoked per iteration.\r\n * If a property name or an object is provided it will be used to create a predicate function.\r\n * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\r\n *\r\n * @example\r\n * some([1, 2, 3, 4], n => n % 2 === 0);\r\n * // => true\r\n *\r\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], { a: 2 });\r\n * // => true\r\n *\r\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], ['a', 2]);\r\n * // => true\r\n *\r\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], 'a');\r\n * // => true\r\n */\r\nexport function some<T>(\r\n  arr: readonly T[] | null | undefined,\r\n  predicate?: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string,\r\n  guard?: unknown\r\n): boolean {\r\n  if (guard != null) {\r\n    predicate = undefined;\r\n  }\r\n\r\n  if (!predicate) {\r\n    predicate = identity;\r\n  }\r\n\r\n  if (!Array.isArray(arr)) {\r\n    return false;\r\n  }\r\n\r\n  switch (typeof predicate) {\r\n    case 'function': {\r\n      return arr.some(predicate);\r\n    }\r\n    case 'object': {\r\n      if (Array.isArray(predicate) && predicate.length === 2) {\r\n        const key = predicate[0];\r\n        const value = predicate[1];\r\n\r\n        return arr.some(matchesProperty(key, value));\r\n      } else {\r\n        return arr.some(matches(predicate));\r\n      }\r\n    }\r\n    case 'string': {\r\n      return arr.some(property(predicate));\r\n    }\r\n  }\r\n}\r\n","import { Criterion, orderBy } from './orderBy.ts';\r\n\r\n/**\r\n * Sorts an array of objects based on multiple properties and their corresponding order directions.\r\n *\r\n * This function takes an array of objects, an array of criteria to sort by.\r\n * It returns the ascending sorted array, ordering by each key.\r\n * If values for a key are equal, it moves to the next key to determine the order.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param { T[] | object | null | undefined} collection - The array of objects to be sorted.\r\n * @param {Criterion<T> | Array<Criterion<T>>} criteria - An array of criteria (property names or property paths or custom key functions) to sort by.\r\n * @returns {T[]} - The ascending sorted array.\r\n *\r\n * @example\r\n * // Sort an array of objects by 'user' in ascending order and 'age' in descending order.\r\n * const users = [\r\n *   { user: 'fred', age: 48 },\r\n *   { user: 'barney', age: 34 },\r\n *   { user: 'fred', age: 40 },\r\n *   { user: 'barney', age: 36 },\r\n * ];\r\n * const result = sortBy(users, ['user', (item) => item.age])\r\n * // result will be:\r\n * // [\r\n * //   { user: 'barney', age: 34 },\r\n * //   { user: 'barney', age: 36 },\r\n * //   { user: 'fred', age: 40 },\r\n * //   { user: 'fred', age: 48 },\r\n * // ]\r\n */\r\nexport function sortBy<T>(\r\n  collection: readonly T[] | object | number | null | undefined,\r\n  criteria?: Criterion<T> | Array<Criterion<T>>\r\n): T[] {\r\n  return orderBy(collection, criteria, ['asc']);\r\n}\r\n","/**\r\n * Creates a new function that spreads elements of an array argument into individual arguments\r\n * for the original function. The array argument is positioned based on the `argsIndex` parameter.\r\n *\r\n * @template F - A function type with any number of parameters and any return type.\r\n * @param {F} func - The function to be transformed. It can be any function with any number of arguments.\r\n * @param {number} [argsIndex=0] - The index where the array argument is positioned among the other arguments.\r\n *   If `argsIndex` is negative or `NaN`, it defaults to `0`. If it's a fractional number, it is rounded to the nearest integer.\r\n * @returns {(...args: any[]) => ReturnType<F>} - A new function that takes multiple arguments, including an array of arguments at the specified `argsIndex`,\r\n *   and returns the result of calling the original function with those arguments.\r\n *\r\n * @example\r\n * function add(a, b) {\r\n *   return a + b;\r\n * }\r\n *\r\n * const spreadAdd = spread(add);\r\n * console.log(spreadAdd([1, 2])); // Output: 3\r\n *\r\n * @example\r\n * // Example function to spread arguments over\r\n * function add(a, b) {\r\n *   return a + b;\r\n * }\r\n *\r\n * // Create a new function that uses `spread` to combine arguments\r\n * const spreadAdd = spread(add, 1);\r\n *\r\n * // Calling `spreadAdd` with an array as the second argument\r\n * console.log(spreadAdd(1, [2])); // Output: 3\r\n *\r\n * @example\r\n * // Function with default arguments\r\n * function greet(name, greeting = 'Hello') {\r\n *   return `${greeting}, ${name}!`;\r\n * }\r\n *\r\n * // Create a new function that uses `spread` to position the argument array at index 0\r\n * const spreadGreet = spread(greet, 0);\r\n *\r\n * // Calling `spreadGreet` with an array of arguments\r\n * console.log(spreadGreet(['Alice'])); // Output: Hello, Alice!\r\n * console.log(spreadGreet(['Bob', 'Hi'])); // Output: Hi, Bob!\r\n */\r\nexport function spread<F extends (...args: any[]) => any>(func: F, argsIndex = 0): (...args: any[]) => ReturnType<F> {\r\n  argsIndex = Number.parseInt(argsIndex as any, 10);\r\n\r\n  if (Number.isNaN(argsIndex) || argsIndex < 0) {\r\n    argsIndex = 0;\r\n  }\r\n\r\n  return function (this: any, ...args: any[]) {\r\n    const array = args[argsIndex];\r\n    const params = args.slice(0, argsIndex);\r\n\r\n    if (array) {\r\n      params.push(...array);\r\n    }\r\n\r\n    return func.apply(this, params);\r\n  };\r\n}\r\n","import { getWords } from '../../string/_internal/getWords.ts';\r\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\r\n\r\n/**\r\n * Converts the first character of each word in a string to uppercase and the remaining characters to lowercase.\r\n *\r\n * Start case is the naming convention in which each word is written with an initial capital letter.\r\n * @param {string | object} str - The string to convert.\r\n * @returns {string} The converted string.\r\n *\r\n * @example\r\n * const result1 = startCase('hello world');  // result will be 'Hello World'\r\n * const result2 = startCase('HELLO WORLD');  // result will be 'HELLO WORLD'\r\n * const result3 = startCase('hello-world');  // result will be 'Hello World'\r\n * const result4 = startCase('hello_world');  // result will be 'Hello World'\r\n */\r\nexport function startCase(str?: string | object): string {\r\n  const words = getWords(normalizeForCase(str).trim());\r\n\r\n  let result = '';\r\n\r\n  for (let i = 0; i < words.length; i++) {\r\n    const word = words[i];\r\n\r\n    if (result) {\r\n      result += ' ';\r\n    }\r\n\r\n    if (word === word.toUpperCase()) {\r\n      result += word;\r\n    } else {\r\n      result += word[0].toUpperCase() + word.slice(1).toLowerCase();\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Checks if a string contains another string at the beginning of the string.\r\n *\r\n * Checks if one string startsWith another string. Optional position parameter to start searching from a certain index.\r\n *\r\n * @param {string} str - The string that might contain the target string.\r\n * @param {string} target - The string to search for.\r\n * @param {number} position - An optional offset to start searching in the str string\r\n * @returns {boolean} - True if the str string starts with the target string.\r\n *\r\n * @example\r\n * const isPrefix = startsWith('fooBar', 'foo') // returns true\r\n * const isPrefix = startsWith('fooBar', 'bar') // returns false\r\n * const isPrefix = startsWith('fooBar', 'abc') // returns false\r\n * const isPrefix = startsWith('fooBar', 'Bar', 2) // returns true\r\n * const isPrefix = startsWith('fooBar', 'Bar', 5) // returns false\r\n */\r\nexport function startsWith(str: string, target: string, position = 0): boolean {\r\n  return str.startsWith(target, position);\r\n}\r\n","import { sum } from './sum.ts';\r\n\r\n/**\r\n * Calculates the sum of an array of numbers when applying\r\n * the `getValue` function to each element.\r\n *\r\n * If the array is empty, this function returns `0`.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} items An array to calculate the sum.\r\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\r\n * @returns {number} The sum of all the numbers as determined by the `getValue` function.\r\n *\r\n * @example\r\n * sumBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: 6\r\n * sumBy([], x => x.a); // Returns: 0\r\n */\r\nexport function sumBy<T>(items: readonly T[], getValue: (element: T) => number): number {\r\n  const nums = items.map(x => getValue(x));\r\n\r\n  return sum(nums);\r\n}\r\n","/**\r\n * Returns an empty array when the input is a single-element array.\r\n *\r\n * @template T - The type of the single element in the array.\r\n * @param {[T]} arr - The single-element array to process.\r\n * @returns {[]} An empty array.\r\n *\r\n * @example\r\n * const arr = [1];\r\n * const result = tail(arr);\r\n * // result will be []\r\n */\r\nexport function tail<T>(arr: readonly [T]): [];\r\n\r\n/**\r\n * Returns an empty array when the input is an empty array.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {[]} arr - The empty array to process.\r\n * @returns {[]} An empty array.\r\n *\r\n * @example\r\n * const arr = [];\r\n * const result = tail(arr);\r\n * // result will be []\r\n */\r\nexport function tail(arr: readonly []): [];\r\n\r\n/**\r\n * Returns a new array with all elements except for the first when the input is a tuple array.\r\n *\r\n * @template T - The type of the first element in the tuple array.\r\n * @template U - The type of the remaining elements in the tuple array.\r\n * @param {[T, ...U[]]} arr - The tuple array to process.\r\n * @returns {U[]} A new array containing all elements of the input array except for the first one.\r\n *\r\n * @example\r\n * const arr = [1, 2, 3];\r\n * const result = tail(arr);\r\n * // result will be [2, 3]\r\n */\r\nexport function tail<T, U>(arr: readonly [T, ...U[]]): U[];\r\n\r\n/**\r\n * Returns a new array with all elements except for the first.\r\n *\r\n * This function takes an array and returns a new array containing all the elements\r\n * except for the first one. If the input array is empty or has only one element,\r\n * an empty array is returned.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to get the tail of.\r\n * @returns {T[]} A new array containing all elements of the input array except for the first one.\r\n *\r\n * @example\r\n * const arr1 = [1, 2, 3];\r\n * const result = tail(arr1);\r\n * // result will be [2, 3]\r\n *\r\n * const arr2 = [1];\r\n * const result2 = tail(arr2);\r\n * // result2 will be []\r\n *\r\n * const arr3 = [];\r\n * const result3 = tail(arr3);\r\n * // result3 will be []\r\n */\r\nexport function tail<T>(arr: readonly T[]): T[];\r\n\r\n/**\r\n * Returns a new array with all elements except for the first.\r\n *\r\n * This function takes an array and returns a new array containing all the elements\r\n * except for the first one. If the input array is empty or has only one element,\r\n * an empty array is returned.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to get the tail of.\r\n * @returns {T[]} A new array containing all elements of the input array except for the first one.\r\n *\r\n * @example\r\n * const arr1 = [1, 2, 3];\r\n * const result = tail(arr1);\r\n * // result will be [2, 3]\r\n *\r\n * const arr2 = [1];\r\n * const result2 = tail(arr2);\r\n * // result2 will be []\r\n *\r\n * const arr3 = [];\r\n * const result3 = tail(arr3);\r\n * // result3 will be []\r\n */\r\nexport function tail<T>(arr: readonly T[]): T[] {\r\n  return arr.slice(1);\r\n}\r\n","/**\r\n * Returns a new array containing the first `count` elements from the input array `arr`.\r\n * If `count` is greater than the length of `arr`, the entire array is returned.\r\n *\r\n * @template T - Type of elements in the input array.\r\n *\r\n * @param {T[]} arr - The array to take elements from.\r\n * @param {number} count - The number of elements to take.\r\n * @returns {T[]} A new array containing the first `count` elements from `arr`.\r\n *\r\n * @example\r\n * // Returns [1, 2, 3]\r\n * take([1, 2, 3, 4, 5], 3);\r\n *\r\n * @example\r\n * // Returns ['a', 'b']\r\n * take(['a', 'b', 'c'], 2);\r\n *\r\n * @example\r\n * // Returns [1, 2, 3]\r\n * take([1, 2, 3], 5);\r\n */\r\nexport function take<T>(arr: readonly T[], count: number): T[] {\r\n  return arr.slice(0, count);\r\n}\r\n","/**\r\n * Returns a new array containing the last `count` elements from the input array `arr`.\r\n * If `count` is greater than the length of `arr`, the entire array is returned.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to take elements from.\r\n * @param {number} [count=1] - The number of elements to take.\r\n * @returns {T[]} A new array containing the last `count` elements from `arr`.\r\n *\r\n * @example\r\n * // Returns [4, 5]\r\n * takeRight([1, 2, 3, 4, 5], 2);\r\n *\r\n * @example\r\n * // Returns ['b', 'c']\r\n * takeRight(['a', 'b', 'c'], 2);\r\n *\r\n * @example\r\n * // Returns [1, 2, 3]\r\n * takeRight([1, 2, 3], 5);\r\n */\r\nexport function takeRight<T>(arr: readonly T[], count = 1): T[] {\r\n  if (count <= 0) {\r\n    return [];\r\n  }\r\n\r\n  return arr.slice(-count);\r\n}\r\n","/**\r\n * Takes elements from the end of the array while the predicate function returns `true`.\r\n *\r\n * @template T - Type of elements in the input array.\r\n *\r\n * @param {T[]} arr - The array to take elements from.\r\n * @param {(item: T) => boolean} shouldContinueTaking - The function invoked per element.\r\n * @returns {T[]} A new array containing the elements taken from the end while the predicate returns `true`.\r\n *\r\n * @example\r\n * // Returns [3, 2, 1]\r\n * takeRightWhile([5, 4, 3, 2, 1], n => n < 4);\r\n *\r\n * @example\r\n * // Returns []\r\n * takeRightWhile([1, 2, 3], n => n > 3);\r\n */\r\nexport function takeRightWhile<T>(arr: readonly T[], shouldContinueTaking: (item: T) => boolean): T[] {\r\n  for (let i = arr.length - 1; i >= 0; i--) {\r\n    if (!shouldContinueTaking(arr[i])) {\r\n      return arr.slice(i + 1);\r\n    }\r\n  }\r\n\r\n  return arr.slice();\r\n}\r\n","/**\r\n * Returns a new array containing the leading elements of the provided array\r\n * that satisfy the provided predicate function. It stops taking elements as soon\r\n * as an element does not satisfy the predicate.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr - The array to process.\r\n * @param {(element: T) => boolean} shouldContinueTaking - The predicate function that is called with each element. Elements are included in the result as long as this function returns true.\r\n * @returns {T[]} A new array containing the leading elements that satisfy the predicate.\r\n *\r\n * @example\r\n * // Returns [1, 2]\r\n * takeWhile([1, 2, 3, 4], x => x < 3);\r\n *\r\n * @example\r\n * // Returns []\r\n * takeWhile([1, 2, 3, 4], x => x > 3);\r\n */\r\nexport function takeWhile<T>(arr: readonly T[], shouldContinueTaking: (element: T) => boolean): T[] {\r\n  const result: T[] = [];\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const item = arr[i];\r\n    if (!shouldContinueTaking(item)) {\r\n      break;\r\n    }\r\n\r\n    result.push(item);\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { debounce } from './debounce.ts';\r\n\r\ninterface ThrottleOptions {\r\n  /**\r\n   * An optional AbortSignal to cancel the function invocation on the trailing edge.\r\n   */\r\n  signal?: AbortSignal;\r\n\r\n  /**\r\n   * If `true`, the function will be invoked on the leading edge of the timeout.\r\n   * @default true\r\n   */\r\n  leading?: boolean;\r\n\r\n  /**\r\n   * If `true`, the function will be invoked on the trailing edge of the timeout.\r\n   * @default true\r\n   */\r\n  trailing?: boolean;\r\n}\r\n\r\n/**\r\n * Creates a throttled function that only invokes the provided function at most once\r\n * per every `throttleMs` milliseconds. Subsequent calls to the throttled function\r\n * within the wait time will not trigger the execution of the original function.\r\n *\r\n * @template F - The type of function.\r\n * @param {F} func - The function to throttle.\r\n * @param {number} throttleMs - The number of milliseconds to throttle executions to.\r\n * @param {ThrottleOptions} options - The options object\r\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the throttled function.\r\n * @param {boolean} options.leading - If `true`, the function will be invoked on the leading edge of the timeout.\r\n * @param {boolean} options.trailing - If `true`, the function will be invoked on the trailing edge of the timeout.\r\n * @returns {(...args: Parameters<F>) => void} A new throttled function that accepts the same parameters as the original function.\r\n *\r\n * @example\r\n * const throttledFunction = throttle(() => {\r\n *   console.log('Function executed');\r\n * }, 1000);\r\n *\r\n * // Will log 'Function executed' immediately\r\n * throttledFunction();\r\n *\r\n * // Will not log anything as it is within the throttle time\r\n * throttledFunction();\r\n *\r\n * // After 1 second\r\n * setTimeout(() => {\r\n *   throttledFunction(); // Will log 'Function executed'\r\n * }, 1000);\r\n */\r\nexport function throttle<F extends (...args: any[]) => any>(\r\n  func: F,\r\n  throttleMs: number = 0,\r\n  options: ThrottleOptions = {}\r\n): ((...args: Parameters<F>) => ReturnType<F> | undefined) & {\r\n  cancel: () => void;\r\n  flush: () => void;\r\n} {\r\n  if (typeof options !== 'object') {\r\n    options = {};\r\n  }\r\n\r\n  const { leading = true, trailing = true, signal } = options;\r\n\r\n  return debounce(func, throttleMs, { leading, trailing, signal, maxWait: throttleMs });\r\n}\r\n","/**\r\n * Creates a new array filled with the specified value from the start position up to, but not including, the end position.\r\n * This function does not mutate the original array.\r\n *\r\n * @template T - The type of elements in the original array.\r\n * @template U - The type of the value to fill the new array with.\r\n * @param {Array<T>} arr - The array to base the new array on.\r\n * @param {U} value - The value to fill the new array with.\r\n * @returns {Array<T | U>} The new array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * let result = toFilled(array, '*', 2);\r\n * console.log(result); // [1, 2, '*', '*', '*']\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n *\r\n * result = toFilled(array, '*', 1, 4);\r\n * console.log(result); // [1, '*', '*', '*', 5]\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n *\r\n * result = toFilled(array, '*');\r\n * console.log(result); // ['*', '*', '*', '*', '*']\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n *\r\n * result = toFilled(array, '*', -4, -1);\r\n * console.log(result); // [1, '*', '*', '*', 5]\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n */\r\nexport function toFilled<T, U>(arr: readonly T[], value: U): Array<T | U>;\r\n\r\n/**\r\n * Creates a new array filled with the specified value from the start position up to, but not including, the end position.\r\n * This function does not mutate the original array.\r\n *\r\n * @template T - The type of elements in the original array.\r\n * @template U - The type of the value to fill the new array with.\r\n * @param {Array<T>} arr - The array to base the new array on.\r\n * @param {U} value - The value to fill the new array with.\r\n * @param {number} [start=0] - The start position. Defaults to 0.\r\n * @returns {Array<T | U>} The new array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * let result = toFilled(array, '*', 2);\r\n * console.log(result); // [1, 2, '*', '*', '*']\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n *\r\n * result = toFilled(array, '*', 1, 4);\r\n * console.log(result); // [1, '*', '*', '*', 5]\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n *\r\n * result = toFilled(array, '*');\r\n * console.log(result); // ['*', '*', '*', '*', '*']\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n *\r\n * result = toFilled(array, '*', -4, -1);\r\n * console.log(result); // [1, '*', '*', '*', 5]\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n */\r\nexport function toFilled<T, U>(arr: readonly T[], value: U, start: number): Array<T | U>;\r\n\r\n/**\r\n * Creates a new array filled with the specified value from the start position up to, but not including, the end position.\r\n * This function does not mutate the original array.\r\n *\r\n * @template T - The type of elements in the original array.\r\n * @template U - The type of the value to fill the new array with.\r\n * @param {Array<T>} arr - The array to base the new array on.\r\n * @param {U} value - The value to fill the new array with.\r\n * @param {number} [start=0] - The start position. Defaults to 0.\r\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\r\n * @returns {Array<T | U>} The new array with the filled values.\r\n *\r\n * @example\r\n * const array = [1, 2, 3, 4, 5];\r\n * let result = toFilled(array, '*', 2);\r\n * console.log(result); // [1, 2, '*', '*', '*']\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n *\r\n * result = toFilled(array, '*', 1, 4);\r\n * console.log(result); // [1, '*', '*', '*', 5]\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n *\r\n * result = toFilled(array, '*');\r\n * console.log(result); // ['*', '*', '*', '*', '*']\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n *\r\n * result = toFilled(array, '*', -4, -1);\r\n * console.log(result); // [1, '*', '*', '*', 5]\r\n * console.log(array); // [1, 2, 3, 4, 5]\r\n */\r\nexport function toFilled<T, U>(arr: readonly T[], value: U, start: number, end: number): Array<T | U>;\r\n\r\n/**\r\n * Creates a new array filled with the specified value from the start position up to, but not including, the end position.\r\n * This function does not mutate the original array.\r\n *\r\n * @template T - The type of elements in the original array.\r\n * @template U - The type of the value to fill the new array with.\r\n * @param {Array<T>} arr - The array to base the new array on.\r\n * @param {U} value - The value to fill the new array with.\r\n * @param {number} [start=0] - The start position. Defaults to 0.\r\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\r\n * @returns {Array<T | U>} The new array with the filled values.\r\n */\r\nexport function toFilled<T, U>(arr: readonly T[], value: U, start = 0, end = arr.length): Array<T | U> {\r\n  const length = arr.length;\r\n  const finalStart = Math.max(start >= 0 ? start : length + start, 0);\r\n  const finalEnd = Math.min(end >= 0 ? end : length + end, length);\r\n\r\n  const newArr: Array<T | U> = arr.slice();\r\n\r\n  for (let i = finalStart; i < finalEnd; i++) {\r\n    newArr[i] = value;\r\n  }\r\n\r\n  return newArr;\r\n}\r\n","import { toFinite } from './toFinite';\r\n\r\n/**\r\n * Converts `value` to an integer.\r\n * \r\n * This function first converts `value` to a finite number. If the result has any decimal places,\r\n * they are removed by rounding down to the nearest whole number.\r\n *\r\n * @param {unknown} value - The value to convert.\r\n * @returns {number} Returns the number.\r\n *\r\n * @example\r\n * toInteger(3.2); // => 3\r\n * toInteger(Number.MIN_VALUE); // => 0\r\n * toInteger(Infinity); // => 1.7976931348623157e+308\r\n * toInteger('3.2'); // => 3\r\n * toInteger(Symbol.iterator); // => 0\r\n * toInteger(NaN); // => 0\r\n */\r\nexport function toInteger(value?: unknown): number {\r\n  const finite = toFinite(value);\r\n  const remainder = finite % 1;\r\n\r\n  return remainder ? finite - remainder : finite;\r\n}\r\n","import { cloneDeep } from './cloneDeep.ts';\r\nimport { merge } from './merge.ts';\r\n\r\n/**\r\n * Merges the properties of the source object into a deep clone of the target object.\r\n * Unlike `merge`, This function does not modify the original target object.\r\n *\r\n * This function performs a deep merge, meaning nested objects and arrays are merged recursively.\r\n *\r\n * - If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * - If a property in the source object is undefined, it will not overwrite a defined property in the target object.\r\n *\r\n * Note that this function does not mutate the target object.\r\n *\r\n * @param {T} target - The target object to be cloned and merged into. This object is not modified directly.\r\n * @param {S} source - The source object whose properties will be merged into the cloned target object.\r\n * @returns {T & S} A new object with properties from the source object merged into a deep clone of the target object.\r\n *\r\n * @template T - Type of the target object.\r\n * @template S - Type of the source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = toMerged(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = toMerged(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3, 2], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = toMerged(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function toMerged<T, S>(target: T, source: S): T & S;\r\n/**\r\n * Merges the properties of the source object into a deep clone of the target object.\r\n * Unlike `merge`, This function does not modify the original target object.\r\n *\r\n * This function performs a deep merge, meaning nested objects and arrays are merged recursively.\r\n *\r\n * - If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\r\n * - If a property in the source object is undefined, it will not overwrite a defined property in the target object.\r\n *\r\n * Note that this function does not mutate the target object.\r\n *\r\n * @param {T} target - The target object to be cloned and merged into. This object is not modified directly.\r\n * @param {S} source - The source object whose properties will be merged into the cloned target object.\r\n * @returns {T & S} A new object with properties from the source object merged into a deep clone of the target object.\r\n *\r\n * @template T - Type of the target object.\r\n * @template S - Type of the source object.\r\n *\r\n * @example\r\n * const target = { a: 1, b: { x: 1, y: 2 } };\r\n * const source = { b: { y: 3, z: 4 }, c: 5 };\r\n *\r\n * const result = toMerged(target, source);\r\n * console.log(result);\r\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\r\n *\r\n * @example\r\n * const target = { a: [1, 2], b: { x: 1 } };\r\n * const source = { a: [3], b: { y: 2 } };\r\n *\r\n * const result = toMerged(target, source);\r\n * console.log(result);\r\n * // Output: { a: [3, 2], b: { x: 1, y: 2 } }\r\n *\r\n * @example\r\n * const target = { a: null };\r\n * const source = { a: [1, 2, 3] };\r\n *\r\n * const result = toMerged(target, source);\r\n * console.log(result);\r\n * // Output: { a: [1, 2, 3] }\r\n */\r\nexport function toMerged(target: any, source: any) {\r\n  return merge(cloneDeep(target), source);\r\n}\r\n","import { trim as trimToolkit } from '../../string/trim.ts';\r\n\r\n/**\r\n * Removes leading and trailing whitespace or specified characters from a string.\r\n *\r\n * @param {string} str - The string from which leading and trailing characters will be trimmed.\r\n * @param {string | string[]} chars - The character(s) to remove from the end of the string. Defaults to `\" \"`.\r\n * @returns {string} - The resulting string after the specified leading and trailing characters have been removed.\r\n *\r\n * @example\r\n * trim(\"  hello  \"); // \"hello\"\r\n * trim(\"--hello--\", \"-\"); // \"hello\"\r\n * trim(\"##hello##\", [\"#\", \"o\"]); // \"hell\"\r\n */\r\nexport function trim(str: string, chars?: string | string[], guard?: unknown): string {\r\n  if (str == null) {\r\n    return '';\r\n  }\r\n\r\n  if (guard != null || chars == null) {\r\n    return str.toString().trim();\r\n  }\r\n\r\n  switch (typeof chars) {\r\n    case 'string': {\r\n      return trimToolkit(str, chars.toString().split(''));\r\n    }\r\n    case 'object': {\r\n      if (Array.isArray(chars)) {\r\n        return trimToolkit(\r\n          str,\r\n          chars.map(x => x.toString())\r\n        );\r\n      } else {\r\n        return trimToolkit(str, (chars as any).toString().split(''));\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { trimEnd as trimEndToolkit } from '../../string/trimEnd.ts';\r\n\r\n/**\r\n * Removes trailing whitespace or specified characters from a string.\r\n *\r\n * @param {string} str - The string from which trailing characters will be trimmed.\r\n * @param {string | string[]} chars - The character(s) to remove from the end of the string. Defaults to `\" \"`.\r\n * @returns {string} - The resulting string after the specified trailing character has been removed.\r\n *\r\n * @example\r\n * const trimmedStr1 = trimEnd('hello---', '-') // returns 'hello'\r\n * const trimmedStr2 = trimEnd('123000', '0') // returns '123'\r\n * const trimmedStr3 = trimEnd('abcabcabc', 'c') // returns 'abcabcab'\r\n * const trimmedStr4 = trimEnd('trimmedxxx', 'x') // returns 'trimmed'\r\n */\r\nexport function trimEnd(str: string, chars?: string | string[], guard?: unknown): string {\r\n  if (str == null) {\r\n    return '';\r\n  }\r\n\r\n  if (guard != null || chars == null) {\r\n    return str.toString().trimEnd();\r\n  }\r\n\r\n  switch (typeof chars) {\r\n    case 'string': {\r\n      return trimEndToolkit(str, chars.toString().split(''));\r\n    }\r\n    case 'object': {\r\n      if (Array.isArray(chars)) {\r\n        return trimEndToolkit(\r\n          str,\r\n          chars.map(x => x.toString())\r\n        );\r\n      } else {\r\n        return trimEndToolkit(str, (chars as any).toString().split(''));\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { trimStart as trimStartToolkit } from '../../string/trimStart.ts';\r\n\r\n/**\r\n * Removes leading whitespace or specified characters from a string.\r\n *\r\n * @param {string} str - The string from which leading characters will be trimmed.\r\n * @param {string | string[]} chars - The character(s) to remove from the end of the string. Defaults to `\" \"`.\r\n * @returns {string} - The resulting string after the specified leading character has been removed.\r\n *\r\n * @example\r\n * const trimmedStr1 = ltrim('---hello', '-') // returns 'hello'\r\n * const trimmedStr2 = ltrim('000123', '0') // returns '123'\r\n * const trimmedStr3 = ltrim('abcabcabc', 'a') // returns 'bcabcabc'\r\n * const trimmedStr4 = ltrim('xxxtrimmed', 'x') // returns 'trimmed'\r\n */\r\nexport function trimStart(str: string, chars?: string | string[], guard?: unknown): string {\r\n  if (str == null) {\r\n    return '';\r\n  }\r\n\r\n  if (guard != null || chars == null) {\r\n    return str.toString().trimStart();\r\n  }\r\n\r\n  switch (typeof chars) {\r\n    case 'string': {\r\n      return trimStartToolkit(str, chars.toString().split(''));\r\n    }\r\n    case 'object': {\r\n      if (Array.isArray(chars)) {\r\n        return trimStartToolkit(\r\n          str,\r\n          chars.map(x => x.toString())\r\n        );\r\n      } else {\r\n        return trimStartToolkit(str, (chars as any).toString().split(''));\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { ary } from './ary.ts';\r\n\r\n/**\r\n * Creates a function that accepts up to one argument, ignoring any additional arguments.\r\n *\r\n * @template F - The type of the function.\r\n * @param {F} func - The function to cap arguments for.\r\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new capped function.\r\n *\r\n * @example\r\n * function fn(a, b, c) {\r\n *   console.log(arguments);\r\n * }\r\n *\r\n * unary(fn)(1, 2, 3); // [Arguments] { '0': 1 }\r\n */\r\nexport function unary<F extends (...args: any[]) => any>(func: F): (...args: any[]) => ReturnType<F> {\r\n  return ary(func, 1);\r\n}\r\n","/**\r\n * Returns a new array containing only the unique elements from the original array,\r\n * based on the values returned by the mapper function.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @template U - The type of mapped elements.\r\n * @param {T[]} arr - The array to process.\r\n * @param {(item: T) => U} mapper - The function used to convert the array elements.\r\n * @returns {T[]} A new array containing only the unique elements from the original array, based on the values returned by the mapper function.\r\n *\r\n * @example\r\n * ```ts\r\n * uniqBy([1.2, 1.5, 2.1, 3.2, 5.7, 5.3, 7.19], Math.floor);\r\n * // [1.2, 2.1, 3.2, 5.7, 7.19]\r\n * ```\r\n *\r\n * @example\r\n * const array = [\r\n *   { category: 'fruit', name: 'apple' },\r\n *   { category: 'fruit', name: 'banana' },\r\n *   { category: 'vegetable', name: 'carrot' },\r\n * ];\r\n * uniqBy(array, item => item.category).length\r\n * // 2\r\n * ```\r\n */\r\nexport function uniqBy<T, U>(arr: readonly T[], mapper: (item: T) => U): T[] {\r\n  const map = new Map<U, T>();\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const item = arr[i];\r\n    const key = mapper(item);\r\n\r\n    if (!map.has(key)) {\r\n      map.set(key, item);\r\n    }\r\n  }\r\n\r\n  return Array.from(map.values());\r\n}\r\n","/**\r\n * Gathers elements in the same position in an internal array\r\n * from a grouped array of elements and returns them as a new array.\r\n *\r\n * @template T - The type of elements in the nested array.\r\n * @param {Array<[...T]>} zipped - The nested array to unzip.\r\n * @returns {Unzip<T>} A new array of unzipped elements.\r\n *\r\n * @example\r\n * const zipped = [['a', true, 1],['b', false, 2]];\r\n * const result = unzip(zipped);\r\n * // result will be [['a', 'b'], [true, false], [1, 2]]\r\n */\r\nexport function unzip<T extends unknown[]>(zipped: ReadonlyArray<[...T]>): Unzip<T> {\r\n  // For performance reasons, use this implementation instead of\r\n  // const maxLen = Math.max(...zipped.map(arr => arr.length));\r\n  let maxLen = 0;\r\n\r\n  for (let i = 0; i < zipped.length; i++) {\r\n    if (zipped[i].length > maxLen) {\r\n      maxLen = zipped[i].length;\r\n    }\r\n  }\r\n\r\n  const result = new Array(maxLen) as Unzip<T>;\r\n\r\n  for (let i = 0; i < maxLen; i++) {\r\n    result[i] = new Array(zipped.length);\r\n    for (let j = 0; j < zipped.length; j++) {\r\n      result[i][j] = zipped[j][i];\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\ntype Unzip<K extends unknown[]> = { [I in keyof K]: Array<K[I]> };\r\n","/**\r\n * Unzips an array of arrays, applying an `iteratee` function to regrouped elements.\r\n *\r\n * @template T, R\r\n * @param {T[][]} target - The nested array to unzip. This is an array of arrays,\r\n * where each inner array contains elements to be unzipped.\r\n * @param {(...args: T[]) => R} iteratee - A function to transform the unzipped elements.\r\n * @returns {R[]} A new array of unzipped and transformed elements.\r\n *\r\n * @example\r\n * const nestedArray = [[1, 2], [3, 4], [5, 6]];\r\n * const result = unzipWith(nestedArray, (item, item2, item3) => item + item2 + item3);\r\n * // result will be [9, 12]\r\n */\r\nexport function unzipWith<T, R>(target: readonly T[][], iteratee: (...args: T[]) => R): R[] {\r\n  const maxLength = Math.max(...target.map(innerArray => innerArray.length));\r\n  const result: R[] = new Array(maxLength);\r\n\r\n  for (let i = 0; i < maxLength; i++) {\r\n    const group = new Array(target.length);\r\n\r\n    for (let j = 0; j < target.length; j++) {\r\n      group[j] = target[j][i];\r\n    }\r\n\r\n    result[i] = iteratee(...group);\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { upperCase as upperCaseToolkit } from '../../string';\r\nimport { normalizeForCase } from '../_internal/normalizeForCase';\r\n\r\n/**\r\n * Converts a string to upper case.\r\n *\r\n * Upper case is the naming convention in which each word is written in uppercase and separated by an space ( ) character.\r\n *\r\n * @param {string | object} str - The string that is to be changed to upper case.\r\n * @returns {string} - The converted string to upper case.\r\n *\r\n * @example\r\n * const convertedStr1 = upperCase('camelCase') // returns 'CAMEL CASE'\r\n * const convertedStr2 = upperCase('some whitespace') // returns 'SOME WHITESPACE'\r\n * const convertedStr3 = upperCase('hyphen-text') // returns 'HYPHEN TEXT'\r\n * const convertedStr4 = upperCase('HTTPRequest') // returns 'HTTP REQUEST'\r\n */\r\nexport function upperCase(str?: string | object): string {\r\n  return upperCaseToolkit(normalizeForCase(str));\r\n}\r\n","import { getWords } from './_internal/getWords.ts';\r\n\r\n/**\r\n * Converts a string to upper case.\r\n *\r\n * Upper case is the naming convention in which each word is written in uppercase and separated by an space ( ) character.\r\n *\r\n * @param {string} str - The string that is to be changed to upper case.\r\n * @returns {string} - The converted string to upper case.\r\n *\r\n * @example\r\n * const convertedStr1 = upperCase('camelCase') // returns 'CAMEL CASE'\r\n * const convertedStr2 = upperCase('some whitespace') // returns 'SOME WHITESPACE'\r\n * const convertedStr3 = upperCase('hyphen-text') // returns 'HYPHEN TEXT'\r\n * const convertedStr4 = upperCase('HTTPRequest') // returns 'HTTP REQUEST'\r\n */\r\nexport function upperCase(str: string): string {\r\n  const words = getWords(str);\r\n\r\n  let result = '';\r\n\r\n  for (let i = 0; i < words.length; i++) {\r\n    result += words[i].toUpperCase();\r\n    if (i < words.length - 1) {\r\n      result += ' ';\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Converts the first character of string to upper case.\r\n *\r\n * @param {string} str - The string that is to be changed\r\n * @returns {string} - The converted string.\r\n *\r\n * @example\r\n * const convertedStr1 = upperFirst('fred') // returns 'Fred'\r\n * const convertedStr2 = upperFirst('Fred') // returns 'Fred'\r\n * const convertedStr3 = upperFirst('FRED') // returns 'FRED'\r\n */\r\nexport function upperFirst(str: string): string {\r\n  return str.substring(0, 1).toUpperCase() + str.substring(1);\r\n}\r\n","import { timeout } from './timeout.ts';\r\n\r\n/**\r\n * Executes an async function and enforces a timeout.\r\n *\r\n * If the promise does not resolve within the specified time,\r\n * the timeout will trigger and the returned promise will be rejected.\r\n *\r\n *\r\n * @template T\r\n * @param {() => Promise<T>} run - A function that returns a promise to be executed.\r\n * @param {number} ms - The timeout duration in milliseconds.\r\n * @returns {Promise<T>} A promise that resolves with the result of the `run` function or rejects if the timeout is reached.\r\n *\r\n * @example\r\n * async function fetchData() {\r\n *   const response = await fetch('https://example.com/data');\r\n *   return response.json();\r\n * }\r\n *\r\n * try {\r\n *   const data = await withTimeout(fetchData, 1000);\r\n *   console.log(data); // Logs the fetched data if `fetchData` is resolved within 1 second.\r\n * } catch (error) {\r\n *   console.error(error); // Will log 'TimeoutError' if `fetchData` is not resolved within 1 second.\r\n * }\r\n */\r\nexport async function withTimeout<T>(run: () => Promise<T>, ms: number): Promise<T> {\r\n  return Promise.race([run(), timeout(ms) as T]);\r\n}\r\n","/**\r\n * Creates an array that excludes all specified values.\r\n *\r\n * It correctly excludes `NaN`, as it compares values using [SameValueZero](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-samevaluezero).\r\n *\r\n * @template T The type of elements in the array.\r\n * @param {T[]} array - The array to filter.\r\n * @param {...T[]} values - The values to exclude.\r\n * @returns {T[]} A new array without the specified values.\r\n *\r\n * @example\r\n * // Removes the specified values from the array\r\n * without([1, 2, 3, 4, 5], 2, 4);\r\n * // Returns: [1, 3, 5]\r\n *\r\n * @example\r\n * // Removes specified string values from the array\r\n * without(['a', 'b', 'c', 'a'], 'a');\r\n * // Returns: ['b', 'c']\r\n */\r\nexport function without<T>(array: readonly T[], ...values: T[]): T[] {\r\n  const valuesSet = new Set(values);\r\n  return array.filter(item => !valuesSet.has(item));\r\n}\r\n","import { difference } from './difference.ts';\r\nimport { intersection } from './intersection.ts';\r\nimport { union } from './union.ts';\r\n\r\n/**\r\n * Computes the symmetric difference between two arrays. The symmetric difference is the set of elements\r\n * which are in either of the arrays, but not in their intersection.\r\n *\r\n * @template T - The type of elements in the array.\r\n * @param {T[]} arr1 - The first array.\r\n * @param {T[]} arr2 - The second array.\r\n * @returns {T[]} An array containing the elements that are present in either `arr1` or `arr2` but not in both.\r\n *\r\n * @example\r\n * // Returns [1, 2, 5, 6]\r\n * xor([1, 2, 3, 4], [3, 4, 5, 6]);\r\n *\r\n * @example\r\n * // Returns ['a', 'c']\r\n * xor(['a', 'b'], ['b', 'c']);\r\n */\r\nexport function xor<T>(arr1: readonly T[], arr2: readonly T[]): T[] {\r\n  return difference(union(arr1, arr2), intersection(arr1, arr2));\r\n}\r\n","import { differenceBy } from './differenceBy.ts';\r\nimport { intersectionBy } from './intersectionBy.ts';\r\nimport { unionBy } from './unionBy.ts';\r\n\r\n/**\r\n * Computes the symmetric difference between two arrays using a custom mapping function.\r\n * The symmetric difference is the set of elements which are in either of the arrays,\r\n * but not in their intersection, determined by the result of the mapping function.\r\n *\r\n * @template T - Type of elements in the input arrays.\r\n * @template U - Type of the values returned by the mapping function.\r\n *\r\n * @param {T[]} arr1 - The first array.\r\n * @param {T[]} arr2 - The second array.\r\n * @param {(item: T) => U} mapper - The function to map array elements to comparison values.\r\n * @returns {T[]} An array containing the elements that are present in either `arr1` or `arr2` but not in both, based on the values returned by the mapping function.\r\n *\r\n * @example\r\n * // Custom mapping function for objects with an 'id' property\r\n * const idMapper = obj => obj.id;\r\n * xorBy([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], idMapper);\r\n * // Returns [{ id: 1 }, { id: 3 }]\r\n */\r\nexport function xorBy<T, U>(arr1: readonly T[], arr2: readonly T[], mapper: (item: T) => U): T[] {\r\n  const union = unionBy(arr1, arr2, mapper);\r\n  const intersection = intersectionBy(arr1, arr2, mapper);\r\n\r\n  return differenceBy(union, intersection, mapper);\r\n}\r\n","import { differenceWith } from './differenceWith.ts';\r\nimport { intersectionWith } from './intersectionWith.ts';\r\nimport { unionWith } from './unionWith.ts';\r\n\r\n/**\r\n * Computes the symmetric difference between two arrays using a custom equality function.\r\n * The symmetric difference is the set of elements which are in either of the arrays,\r\n * but not in their intersection.\r\n *\r\n * @template T - Type of elements in the input arrays.\r\n *\r\n * @param {T[]} arr1 - The first array.\r\n * @param {T[]} arr2 - The second array.\r\n * @param {(item1: T, item2: T) => boolean} areElementsEqual - The custom equality function to compare elements.\r\n * @returns {T[]} An array containing the elements that are present in either `arr1` or `arr2` but not in both, based on the custom equality function.\r\n *\r\n * @example\r\n * // Custom equality function for objects with an 'id' property\r\n * const areObjectsEqual = (a, b) => a.id === b.id;\r\n * xorWith([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], areObjectsEqual);\r\n * // Returns [{ id: 1 }, { id: 3 }]\r\n */\r\nexport function xorWith<T>(\r\n  arr1: readonly T[],\r\n  arr2: readonly T[],\r\n  areElementsEqual: (item1: T, item2: T) => boolean\r\n): T[] {\r\n  const union = unionWith(arr1, arr2, areElementsEqual);\r\n  const intersection = intersectionWith(arr1, arr2, areElementsEqual);\r\n\r\n  return differenceWith(union, intersection, areElementsEqual);\r\n}\r\n","/**\r\n * Combines two arrays, one of property names and one of corresponding values, into a single object.\r\n *\r\n * This function takes two arrays: one containing property names and another containing corresponding values.\r\n * It returns a new object where the property names from the first array are keys, and the corresponding elements\r\n * from the second array are values. If the `keys` array is longer than the `values` array, the remaining keys will\r\n * have `undefined` as their values.\r\n *\r\n * @template P - The type of elements in the array.\r\n * @template V - The type of elements in the array.\r\n * @param {P[]} keys - An array of property names.\r\n * @param {V[]} values - An array of values corresponding to the property names.\r\n * @returns {Record<P, V>} - A new object composed of the given property names and values.\r\n *\r\n * @example\r\n * const keys = ['a', 'b', 'c'];\r\n * const values = [1, 2, 3];\r\n * const result = zipObject(keys, values);\r\n * // result will be { a: 1, b: 2, c: 3 }\r\n *\r\n * const keys2 = ['a', 'b', 'c'];\r\n * const values2 = [1, 2];\r\n * const result2 = zipObject(keys2, values2);\r\n * // result2 will be { a: 1, b: 2, c: undefined }\r\n *\r\n * const keys2 = ['a', 'b'];\r\n * const values2 = [1, 2, 3];\r\n * const result2 = zipObject(keys2, values2);\r\n * // result2 will be { a: 1, b: 2 }\r\n */\r\nexport function zipObject<P extends PropertyKey, V>(keys: readonly P[], values: readonly V[]): Record<P, V> {\r\n  const result = {} as Record<P, V>;\r\n\r\n  for (let i = 0; i < keys.length; i++) {\r\n    result[keys[i]] = values[i];\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { zip } from '../../array/zip.ts';\r\nimport { set } from '../object/set.ts';\r\n\r\n/**\r\n * Creates a deeply nested object given arrays of paths and values.\r\n *\r\n * This function takes two arrays: one containing arrays of property paths, and the other containing corresponding values.\r\n * It returns a new object where paths from the first array are used as key paths to set values, with corresponding elements from the second array as values.\r\n * Paths can be dot-separated strings or arrays of property names.\r\n *\r\n * If the `keys` array is longer than the `values` array, the remaining keys will have `undefined` as their values.\r\n *\r\n * @template P - The type of property paths.\r\n * @template V - The type of values corresponding to the property paths.\r\n * @param {P[] | P[][]} keys - An array of property paths, each path can be a dot-separated string or an array of property names.\r\n * @param {V[]} values - An array of values corresponding to the property paths.\r\n * @returns {object} A new object composed of the given property paths and values.\r\n *\r\n * @example\r\n * const paths = ['a.b.c', 'd.e.f'];\r\n * const values = [1, 2];\r\n * const result = zipObjectDeep(paths, values);\r\n * // result will be { a: { b: { c: 1 } }, d: { e: { f: 2 } } }\r\n *\r\n * @example\r\n * const paths = [['a', 'b', 'c'], ['d', 'e', 'f']];\r\n * const values = [1, 2];\r\n * const result = zipObjectDeep(paths, values);\r\n * // result will be { a: { b: { c: 1 } }, d: { e: { f: 2 } } }\r\n *\r\n * @example\r\n * const paths = ['a.b[0].c', 'a.b[1].d'];\r\n * const values = [1, 2];\r\n * const result = zipObjectDeep(paths, values);\r\n * // result will be { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\r\n */\r\nexport function zipObjectDeep<P extends PropertyKey, V>(\r\n  keys: readonly P[] | readonly P[][],\r\n  values: readonly V[]\r\n): { [K in P]: V } {\r\n  const result = {} as { [K in P]: V };\r\n  const zipped = zip<P | P[], V>(keys, values);\r\n\r\n  for (let i = 0; i < zipped.length; i++) {\r\n    const [key, value] = zipped[i];\r\n\r\n    if (key != null) {\r\n      set(result, key, value);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Combines multiple arrays into a single array using a custom combiner function.\r\n *\r\n * This function takes multiple arrays and a combiner function, and returns a new array where each element\r\n * is the result of applying the combiner function to the corresponding elements of the input arrays.\r\n *\r\n * @template T - The type of elements in the first array.\r\n * @template R - The type of elements in the resulting array.\r\n * @param {T[]} arr1 - The first array to zip.\r\n * @param {(...items: T[]) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\r\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\r\n *\r\n * @example\r\n * // Example usage with two arrays:\r\n * const arr1 = [1, 2, 3];\r\n * const arr2 = [4, 5, 6];\r\n * const result = zipWith(arr1, arr2, (a, b) => a + b);\r\n * // result will be [5, 7, 9]\r\n *\r\n * @example\r\n * // Example usage with three arrays:\r\n * const arr1 = [1, 2];\r\n * const arr2 = [3, 4];\r\n * const arr3 = [5, 6];\r\n * const result = zipWith(arr1, arr2, arr3, (a, b, c) => `${a}${b}${c}`);\r\n * // result will be [`135`, `246`]\r\n */\r\nexport function zipWith<T, R>(arr1: readonly T[], combine: (item: T) => R): R[];\r\n/**\r\n * Combines two arrays into a single array using a custom combiner function.\r\n *\r\n * @template T - The type of elements in the first array.\r\n * @template U - The type of elements in the second array.\r\n * @template R - The type of elements in the resulting array.\r\n * @param {T[]} arr1 - The first array to zip.\r\n * @param {U[]} arr2 - The second array to zip.\r\n * @param {(item1: T, item2: U) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\r\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\r\n */\r\nexport function zipWith<T, U, R>(arr1: readonly T[], arr2: readonly U[], combine: (item1: T, item2: U) => R): R[];\r\n/**\r\n * Combines three arrays into a single array using a custom combiner function.\r\n *\r\n * @template T - The type of elements in the first array.\r\n * @template U - The type of elements in the second array.\r\n * @template V - The type of elements in the third array.\r\n * @template R - The type of elements in the resulting array.\r\n * @param {T[]} arr1 - The first array to zip.\r\n * @param {U[]} arr2 - The second array to zip.\r\n * @param {V[]} arr3 - The third array to zip.\r\n * @param {(item1: T, item2: U, item3: V) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\r\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\r\n */\r\nexport function zipWith<T, U, V, R>(\r\n  arr1: readonly T[],\r\n  arr2: readonly U[],\r\n  arr3: readonly V[],\r\n  combine: (item1: T, item2: U, item3: V) => R\r\n): R[];\r\n/**\r\n * Combines four arrays into a single array using a custom combiner function.\r\n *\r\n * @template T - The type of elements in the first array.\r\n * @template U - The type of elements in the second array.\r\n * @template V - The type of elements in the third array.\r\n * @template W - The type of elements in the fourth array.\r\n * @template R - The type of elements in the resulting array.\r\n * @param {T[]} arr1 - The first array to zip.\r\n * @param {U[]} arr2 - The second array to zip.\r\n * @param {V[]} arr3 - The third array to zip.\r\n * @param {W[]} arr4 - The fourth array to zip.\r\n * @param {(item1: T, item2: U, item3: V, item4: W) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\r\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\r\n */\r\nexport function zipWith<T, U, V, W, R>(\r\n  arr1: readonly T[],\r\n  arr2: readonly U[],\r\n  arr3: readonly V[],\r\n  arr4: readonly W[],\r\n  combine: (item1: T, item2: U, item3: V, item4: W) => R\r\n): R[];\r\n\r\n/**\r\n * Combines multiple arrays into a single array using a custom combiner function.\r\n *\r\n * This function takes one array and a variable number of additional arrays,\r\n * applying the provided combiner function to the corresponding elements of each array.\r\n * If the input arrays are of different lengths, the resulting array will have the length\r\n * of the longest input array, with undefined values for missing elements.\r\n *\r\n * @template T - The type of elements in the input arrays.\r\n * @template R - The type of elements in the resulting array.\r\n * @param {T[]} arr1 - The first array to zip.\r\n * @param {...Array<T[]>} rest - The additional arrays to zip together, followed by the combiner function.\r\n * @param {(...items: T[]) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\r\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\r\n *\r\n * @example\r\n * const arr1 = [1, 2, 3];\r\n * const arr2 = ['a', 'b', 'c'];\r\n * const result = zipWith(arr1, arr2, (num, char) => `${num}${char}`);\r\n * // result will be ['1a', '2b', '3c']\r\n */\r\nexport function zipWith<T, R>(arr1: readonly T[], ...rest: any[]): R[] {\r\n  const arrs = [arr1, ...rest.slice(0, -1)];\r\n  const combine = rest[rest.length - 1] as (...items: T[]) => R;\r\n\r\n  const maxIndex = Math.max(...arrs.map(arr => arr.length));\r\n  const result: R[] = Array(maxIndex);\r\n\r\n  for (let i = 0; i < maxIndex; i++) {\r\n    const elements: T[] = arrs.map(arr => arr[i]);\r\n    result[i] = combine(...elements);\r\n  }\r\n\r\n  return result;\r\n}\r\n"],"names":["at","arr","indices","result","i","length","index","difference","firstArr","secondArr","secondSet","Set","filter","item","has","differenceBy","mapper","mappedSecondSet","map","differenceWith","areItemsEqual","firstItem","every","secondItem","flatten","depth","flooredDepth","Math","floor","recursive","currentDepth","Array","isArray","push","head","intersection","intersectionBy","intersectionWith","some","random","minimum","maximum","Error","randomInt","uniq","from","union","arr1","arr2","concat","unionBy","Map","items","key","set","values","uniqWith","v","unionWith","zip","arrs","rowCount","max","x","columnCount","row","j","AbortError","constructor","message","super","this","name","TimeoutError","debounce","func","debounceMs","signal","edges","pendingThis","pendingArgs","leading","includes","trailing","invoke","apply","undefined","timeoutId","schedule","clearTimeout","setTimeout","cancel","onTimerEnd","cancelTimer","debounced","args","aborted","isFirstCall","flush","addEventListener","once","noop","ary","n","slice","partial","partialArgs","providedArgs","startIndex","arg","placeholder","partialPlaceholder","Symbol","partialRight","placeholderLength","partialRightPlaceholder","rangeLength","providedIndex","sum","nums","mean","isTypedArray","ArrayBuffer","isView","DataView","isPrimitive","value","clone","obj","SharedArrayBuffer","prototype","Object","getPrototypeOf","Constructor","Date","RegExp","newRegExp","lastIndex","buffer","newError","stack","cause","File","type","lastModified","newObject","create","assign","isPlainObject","object","toString","proto","flattenObjectImpl","prefix","keys","prefixedKey","mapKeys","getNewKey","mapValues","getNewValue","cloneDeep","cloneDeepImpl","get","hasOwnProperty","call","input","getTime","source","flags","entries","add","Buffer","isBuffer","subarray","copyProperties","Blob","target","descriptor","getOwnPropertyDescriptor","writable","isObjectLike","merge","sourceKeys","sourceValue","targetValue","stringTag","numberTag","booleanTag","argumentsTag","objectTag","getSymbols","getOwnPropertySymbols","symbol","propertyIsEnumerable","getTag","areObjectsEqual","a","b","is","aTag","bTag","valueOf","y","Number","isNaN","aStack","bStack","size","aValues","bValues","aValue","findIndex","bValue","splice","byteLength","Uint8Array","byteOffset","aKeys","bKeys","propKey","aProp","delete","isLength","isSafeInteger","delay","ms","Promise","resolve","reject","abortError","abortHandler","removeEventListener","async","timeout","capitalize","str","charAt","toUpperCase","toLowerCase","CASE_SPLIT_PATTERN","getWords","match","trimStart","chars","substring","trimEnd","endIndex","trim","deburrMap","htmlEscapes","htmlUnescapes","isDeepKey","toKey","DOTS_KEY","ESCAPE_REGEXP","PROPERTY_REGEXP","toPath","deepKey","test","split","matches","matchAll","expr","quote","substr","replace","path","defaultValue","getWithPath","current","String","property","isMatch","isArrayMatch","isMapMatch","isSetMatch","countedIndex","sourceItem","targetItem","cloneDeepToolkit","iterator","IS_UNSIGNED_INTEGER","isIndex","isInteger","MAX_SAFE_INTEGER","isArguments","resolvedPath","matchesProperty","Boolean","isConcatSpreadable","getPriority","compareValues","order","localeCompare","aPriority","bPriority","isSymbol","regexIsDeepProp","regexIsPlainProp","orderBy","collection","criteria","orders","getValueByNestedPath","preparedCriteria","criterion","isKey","original","hasOwn","getValueByCriterion","sort","comparedResult","identity","nextKey","bind","thisObj","bound","bindPlaceholder","bindKey","bindKeyPlaceholder","curry","arity","guard","parseInt","wrapper","holders","makeCurry","curryPlaceholder","composeArgs","options","maxWait","pendingAt","_debounced","debounceToolkit","now","isNil","unset","unsetWithPath","parent","lastKey","tag","toStringTag","isTypedArrayToolkit","mergeWith","otherArgs","sources","mergeWithDeep","cloned","targetKeys","Reflect","ownKeys","targetKey","merged","isArrayLike","conformsTo","predicate","join","normalizeForCase","clamp","bound1","bound2","min","clampToolkit","decimalAdjust","number","precision","magnitude","exponent","adjustedValue","newMagnitude","newExponent","toNumber","NaN","toFinite","Infinity","MAX_VALUE","after","counter","aryToolkit","attempt","e","before","camelCase","words","first","rest","word","camelCaseToolkit","castArray","arguments","ceil","chunk","chunkLength","start","end","chunkToolkit","compact","conforms","constantCase","countBy","deburr","normalize","char","defer","TypeError","differenceToolkit","drop","itemsCount","dropRight","dropRightWhile","canContinueDropping","dropWhile","dropEndIndex","endsWith","position","escape","escapeRegExp","fill","array","finalStart","finalEnd","fillToolkit","find","doesMatch","entry","findLastIndex","fromIndex","flatMap","iteratee","flatMapDeep","flattenDeep","flattenDepth","flattenObject","flow","funcs","forEachRight","callback","fromPairs","pairs","groupBy","getKeyFromItem","inRange","inRangeToolkit","indexOf","searchElement","initial","invert","isArrayLikeObject","isBoolean","isDate","isEqual","isError","isFinite","isFunction","isMap","isNotNil","isNull","isNumber","isObject","isRegExp","isRegExpToolkit","isSet","isString","isSubset","superset","subset","isUndefined","isWeakMap","WeakMap","isWeakMapToolkit","isWeakSet","WeakSet","isWeakSetToolkit","separator","kebabCase","kebabCaseToolkit","keyBy","last","lowerCase","lowerCaseToolkit","lowerFirst","mapKeysToolkit","mapValuesToolkit","maxElement","element","maxBy","getValue","meanBy","memoize","fn","cache","getCacheKey","memoizedFn","minElement","minBy","negate","omit","keysArr","omitBy","shouldOmit","objEntries","called","pad","padStart","padEnd","padToolkit","string","radix","partition","isInTruthy","truthy","falsy","pascalCase","pick","pickBy","shouldPick","pullAt","indicesToRemove","removed","floating","randomToolkit","randomIntToolkit","range","step","rearg","flattenIndices","reorderedArgs","repeat","params","restToolkit","round","sample","sampleSize","selected","resultIndex","shuffle","snakeCase","snakeCaseToolkit","sortBy","spread","argsIndex","startCase","startsWith","sumBy","tail","take","count","takeRight","takeRightWhile","shouldContinueTaking","takeWhile","throttle","throttleMs","toFilled","newArr","toInteger","finite","remainder","toMerged","trimToolkit","trimEndToolkit","trimStartToolkit","unary","unescape","uniqBy","unzip","zipped","maxLen","unzipWith","maxLength","innerArray","group","upperCase","upperCaseToolkit","upperFirst","withTimeout","run","race","without","valuesSet","xor","xorBy","xorWith","areElementsEqual","zipObject","zipObjectDeep","zipWith","combine","maxIndex","elements"],"mappings":"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"}